!function(t){var s={};function r(e){if(s[e])return s[e].exports;var n=s[e]={i:e,l:!1,exports:{}};return t[e].call(n.exports,n,n.exports,r),n.l=!0,n.exports}r.m=t,r.c=s,r.d=function(e,n,t){r.o(e,n)||Object.defineProperty(e,n,{enumerable:!0,get:t})},r.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},r.t=function(n,e){if(1&e&&(n=r(n)),8&e)return n;if(4&e&&"object"==typeof n&&n&&n.__esModule)return n;var t=Object.create(null);if(r.r(t),Object.defineProperty(t,"default",{enumerable:!0,value:n}),2&e&&"string"!=typeof n)for(var s in n)r.d(t,s,function(e){return n[e]}.bind(null,s));return t},r.n=function(e){var n=e&&e.__esModule?function(){return e.default}:function(){return e};return r.d(n,"a",n),n},r.o=function(e,n){return Object.prototype.hasOwnProperty.call(e,n)},r.p="",r(r.s="./src/electron.js")}({"./node_modules/@paulcbetts/mime-db/db.json":
/*!**************************************************!*\
  !*** ./node_modules/@paulcbetts/mime-db/db.json ***!
  \**************************************************/
/*! exports provided: application/font-woff, application/font-woff2, application/javascript, application/pdf, application/postscript, application/x-font-otf, application/x-font-ttf, application/xml, application/zip, audio/midi, audio/mpeg, audio/wav, audio/wave, audio/x-aiff, audio/x-wav, font/opentype, image/bmp, image/gif, image/jpeg, image/png, image/svg+xml, image/tiff, image/webp, image/x-icon, image/x-ms-bmp, text/coffeescript, text/css, text/html, text/jsx, text/less, text/plain, text/x-sass, text/x-scss, text/xml, video/mp4, video/mpeg, video/quicktime, video/webm, video/x-fli, video/x-m4v, video/x-ms-asf, video/x-msvideo, default */function(module){eval('module.exports = JSON.parse("{\\"application/font-woff\\":{\\"source\\":\\"apache\\",\\"extensions\\":[\\"woff\\"]},\\"application/font-woff2\\":{\\"compressible\\":false,\\"extensions\\":[\\"woff2\\"]},\\"application/javascript\\":{\\"source\\":\\"apache\\",\\"extensions\\":[\\"js\\"]},\\"application/pdf\\":{\\"source\\":\\"apache\\",\\"extensions\\":[\\"pdf\\"]},\\"application/postscript\\":{\\"source\\":\\"apache\\",\\"extensions\\":[\\"ai\\",\\"eps\\",\\"ps\\"]},\\"application/x-font-otf\\":{\\"source\\":\\"apache\\",\\"extensions\\":[\\"otf\\"]},\\"application/x-font-ttf\\":{\\"source\\":\\"apache\\",\\"extensions\\":[\\"ttf\\",\\"ttc\\"]},\\"application/xml\\":{\\"source\\":\\"apache\\",\\"extensions\\":[\\"xml\\",\\"xsl\\"]},\\"application/zip\\":{\\"source\\":\\"apache\\",\\"extensions\\":[\\"zip\\"]},\\"audio/midi\\":{\\"source\\":\\"apache\\",\\"extensions\\":[\\"mid\\",\\"midi\\",\\"kar\\",\\"rmi\\"]},\\"audio/mpeg\\":{\\"source\\":\\"apache\\",\\"extensions\\":[\\"mpga\\",\\"mp2\\",\\"mp2a\\",\\"mp3\\",\\"m2a\\",\\"m3a\\"]},\\"audio/wav\\":{\\"compressible\\":false,\\"extensions\\":[\\"wav\\"]},\\"audio/wave\\":{\\"compressible\\":false,\\"extensions\\":[\\"wav\\"]},\\"audio/x-aiff\\":{\\"source\\":\\"apache\\",\\"extensions\\":[\\"aif\\",\\"aiff\\",\\"aifc\\"]},\\"audio/x-wav\\":{\\"source\\":\\"apache\\",\\"extensions\\":[\\"wav\\"]},\\"font/opentype\\":{\\"compressible\\":true,\\"extensions\\":[\\"otf\\"]},\\"image/bmp\\":{\\"source\\":\\"apache\\",\\"extensions\\":[\\"bmp\\"]},\\"image/gif\\":{\\"source\\":\\"apache\\",\\"extensions\\":[\\"gif\\"]},\\"image/jpeg\\":{\\"source\\":\\"apache\\",\\"extensions\\":[\\"jpeg\\",\\"jpg\\",\\"jpe\\"]},\\"image/png\\":{\\"source\\":\\"apache\\",\\"extensions\\":[\\"png\\"]},\\"image/svg+xml\\":{\\"source\\":\\"apache\\",\\"extensions\\":[\\"svg\\",\\"svgz\\"]},\\"image/tiff\\":{\\"source\\":\\"apache\\",\\"extensions\\":[\\"tiff\\",\\"tif\\"]},\\"image/webp\\":{\\"source\\":\\"apache\\",\\"extensions\\":[\\"webp\\"]},\\"image/x-icon\\":{\\"source\\":\\"apache\\",\\"extensions\\":[\\"ico\\"]},\\"image/x-ms-bmp\\":{\\"source\\":\\"nginx\\",\\"extensions\\":[\\"bmp\\"]},\\"text/coffeescript\\":{\\"extensions\\":[\\"coffee\\",\\"litcoffee\\"]},\\"text/css\\":{\\"source\\":\\"apache\\",\\"extensions\\":[\\"css\\"]},\\"text/html\\":{\\"source\\":\\"apache\\",\\"extensions\\":[\\"html\\",\\"htm\\",\\"shtml\\"]},\\"text/jsx\\":{\\"compressible\\":true,\\"extensions\\":[\\"jsx\\"]},\\"text/less\\":{\\"extensions\\":[\\"less\\"]},\\"text/plain\\":{\\"source\\":\\"apache\\",\\"extensions\\":[\\"txt\\",\\"text\\",\\"conf\\",\\"def\\",\\"list\\",\\"log\\",\\"in\\"]},\\"text/x-sass\\":{\\"extensions\\":[\\"sass\\"]},\\"text/x-scss\\":{\\"extensions\\":[\\"scss\\"]},\\"text/xml\\":{\\"source\\":\\"nginx\\",\\"extensions\\":[\\"xml\\"]},\\"video/mp4\\":{\\"source\\":\\"apache\\",\\"extensions\\":[\\"mp4\\",\\"mp4v\\",\\"mpg4\\"]},\\"video/mpeg\\":{\\"source\\":\\"apache\\",\\"extensions\\":[\\"mpeg\\",\\"mpg\\",\\"mpe\\",\\"m1v\\",\\"m2v\\"]},\\"video/quicktime\\":{\\"source\\":\\"apache\\",\\"extensions\\":[\\"qt\\",\\"mov\\"]},\\"video/webm\\":{\\"source\\":\\"apache\\",\\"extensions\\":[\\"webm\\"]},\\"video/x-fli\\":{\\"source\\":\\"apache\\",\\"extensions\\":[\\"fli\\"]},\\"video/x-m4v\\":{\\"source\\":\\"apache\\",\\"extensions\\":[\\"m4v\\"]},\\"video/x-ms-asf\\":{\\"source\\":\\"apache\\",\\"extensions\\":[\\"asf\\",\\"asx\\"]},\\"video/x-msvideo\\":{\\"source\\":\\"apache\\",\\"extensions\\":[\\"avi\\"]}}");\n\n//# sourceURL=webpack:///./node_modules/@paulcbetts/mime-db/db.json?')},"./node_modules/@paulcbetts/mime-db/index.js":
/*!***************************************************!*\
  !*** ./node_modules/@paulcbetts/mime-db/index.js ***!
  \***************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){eval('/*!\n * mime-db\n * Copyright(c) 2014 Jonathan Ong\n * MIT Licensed\n */\n\n/**\n * Module exports.\n */\n\nmodule.exports = __webpack_require__(/*! ./db.json */ "./node_modules/@paulcbetts/mime-db/db.json")\n\n\n//# sourceURL=webpack:///./node_modules/@paulcbetts/mime-db/index.js?')},"./node_modules/@paulcbetts/mime-types/index.js":
/*!******************************************************!*\
  !*** ./node_modules/@paulcbetts/mime-types/index.js ***!
  \******************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){"use strict";eval("/*!\n * mime-types\n * Copyright(c) 2014 Jonathan Ong\n * Copyright(c) 2015 Douglas Christopher Wilson\n * MIT Licensed\n */\n\n\n\n/**\n * Module dependencies.\n * @private\n */\n\nvar db = __webpack_require__(/*! @paulcbetts/mime-db */ \"./node_modules/@paulcbetts/mime-db/index.js\")\nvar extname = __webpack_require__(/*! path */ \"path\").extname\n\n/**\n * Module variables.\n * @private\n */\n\nvar extractTypeRegExp = /^\\s*([^;\\s]*)(?:;|\\s|$)/\nvar textTypeRegExp = /^text\\//i\n\n/**\n * Module exports.\n * @public\n */\n\nexports.charset = charset\nexports.charsets = { lookup: charset }\nexports.contentType = contentType\nexports.extension = extension\nexports.extensions = Object.create(null)\nexports.lookup = lookup\nexports.types = Object.create(null)\n\n// Populate the extensions/types maps\npopulateMaps(exports.extensions, exports.types)\n\n/**\n * Get the default charset for a MIME type.\n *\n * @param {string} type\n * @return {boolean|string}\n */\n\nfunction charset(type) {\n  if (!type || typeof type !== 'string') {\n    return false\n  }\n\n  // TODO: use media-typer\n  var match = extractTypeRegExp.exec(type)\n  var mime = match && db[match[1].toLowerCase()]\n\n  if (mime && mime.charset) {\n    return mime.charset\n  }\n\n  // default text/* to utf-8\n  if (match && textTypeRegExp.test(match[1])) {\n    return 'UTF-8'\n  }\n\n  return false\n}\n\n/**\n * Create a full Content-Type header given a MIME type or extension.\n *\n * @param {string} str\n * @return {boolean|string}\n */\n\nfunction contentType(str) {\n  // TODO: should this even be in this module?\n  if (!str || typeof str !== 'string') {\n    return false\n  }\n\n  var mime = str.indexOf('/') === -1\n    ? exports.lookup(str)\n    : str\n\n  if (!mime) {\n    return false\n  }\n\n  // TODO: use content-type or other module\n  if (mime.indexOf('charset') === -1) {\n    var charset = exports.charset(mime)\n    if (charset) mime += '; charset=' + charset.toLowerCase()\n  }\n\n  return mime\n}\n\n/**\n * Get the default extension for a MIME type.\n *\n * @param {string} type\n * @return {boolean|string}\n */\n\nfunction extension(type) {\n  if (!type || typeof type !== 'string') {\n    return false\n  }\n\n  // TODO: use media-typer\n  var match = extractTypeRegExp.exec(type)\n\n  // get extensions\n  var exts = match && exports.extensions[match[1].toLowerCase()]\n\n  if (!exts || !exts.length) {\n    return false\n  }\n\n  return exts[0]\n}\n\n/**\n * Lookup the MIME type for a file path/extension.\n *\n * @param {string} path\n * @return {boolean|string}\n */\n\nfunction lookup(path) {\n  if (!path || typeof path !== 'string') {\n    return false\n  }\n\n  // get the extension (\"ext\" or \".ext\" or full path)\n  var extension = extname('x.' + path)\n    .toLowerCase()\n    .substr(1)\n\n  if (!extension) {\n    return false\n  }\n\n  return exports.types[extension] || false\n}\n\n/**\n * Populate the extensions and types maps.\n * @private\n */\n\nfunction populateMaps(extensions, types) {\n  // source preference (least -> most)\n  var preference = ['nginx', 'apache', undefined, 'iana']\n\n  Object.keys(db).forEach(function forEachMimeType(type) {\n    var mime = db[type]\n    var exts = mime.extensions\n\n    if (!exts || !exts.length) {\n      return\n    }\n\n    // mime -> extensions\n    extensions[type] = exts\n\n    // extension -> mime\n    for (var i = 0; i < exts.length; i++) {\n      var extension = exts[i]\n\n      if (types[extension]) {\n        var from = preference.indexOf(db[types[extension]].source)\n        var to = preference.indexOf(mime.source)\n\n        if (types[extension] !== 'application/octet-stream'\n          && from > to || (from === to && types[extension].substr(0, 12) === 'application/')) {\n          // skip the remapping\n          continue\n        }\n      }\n\n      // set the extension -> mime\n      types[extension] = type\n    }\n  })\n}\n\n\n//# sourceURL=webpack:///./node_modules/@paulcbetts/mime-types/index.js?")},"./node_modules/debug/src/browser.js":
/*!*******************************************!*\
  !*** ./node_modules/debug/src/browser.js ***!
  \*******************************************/
/*! no static exports found */function(module,exports,__webpack_require__){eval("/**\n * This is the web browser implementation of `debug()`.\n *\n * Expose `debug()` as the module.\n */\n\nexports = module.exports = __webpack_require__(/*! ./debug */ \"./node_modules/debug/src/debug.js\");\nexports.log = log;\nexports.formatArgs = formatArgs;\nexports.save = save;\nexports.load = load;\nexports.useColors = useColors;\nexports.storage = 'undefined' != typeof chrome\n               && 'undefined' != typeof chrome.storage\n                  ? chrome.storage.local\n                  : localstorage();\n\n/**\n * Colors.\n */\n\nexports.colors = [\n  'lightseagreen',\n  'forestgreen',\n  'goldenrod',\n  'dodgerblue',\n  'darkorchid',\n  'crimson'\n];\n\n/**\n * Currently only WebKit-based Web Inspectors, Firefox >= v31,\n * and the Firebug extension (any Firefox version) are known\n * to support \"%c\" CSS customizations.\n *\n * TODO: add a `localStorage` variable to explicitly enable/disable colors\n */\n\nfunction useColors() {\n  // NB: In an Electron preload script, document will be defined but not fully\n  // initialized. Since we know we're in Chrome, we'll just detect this case\n  // explicitly\n  if (typeof window !== 'undefined' && window.process && window.process.type === 'renderer') {\n    return true;\n  }\n\n  // is webkit? http://stackoverflow.com/a/16459606/376773\n  // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632\n  return (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||\n    // is firebug? http://stackoverflow.com/a/398120/376773\n    (typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||\n    // is firefox >= v31?\n    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages\n    (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\\/(\\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||\n    // double check webkit in userAgent just in case we are in a worker\n    (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\\/(\\d+)/));\n}\n\n/**\n * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.\n */\n\nexports.formatters.j = function(v) {\n  try {\n    return JSON.stringify(v);\n  } catch (err) {\n    return '[UnexpectedJSONParseError]: ' + err.message;\n  }\n};\n\n\n/**\n * Colorize log arguments if enabled.\n *\n * @api public\n */\n\nfunction formatArgs(args) {\n  var useColors = this.useColors;\n\n  args[0] = (useColors ? '%c' : '')\n    + this.namespace\n    + (useColors ? ' %c' : ' ')\n    + args[0]\n    + (useColors ? '%c ' : ' ')\n    + '+' + exports.humanize(this.diff);\n\n  if (!useColors) return;\n\n  var c = 'color: ' + this.color;\n  args.splice(1, 0, c, 'color: inherit')\n\n  // the final \"%c\" is somewhat tricky, because there could be other\n  // arguments passed either before or after the %c, so we need to\n  // figure out the correct index to insert the CSS into\n  var index = 0;\n  var lastC = 0;\n  args[0].replace(/%[a-zA-Z%]/g, function(match) {\n    if ('%%' === match) return;\n    index++;\n    if ('%c' === match) {\n      // we only are interested in the *last* %c\n      // (the user may have provided their own)\n      lastC = index;\n    }\n  });\n\n  args.splice(lastC, 0, c);\n}\n\n/**\n * Invokes `console.log()` when available.\n * No-op when `console.log` is not a \"function\".\n *\n * @api public\n */\n\nfunction log() {\n  // this hackery is required for IE8/9, where\n  // the `console.log` function doesn't have 'apply'\n  return 'object' === typeof console\n    && console.log\n    && Function.prototype.apply.call(console.log, console, arguments);\n}\n\n/**\n * Save `namespaces`.\n *\n * @param {String} namespaces\n * @api private\n */\n\nfunction save(namespaces) {\n  try {\n    if (null == namespaces) {\n      exports.storage.removeItem('debug');\n    } else {\n      exports.storage.debug = namespaces;\n    }\n  } catch(e) {}\n}\n\n/**\n * Load `namespaces`.\n *\n * @return {String} returns the previously persisted debug modes\n * @api private\n */\n\nfunction load() {\n  var r;\n  try {\n    r = exports.storage.debug;\n  } catch(e) {}\n\n  // If debug isn't set in LS, and we're in Electron, try to load $DEBUG\n  if (!r && typeof process !== 'undefined' && 'env' in process) {\n    r = process.env.DEBUG;\n  }\n\n  return r;\n}\n\n/**\n * Enable namespaces listed in `localStorage.debug` initially.\n */\n\nexports.enable(load());\n\n/**\n * Localstorage attempts to return the localstorage.\n *\n * This is necessary because safari throws\n * when a user disables cookies/localstorage\n * and you attempt to access it.\n *\n * @return {LocalStorage}\n * @api private\n */\n\nfunction localstorage() {\n  try {\n    return window.localStorage;\n  } catch (e) {}\n}\n\n\n//# sourceURL=webpack:///./node_modules/debug/src/browser.js?")},"./node_modules/debug/src/debug.js":
/*!*****************************************!*\
  !*** ./node_modules/debug/src/debug.js ***!
  \*****************************************/
/*! no static exports found */function(module,exports,__webpack_require__){eval("\n/**\n * This is the common logic for both the Node.js and web browser\n * implementations of `debug()`.\n *\n * Expose `debug()` as the module.\n */\n\nexports = module.exports = createDebug.debug = createDebug['default'] = createDebug;\nexports.coerce = coerce;\nexports.disable = disable;\nexports.enable = enable;\nexports.enabled = enabled;\nexports.humanize = __webpack_require__(/*! ms */ \"./node_modules/ms/index.js\");\n\n/**\n * The currently active debug mode names, and names to skip.\n */\n\nexports.names = [];\nexports.skips = [];\n\n/**\n * Map of special \"%n\" handling functions, for the debug \"format\" argument.\n *\n * Valid key names are a single, lower or upper-case letter, i.e. \"n\" and \"N\".\n */\n\nexports.formatters = {};\n\n/**\n * Previous log timestamp.\n */\n\nvar prevTime;\n\n/**\n * Select a color.\n * @param {String} namespace\n * @return {Number}\n * @api private\n */\n\nfunction selectColor(namespace) {\n  var hash = 0, i;\n\n  for (i in namespace) {\n    hash  = ((hash << 5) - hash) + namespace.charCodeAt(i);\n    hash |= 0; // Convert to 32bit integer\n  }\n\n  return exports.colors[Math.abs(hash) % exports.colors.length];\n}\n\n/**\n * Create a debugger with the given `namespace`.\n *\n * @param {String} namespace\n * @return {Function}\n * @api public\n */\n\nfunction createDebug(namespace) {\n\n  function debug() {\n    // disabled?\n    if (!debug.enabled) return;\n\n    var self = debug;\n\n    // set `diff` timestamp\n    var curr = +new Date();\n    var ms = curr - (prevTime || curr);\n    self.diff = ms;\n    self.prev = prevTime;\n    self.curr = curr;\n    prevTime = curr;\n\n    // turn the `arguments` into a proper Array\n    var args = new Array(arguments.length);\n    for (var i = 0; i < args.length; i++) {\n      args[i] = arguments[i];\n    }\n\n    args[0] = exports.coerce(args[0]);\n\n    if ('string' !== typeof args[0]) {\n      // anything else let's inspect with %O\n      args.unshift('%O');\n    }\n\n    // apply any `formatters` transformations\n    var index = 0;\n    args[0] = args[0].replace(/%([a-zA-Z%])/g, function(match, format) {\n      // if we encounter an escaped % then don't increase the array index\n      if (match === '%%') return match;\n      index++;\n      var formatter = exports.formatters[format];\n      if ('function' === typeof formatter) {\n        var val = args[index];\n        match = formatter.call(self, val);\n\n        // now we need to remove `args[index]` since it's inlined in the `format`\n        args.splice(index, 1);\n        index--;\n      }\n      return match;\n    });\n\n    // apply env-specific formatting (colors, etc.)\n    exports.formatArgs.call(self, args);\n\n    var logFn = debug.log || exports.log || console.log.bind(console);\n    logFn.apply(self, args);\n  }\n\n  debug.namespace = namespace;\n  debug.enabled = exports.enabled(namespace);\n  debug.useColors = exports.useColors();\n  debug.color = selectColor(namespace);\n\n  // env-specific initialization logic for debug instances\n  if ('function' === typeof exports.init) {\n    exports.init(debug);\n  }\n\n  return debug;\n}\n\n/**\n * Enables a debug mode by namespaces. This can include modes\n * separated by a colon and wildcards.\n *\n * @param {String} namespaces\n * @api public\n */\n\nfunction enable(namespaces) {\n  exports.save(namespaces);\n\n  exports.names = [];\n  exports.skips = [];\n\n  var split = (typeof namespaces === 'string' ? namespaces : '').split(/[\\s,]+/);\n  var len = split.length;\n\n  for (var i = 0; i < len; i++) {\n    if (!split[i]) continue; // ignore empty strings\n    namespaces = split[i].replace(/\\*/g, '.*?');\n    if (namespaces[0] === '-') {\n      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));\n    } else {\n      exports.names.push(new RegExp('^' + namespaces + '$'));\n    }\n  }\n}\n\n/**\n * Disable debug output.\n *\n * @api public\n */\n\nfunction disable() {\n  exports.enable('');\n}\n\n/**\n * Returns true if the given mode name is enabled, false otherwise.\n *\n * @param {String} name\n * @return {Boolean}\n * @api public\n */\n\nfunction enabled(name) {\n  var i, len;\n  for (i = 0, len = exports.skips.length; i < len; i++) {\n    if (exports.skips[i].test(name)) {\n      return false;\n    }\n  }\n  for (i = 0, len = exports.names.length; i < len; i++) {\n    if (exports.names[i].test(name)) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * Coerce `val`.\n *\n * @param {Mixed} val\n * @return {Mixed}\n * @api private\n */\n\nfunction coerce(val) {\n  if (val instanceof Error) return val.stack || val.message;\n  return val;\n}\n\n\n//# sourceURL=webpack:///./node_modules/debug/src/debug.js?")},"./node_modules/debug/src/index.js":
/*!*****************************************!*\
  !*** ./node_modules/debug/src/index.js ***!
  \*****************************************/
/*! no static exports found */function(module,exports,__webpack_require__){eval("/**\n * Detect Electron renderer process, which is node, but we should\n * treat as a browser.\n */\n\nif (typeof process !== 'undefined' && process.type === 'renderer') {\n  module.exports = __webpack_require__(/*! ./browser.js */ \"./node_modules/debug/src/browser.js\");\n} else {\n  module.exports = __webpack_require__(/*! ./node.js */ \"./node_modules/debug/src/node.js\");\n}\n\n\n//# sourceURL=webpack:///./node_modules/debug/src/index.js?")},"./node_modules/debug/src/node.js":
/*!****************************************!*\
  !*** ./node_modules/debug/src/node.js ***!
  \****************************************/
/*! no static exports found */function(module,exports,__webpack_require__){eval("/**\n * Module dependencies.\n */\n\nvar tty = __webpack_require__(/*! tty */ \"tty\");\nvar util = __webpack_require__(/*! util */ \"util\");\n\n/**\n * This is the Node.js implementation of `debug()`.\n *\n * Expose `debug()` as the module.\n */\n\nexports = module.exports = __webpack_require__(/*! ./debug */ \"./node_modules/debug/src/debug.js\");\nexports.init = init;\nexports.log = log;\nexports.formatArgs = formatArgs;\nexports.save = save;\nexports.load = load;\nexports.useColors = useColors;\n\n/**\n * Colors.\n */\n\nexports.colors = [6, 2, 3, 4, 5, 1];\n\n/**\n * Build up the default `inspectOpts` object from the environment variables.\n *\n *   $ DEBUG_COLORS=no DEBUG_DEPTH=10 DEBUG_SHOW_HIDDEN=enabled node script.js\n */\n\nexports.inspectOpts = Object.keys(process.env).filter(function (key) {\n  return /^debug_/i.test(key);\n}).reduce(function (obj, key) {\n  // camel-case\n  var prop = key\n    .substring(6)\n    .toLowerCase()\n    .replace(/_([a-z])/g, function (_, k) { return k.toUpperCase() });\n\n  // coerce string value into JS value\n  var val = process.env[key];\n  if (/^(yes|on|true|enabled)$/i.test(val)) val = true;\n  else if (/^(no|off|false|disabled)$/i.test(val)) val = false;\n  else if (val === 'null') val = null;\n  else val = Number(val);\n\n  obj[prop] = val;\n  return obj;\n}, {});\n\n/**\n * The file descriptor to write the `debug()` calls to.\n * Set the `DEBUG_FD` env variable to override with another value. i.e.:\n *\n *   $ DEBUG_FD=3 node script.js 3>debug.log\n */\n\nvar fd = parseInt(process.env.DEBUG_FD, 10) || 2;\n\nif (1 !== fd && 2 !== fd) {\n  util.deprecate(function(){}, 'except for stderr(2) and stdout(1), any other usage of DEBUG_FD is deprecated. Override debug.log if you want to use a different log function (https://git.io/debug_fd)')()\n}\n\nvar stream = 1 === fd ? process.stdout :\n             2 === fd ? process.stderr :\n             createWritableStdioStream(fd);\n\n/**\n * Is stdout a TTY? Colored output is enabled when `true`.\n */\n\nfunction useColors() {\n  return 'colors' in exports.inspectOpts\n    ? Boolean(exports.inspectOpts.colors)\n    : tty.isatty(fd);\n}\n\n/**\n * Map %o to `util.inspect()`, all on a single line.\n */\n\nexports.formatters.o = function(v) {\n  this.inspectOpts.colors = this.useColors;\n  return util.inspect(v, this.inspectOpts)\n    .split('\\n').map(function(str) {\n      return str.trim()\n    }).join(' ');\n};\n\n/**\n * Map %o to `util.inspect()`, allowing multiple lines if needed.\n */\n\nexports.formatters.O = function(v) {\n  this.inspectOpts.colors = this.useColors;\n  return util.inspect(v, this.inspectOpts);\n};\n\n/**\n * Adds ANSI color escape codes if enabled.\n *\n * @api public\n */\n\nfunction formatArgs(args) {\n  var name = this.namespace;\n  var useColors = this.useColors;\n\n  if (useColors) {\n    var c = this.color;\n    var prefix = '  \\u001b[3' + c + ';1m' + name + ' ' + '\\u001b[0m';\n\n    args[0] = prefix + args[0].split('\\n').join('\\n' + prefix);\n    args.push('\\u001b[3' + c + 'm+' + exports.humanize(this.diff) + '\\u001b[0m');\n  } else {\n    args[0] = new Date().toUTCString()\n      + ' ' + name + ' ' + args[0];\n  }\n}\n\n/**\n * Invokes `util.format()` with the specified arguments and writes to `stream`.\n */\n\nfunction log() {\n  return stream.write(util.format.apply(util, arguments) + '\\n');\n}\n\n/**\n * Save `namespaces`.\n *\n * @param {String} namespaces\n * @api private\n */\n\nfunction save(namespaces) {\n  if (null == namespaces) {\n    // If you set a process.env field to null or undefined, it gets cast to the\n    // string 'null' or 'undefined'. Just delete instead.\n    delete process.env.DEBUG;\n  } else {\n    process.env.DEBUG = namespaces;\n  }\n}\n\n/**\n * Load `namespaces`.\n *\n * @return {String} returns the previously persisted debug modes\n * @api private\n */\n\nfunction load() {\n  return process.env.DEBUG;\n}\n\n/**\n * Copied from `node/src/node.js`.\n *\n * XXX: It's lame that node doesn't expose this API out-of-the-box. It also\n * relies on the undocumented `tty_wrap.guessHandleType()` which is also lame.\n */\n\nfunction createWritableStdioStream (fd) {\n  var stream;\n  var tty_wrap = process.binding('tty_wrap');\n\n  // Note stream._type is used for test-module-load-list.js\n\n  switch (tty_wrap.guessHandleType(fd)) {\n    case 'TTY':\n      stream = new tty.WriteStream(fd);\n      stream._type = 'tty';\n\n      // Hack to have stream not keep the event loop alive.\n      // See https://github.com/joyent/node/issues/1726\n      if (stream._handle && stream._handle.unref) {\n        stream._handle.unref();\n      }\n      break;\n\n    case 'FILE':\n      var fs = __webpack_require__(/*! fs */ \"fs\");\n      stream = new fs.SyncWriteStream(fd, { autoClose: false });\n      stream._type = 'fs';\n      break;\n\n    case 'PIPE':\n    case 'TCP':\n      var net = __webpack_require__(/*! net */ \"net\");\n      stream = new net.Socket({\n        fd: fd,\n        readable: false,\n        writable: true\n      });\n\n      // FIXME Should probably have an option in net.Socket to create a\n      // stream from an existing fd which is writable only. But for now\n      // we'll just add this hack and set the `readable` member to false.\n      // Test: ./node test/fixtures/echo.js < /etc/passwd\n      stream.readable = false;\n      stream.read = null;\n      stream._type = 'pipe';\n\n      // FIXME Hack to have stream not keep the event loop alive.\n      // See https://github.com/joyent/node/issues/1726\n      if (stream._handle && stream._handle.unref) {\n        stream._handle.unref();\n      }\n      break;\n\n    default:\n      // Probably an error on in uv_guess_handle()\n      throw new Error('Implement me. Unknown stream file type!');\n  }\n\n  // For supporting legacy API we put the FD here.\n  stream.fd = fd;\n\n  stream._isStdio = true;\n\n  return stream;\n}\n\n/**\n * Init logic for `debug` instances.\n *\n * Create a new `inspectOpts` object in case `useColors` is set\n * differently for a particular `debug` instance.\n */\n\nfunction init (debug) {\n  debug.inspectOpts = {};\n\n  var keys = Object.keys(exports.inspectOpts);\n  for (var i = 0; i < keys.length; i++) {\n    debug.inspectOpts[keys[i]] = exports.inspectOpts[keys[i]];\n  }\n}\n\n/**\n * Enable namespaces listed in `process.env.DEBUG` initially.\n */\n\nexports.enable(load());\n\n\n//# sourceURL=webpack:///./node_modules/debug/src/node.js?")},"./node_modules/electron-compile/lib sync recursive":
/*!************************************************!*\
  !*** ./node_modules/electron-compile/lib sync ***!
  \************************************************/
/*! no static exports found */function(module,exports){eval('function webpackEmptyContext(req) {\n\tvar e = new Error("Cannot find module \'" + req + "\'");\n\te.code = \'MODULE_NOT_FOUND\';\n\tthrow e;\n}\nwebpackEmptyContext.keys = function() { return []; };\nwebpackEmptyContext.resolve = webpackEmptyContext;\nmodule.exports = webpackEmptyContext;\nwebpackEmptyContext.id = "./node_modules/electron-compile/lib sync recursive";\n\n//# sourceURL=webpack:///./node_modules/electron-compile/lib_sync?')},"./node_modules/electron-compile/lib/browser-signal.js":
/*!*************************************************************!*\
  !*** ./node_modules/electron-compile/lib/browser-signal.js ***!
  \*************************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", {\n  value: true\n});\nexports.send = send;\nexports.listen = listen;\n\nvar _Observable = __webpack_require__(/*! rxjs/Observable */ "./node_modules/electron-compile/node_modules/rxjs/Observable.js");\n\nvar _Subject = __webpack_require__(/*! rxjs/Subject */ "./node_modules/electron-compile/node_modules/rxjs/Subject.js");\n\n__webpack_require__(/*! rxjs/add/observable/throw */ "./node_modules/electron-compile/node_modules/rxjs/add/observable/throw.js");\n\nconst isElectron = \'type\' in process;\nconst isBrowser = process.type === \'browser\';\n\nconst ipc = !isElectron ? null : isBrowser ? __webpack_require__(/*! electron */ "electron").ipcMain : __webpack_require__(/*! electron */ "electron").ipcRenderer;\n\nconst channelList = {};\n\nfunction send(channel) {\n  for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    args[_key - 1] = arguments[_key];\n  }\n\n  if (isElectron && !isBrowser) {\n    ipc.send(channel, ...args);\n    return;\n  }\n\n  if (!(channel in channelList)) return;\n\n  let subj = channelList[channel].subj;\n\n  subj.next(args);\n}\n\nfunction listen(channel) {\n  if (isElectron && !isBrowser) return _Observable.Observable.throw(new Error("Can only call listen from browser"));\n\n  return _Observable.Observable.create(s => {\n    if (!(channel in channelList)) {\n      let subj = new _Subject.Subject();\n      let ipcListener = function (e) {\n        for (var _len2 = arguments.length, args = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n          args[_key2 - 1] = arguments[_key2];\n        }\n\n        subj.next(args);\n      };\n\n      channelList[channel] = { subj, refcount: 0 };\n      if (isElectron && isBrowser) {\n        ipc.on(channel, ipcListener);\n        channelList[channel].listener = ipcListener;\n      }\n    }\n\n    channelList[channel].refcount++;\n\n    let disp = channelList[channel].subj.subscribe(s);\n    disp.add(() => {\n      channelList[channel].refcount--;\n      if (channelList[channel].refcount > 0) return;\n\n      if (channelList[channel].listener) {\n        ipc.removeListener(channel, channelList[channel].listener);\n      }\n\n      delete channelList.channel;\n    });\n\n    return disp;\n  });\n}\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9icm93c2VyLXNpZ25hbC5qcyJdLCJuYW1lcyI6WyJzZW5kIiwibGlzdGVuIiwiaXNFbGVjdHJvbiIsInByb2Nlc3MiLCJpc0Jyb3dzZXIiLCJ0eXBlIiwiaXBjIiwicmVxdWlyZSIsImlwY01haW4iLCJpcGNSZW5kZXJlciIsImNoYW5uZWxMaXN0IiwiY2hhbm5lbCIsImFyZ3MiLCJzdWJqIiwibmV4dCIsIk9ic2VydmFibGUiLCJ0aHJvdyIsIkVycm9yIiwiY3JlYXRlIiwicyIsIlN1YmplY3QiLCJpcGNMaXN0ZW5lciIsImUiLCJyZWZjb3VudCIsIm9uIiwibGlzdGVuZXIiLCJkaXNwIiwic3Vic2NyaWJlIiwiYWRkIiwicmVtb3ZlTGlzdGVuZXIiXSwibWFwcGluZ3MiOiI7Ozs7O1FBYWdCQSxJLEdBQUFBLEk7UUFZQUMsTSxHQUFBQSxNOztBQXpCaEI7O0FBQ0E7O0FBRUE7O0FBRUEsTUFBTUMsYUFBYSxVQUFVQyxPQUE3QjtBQUNBLE1BQU1DLFlBQVlELFFBQVFFLElBQVIsS0FBaUIsU0FBbkM7O0FBRUEsTUFBTUMsTUFBTSxDQUFDSixVQUFELEdBQWMsSUFBZCxHQUNWRSxZQUFZRyxRQUFRLFVBQVIsRUFBb0JDLE9BQWhDLEdBQTBDRCxRQUFRLFVBQVIsRUFBb0JFLFdBRGhFOztBQUdBLE1BQU1DLGNBQWMsRUFBcEI7O0FBRU8sU0FBU1YsSUFBVCxDQUFjVyxPQUFkLEVBQWdDO0FBQUEsb0NBQU5DLElBQU07QUFBTkEsUUFBTTtBQUFBOztBQUNyQyxNQUFJVixjQUFjLENBQUNFLFNBQW5CLEVBQThCO0FBQzVCRSxRQUFJTixJQUFKLENBQVNXLE9BQVQsRUFBa0IsR0FBR0MsSUFBckI7QUFDQTtBQUNEOztBQUVELE1BQUksRUFBRUQsV0FBV0QsV0FBYixDQUFKLEVBQStCOztBQU5NLE1BUS9CRyxJQVIrQixHQVF0QkgsWUFBWUMsT0FBWixDQVJzQixDQVEvQkUsSUFSK0I7O0FBU3JDQSxPQUFLQyxJQUFMLENBQVVGLElBQVY7QUFDRDs7QUFFTSxTQUFTWCxNQUFULENBQWdCVSxPQUFoQixFQUF5QjtBQUM5QixNQUFJVCxjQUFjLENBQUNFLFNBQW5CLEVBQThCLE9BQU9XLHVCQUFXQyxLQUFYLENBQWlCLElBQUlDLEtBQUosQ0FBVSxtQ0FBVixDQUFqQixDQUFQOztBQUU5QixTQUFPRix1QkFBV0csTUFBWCxDQUFtQkMsQ0FBRCxJQUFPO0FBQzlCLFFBQUksRUFBRVIsV0FBV0QsV0FBYixDQUFKLEVBQStCO0FBQzdCLFVBQUlHLE9BQU8sSUFBSU8sZ0JBQUosRUFBWDtBQUNBLFVBQUlDLGNBQWMsVUFBQ0MsQ0FBRCxFQUFnQjtBQUFBLDJDQUFUVixJQUFTO0FBQVRBLGNBQVM7QUFBQTs7QUFBRUMsYUFBS0MsSUFBTCxDQUFVRixJQUFWO0FBQWtCLE9BQXREOztBQUVBRixrQkFBWUMsT0FBWixJQUF1QixFQUFFRSxJQUFGLEVBQVFVLFVBQVUsQ0FBbEIsRUFBdkI7QUFDQSxVQUFJckIsY0FBY0UsU0FBbEIsRUFBNkI7QUFDM0JFLFlBQUlrQixFQUFKLENBQU9iLE9BQVAsRUFBZ0JVLFdBQWhCO0FBQ0FYLG9CQUFZQyxPQUFaLEVBQXFCYyxRQUFyQixHQUFnQ0osV0FBaEM7QUFDRDtBQUNGOztBQUVEWCxnQkFBWUMsT0FBWixFQUFxQlksUUFBckI7O0FBRUEsUUFBSUcsT0FBT2hCLFlBQVlDLE9BQVosRUFBcUJFLElBQXJCLENBQTBCYyxTQUExQixDQUFvQ1IsQ0FBcEMsQ0FBWDtBQUNBTyxTQUFLRSxHQUFMLENBQVMsTUFBTTtBQUNibEIsa0JBQVlDLE9BQVosRUFBcUJZLFFBQXJCO0FBQ0EsVUFBSWIsWUFBWUMsT0FBWixFQUFxQlksUUFBckIsR0FBZ0MsQ0FBcEMsRUFBdUM7O0FBRXZDLFVBQUliLFlBQVlDLE9BQVosRUFBcUJjLFFBQXpCLEVBQW1DO0FBQ2pDbkIsWUFBSXVCLGNBQUosQ0FBbUJsQixPQUFuQixFQUE0QkQsWUFBWUMsT0FBWixFQUFxQmMsUUFBakQ7QUFDRDs7QUFFRCxhQUFPZixZQUFZQyxPQUFuQjtBQUNELEtBVEQ7O0FBV0EsV0FBT2UsSUFBUDtBQUNELEdBM0JNLENBQVA7QUE0QkQiLCJmaWxlIjoiYnJvd3Nlci1zaWduYWwuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge09ic2VydmFibGV9IGZyb20gJ3J4anMvT2JzZXJ2YWJsZSc7XG5pbXBvcnQge1N1YmplY3R9IGZyb20gJ3J4anMvU3ViamVjdCc7XG5cbmltcG9ydCAncnhqcy9hZGQvb2JzZXJ2YWJsZS90aHJvdyc7XG5cbmNvbnN0IGlzRWxlY3Ryb24gPSAndHlwZScgaW4gcHJvY2VzcztcbmNvbnN0IGlzQnJvd3NlciA9IHByb2Nlc3MudHlwZSA9PT0gJ2Jyb3dzZXInO1xuXG5jb25zdCBpcGMgPSAhaXNFbGVjdHJvbiA/IG51bGwgOlxuICBpc0Jyb3dzZXIgPyByZXF1aXJlKCdlbGVjdHJvbicpLmlwY01haW4gOiByZXF1aXJlKCdlbGVjdHJvbicpLmlwY1JlbmRlcmVyO1xuXG5jb25zdCBjaGFubmVsTGlzdCA9IHt9O1xuXG5leHBvcnQgZnVuY3Rpb24gc2VuZChjaGFubmVsLCAuLi5hcmdzKSB7XG4gIGlmIChpc0VsZWN0cm9uICYmICFpc0Jyb3dzZXIpIHtcbiAgICBpcGMuc2VuZChjaGFubmVsLCAuLi5hcmdzKTtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoIShjaGFubmVsIGluIGNoYW5uZWxMaXN0KSkgcmV0dXJuO1xuXG4gIGxldCB7IHN1YmogfSA9IGNoYW5uZWxMaXN0W2NoYW5uZWxdO1xuICBzdWJqLm5leHQoYXJncyk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBsaXN0ZW4oY2hhbm5lbCkge1xuICBpZiAoaXNFbGVjdHJvbiAmJiAhaXNCcm93c2VyKSByZXR1cm4gT2JzZXJ2YWJsZS50aHJvdyhuZXcgRXJyb3IoXCJDYW4gb25seSBjYWxsIGxpc3RlbiBmcm9tIGJyb3dzZXJcIikpO1xuXG4gIHJldHVybiBPYnNlcnZhYmxlLmNyZWF0ZSgocykgPT4ge1xuICAgIGlmICghKGNoYW5uZWwgaW4gY2hhbm5lbExpc3QpKSB7XG4gICAgICBsZXQgc3ViaiA9IG5ldyBTdWJqZWN0KCk7XG4gICAgICBsZXQgaXBjTGlzdGVuZXIgPSAoZSwgLi4uYXJncykgPT4geyBzdWJqLm5leHQoYXJncyk7IH07XG5cbiAgICAgIGNoYW5uZWxMaXN0W2NoYW5uZWxdID0geyBzdWJqLCByZWZjb3VudDogMCB9O1xuICAgICAgaWYgKGlzRWxlY3Ryb24gJiYgaXNCcm93c2VyKSB7XG4gICAgICAgIGlwYy5vbihjaGFubmVsLCBpcGNMaXN0ZW5lcik7XG4gICAgICAgIGNoYW5uZWxMaXN0W2NoYW5uZWxdLmxpc3RlbmVyID0gaXBjTGlzdGVuZXI7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY2hhbm5lbExpc3RbY2hhbm5lbF0ucmVmY291bnQrKztcblxuICAgIGxldCBkaXNwID0gY2hhbm5lbExpc3RbY2hhbm5lbF0uc3Viai5zdWJzY3JpYmUocyk7XG4gICAgZGlzcC5hZGQoKCkgPT4ge1xuICAgICAgY2hhbm5lbExpc3RbY2hhbm5lbF0ucmVmY291bnQtLTtcbiAgICAgIGlmIChjaGFubmVsTGlzdFtjaGFubmVsXS5yZWZjb3VudCA+IDApIHJldHVybjtcblxuICAgICAgaWYgKGNoYW5uZWxMaXN0W2NoYW5uZWxdLmxpc3RlbmVyKSB7XG4gICAgICAgIGlwYy5yZW1vdmVMaXN0ZW5lcihjaGFubmVsLCBjaGFubmVsTGlzdFtjaGFubmVsXS5saXN0ZW5lcik7XG4gICAgICB9XG5cbiAgICAgIGRlbGV0ZSBjaGFubmVsTGlzdC5jaGFubmVsO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIGRpc3A7XG4gIH0pO1xufVxuIl19\n\n//# sourceURL=webpack:///./node_modules/electron-compile/lib/browser-signal.js?')},"./node_modules/electron-compile/lib/compile-cache.js":
/*!************************************************************!*\
  !*** ./node_modules/electron-compile/lib/compile-cache.js ***!
  \************************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){"use strict";eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _fs = __webpack_require__(/*! fs */ \"fs\");\n\nvar _fs2 = _interopRequireDefault(_fs);\n\nvar _path = __webpack_require__(/*! path */ \"path\");\n\nvar _path2 = _interopRequireDefault(_path);\n\nvar _zlib = __webpack_require__(/*! zlib */ \"zlib\");\n\nvar _zlib2 = _interopRequireDefault(_zlib);\n\nvar _digestForObject = __webpack_require__(/*! ./digest-for-object */ \"./node_modules/electron-compile/lib/digest-for-object.js\");\n\nvar _digestForObject2 = _interopRequireDefault(_digestForObject);\n\nvar _promise = __webpack_require__(/*! ./promise */ \"./node_modules/electron-compile/lib/promise.js\");\n\nvar _mkdirp = __webpack_require__(/*! mkdirp */ \"./node_modules/mkdirp/index.js\");\n\nvar _mkdirp2 = _interopRequireDefault(_mkdirp);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step(\"next\", value); }, function (err) { step(\"throw\", err); }); } } return step(\"next\"); }); }; }\n\nconst d = __webpack_require__(/*! debug */ \"./node_modules/debug/src/index.js\")('electron-compile:compile-cache');\n\n/**\n * CompileCache manages getting and setting entries for a single compiler; each\n * in-use compiler will have an instance of this class, usually created via\n * {@link createFromCompiler}.\n *\n * You usually will not use this class directly, it is an implementation class\n * for {@link CompileHost}.\n */\nclass CompileCache {\n  /**\n   * Creates an instance, usually used for testing only.\n   *\n   * @param  {string} cachePath  The root directory to use as a cache path\n   *\n   * @param  {FileChangedCache} fileChangeCache  A file-change cache that is\n   *                                             optionally pre-loaded.\n   * @param {string} sourceMapPath The directory to store sourcemap separately if compiler option enabled to emit.\n   *                               Default to cachePath if not specified.\n   */\n  constructor(cachePath, fileChangeCache) {\n    let sourceMapPath = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n\n    this.cachePath = cachePath;\n    this.fileChangeCache = fileChangeCache;\n    this.sourceMapPath = sourceMapPath || this.cachePath;\n  }\n\n  /**\n   * Creates a CompileCache from a class compatible with the CompilerBase\n   * interface. This method uses the compiler name / version / options to\n   * generate a unique directory name for cached results\n   *\n   * @param  {string} cachePath  The root path to use for the cache, a directory\n   *                             representing the hash of the compiler parameters\n   *                             will be created here.\n   *\n   * @param  {CompilerBase} compiler  The compiler to use for version / option\n   *                                  information.\n   *\n   * @param  {FileChangedCache} fileChangeCache  A file-change cache that is\n   *                                             optionally pre-loaded.\n   *\n   * @param  {boolean} readOnlyMode  Don't attempt to create the cache directory.\n   *\n   * @param {string} sourceMapPath The directory to store sourcemap separately if compiler option enabled to emit.\n   *                               Default to cachePath if not specified.\n   *\n   * @return {CompileCache}  A configured CompileCache instance.\n   */\n  static createFromCompiler(cachePath, compiler, fileChangeCache) {\n    let readOnlyMode = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n    let sourceMapPath = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;\n\n    let newCachePath = null;\n    let getCachePath = () => {\n      if (newCachePath) return newCachePath;\n\n      const digestObj = {\n        name: compiler.name || Object.getPrototypeOf(compiler).constructor.name,\n        version: compiler.getCompilerVersion(),\n        options: compiler.compilerOptions\n      };\n\n      newCachePath = _path2.default.join(cachePath, (0, _digestForObject2.default)(digestObj));\n\n      d(`Path for ${digestObj.name}: ${newCachePath}`);\n      d(`Set up with parameters: ${JSON.stringify(digestObj)}`);\n\n      if (!readOnlyMode) _mkdirp2.default.sync(newCachePath);\n      return newCachePath;\n    };\n\n    let ret = new CompileCache('', fileChangeCache);\n    ret.getCachePath = getCachePath;\n\n    const newSourceMapPath = sourceMapPath;\n    ret.getSourceMapPath = () => newSourceMapPath || getCachePath();\n\n    return ret;\n  }\n\n  /**\n   * Returns a file's compiled contents from the cache.\n   *\n   * @param  {string} filePath  The path to the file. FileChangedCache will look\n   *                            up the hash and use that as the key in the cache.\n   *\n   * @return {Promise<Object>}  An object with all kinds of information\n   *\n   * @property {Object} hashInfo  The hash information returned from getHashForPath\n   * @property {string} code  The source code if the file was a text file\n   * @property {Buffer} binaryData  The file if it was a binary file\n   * @property {string} mimeType  The MIME type saved in the cache.\n   * @property {string[]} dependentFiles  The dependent files returned from\n   *                                      compiling the file, if any.\n   */\n  get(filePath) {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      d(`Fetching ${filePath} from cache`);\n      let hashInfo = yield _this.fileChangeCache.getHashForPath(_path2.default.resolve(filePath));\n\n      let code = null;\n      let mimeType = null;\n      let binaryData = null;\n      let dependentFiles = null;\n\n      let cacheFile = null;\n      try {\n        cacheFile = _path2.default.join(_this.getCachePath(), hashInfo.hash);\n        let result = null;\n\n        if (hashInfo.isFileBinary) {\n          d(\"File is binary, reading out info\");\n          let info = JSON.parse((yield _promise.pfs.readFile(cacheFile + '.info')));\n          mimeType = info.mimeType;\n          dependentFiles = info.dependentFiles;\n\n          binaryData = hashInfo.binaryData;\n          if (!binaryData) {\n            binaryData = yield _promise.pfs.readFile(cacheFile);\n            binaryData = yield _promise.pzlib.gunzip(binaryData);\n          }\n        } else {\n          let buf = yield _promise.pfs.readFile(cacheFile);\n          let str = (yield _promise.pzlib.gunzip(buf)).toString('utf8');\n\n          result = JSON.parse(str);\n          code = result.code;\n          mimeType = result.mimeType;\n          dependentFiles = result.dependentFiles;\n        }\n      } catch (e) {\n        d(`Failed to read cache for ${filePath}, looked in ${cacheFile}: ${e.message}`);\n      }\n\n      return { hashInfo, code, mimeType, binaryData, dependentFiles };\n    })();\n  }\n\n  /**\n   * Saves a compiled result to cache\n   *\n   * @param  {Object} hashInfo  The hash information returned from getHashForPath\n   *\n   * @param  {string / Buffer} codeOrBinaryData   The file's contents, either as\n   *                                              a string or a Buffer.\n   * @param  {string} mimeType  The MIME type returned by the compiler.\n   *\n   * @param  {string[]} dependentFiles  The list of dependent files returned by\n   *                                    the compiler.\n   * @return {Promise}  Completion.\n   */\n  save(hashInfo, codeOrBinaryData, mimeType, dependentFiles) {\n    var _this2 = this;\n\n    return _asyncToGenerator(function* () {\n      let buf = null;\n      let target = _path2.default.join(_this2.getCachePath(), hashInfo.hash);\n      d(`Saving to ${target}`);\n\n      if (hashInfo.isFileBinary) {\n        buf = yield _promise.pzlib.gzip(codeOrBinaryData);\n        yield _promise.pfs.writeFile(target + '.info', JSON.stringify({ mimeType, dependentFiles }), 'utf8');\n      } else {\n        buf = yield _promise.pzlib.gzip(new Buffer(JSON.stringify({ code: codeOrBinaryData, mimeType, dependentFiles })));\n      }\n\n      yield _promise.pfs.writeFile(target, buf);\n    })();\n  }\n\n  /**\n   * Attempts to first get a key via {@link get}, then if it fails, call a method\n   * to retrieve the contents, then save the result to cache.\n   *\n   * The fetcher parameter is expected to have the signature:\n   *\n   * Promise<Object> fetcher(filePath : string, hashInfo : Object);\n   *\n   * hashInfo is a value returned from getHashForPath\n   * The return value of fetcher must be an Object with the properties:\n   *\n   * mimeType - the MIME type of the data to save\n   * code (optional) - the source code as a string, if file is text\n   * binaryData (optional) - the file contents as a Buffer, if file is binary\n   * dependentFiles - the dependent files returned by the compiler.\n   *\n   * @param  {string} filePath  The path to the file. FileChangedCache will look\n   *                            up the hash and use that as the key in the cache.\n   *\n   * @param  {Function} fetcher  A method which conforms to the description above.\n   *\n   * @return {Promise<Object>}  An Object which has the same fields as the\n   *                            {@link get} method return result.\n   */\n  getOrFetch(filePath, fetcher) {\n    var _this3 = this;\n\n    return _asyncToGenerator(function* () {\n      let cacheResult = yield _this3.get(filePath);\n      let anyDependenciesChanged = yield _this3.haveAnyDependentFilesChanged(cacheResult);\n\n      if ((cacheResult.code || cacheResult.binaryData) && !anyDependenciesChanged) {\n        return cacheResult;\n      }\n\n      let result = (yield fetcher(filePath, cacheResult.hashInfo)) || { hashInfo: cacheResult.hashInfo };\n\n      if (result.mimeType && !cacheResult.hashInfo.isInNodeModules) {\n        d(`Cache miss: saving out info for ${filePath}`);\n        yield _this3.save(cacheResult.hashInfo, result.code || result.binaryData, result.mimeType, result.dependentFiles);\n\n        const map = result.sourceMaps;\n        if (map) {\n          d(`source map for ${filePath} found, saving it to ${_this3.getSourceMapPath()}`);\n          yield _this3.saveSourceMap(cacheResult.hashInfo, filePath, map);\n        }\n      }\n\n      result.hashInfo = cacheResult.hashInfo;\n      return result;\n    })();\n  }\n\n  /**\n   * @private Check if any of a file's dependencies have changed\n   */\n  haveAnyDependentFilesChanged(cacheResult) {\n    var _this4 = this;\n\n    return _asyncToGenerator(function* () {\n      if (!cacheResult.code || !cacheResult.dependentFiles.length) return false;\n\n      for (let dependentFile of cacheResult.dependentFiles) {\n        let hasFileChanged = yield _this4.fileChangeCache.hasFileChanged(dependentFile);\n        if (hasFileChanged) {\n          return true;\n        }\n\n        let dependentFileCacheResult = yield _this4.get(dependentFile);\n        if (dependentFileCacheResult.dependentFiles && dependentFileCacheResult.dependentFiles.length) {\n          let anySubdependentFilesChanged = yield _this4.haveAnyDependentFilesChanged(dependentFileCacheResult);\n          if (anySubdependentFilesChanged) return true;\n        }\n      }\n\n      return false;\n    })();\n  }\n\n  getSync(filePath) {\n    d(`Fetching ${filePath} from cache`);\n    let hashInfo = this.fileChangeCache.getHashForPathSync(_path2.default.resolve(filePath));\n\n    let code = null;\n    let mimeType = null;\n    let binaryData = null;\n    let dependentFiles = null;\n\n    try {\n      let cacheFile = _path2.default.join(this.getCachePath(), hashInfo.hash);\n\n      let result = null;\n      if (hashInfo.isFileBinary) {\n        d(\"File is binary, reading out info\");\n        let info = JSON.parse(_fs2.default.readFileSync(cacheFile + '.info'));\n        mimeType = info.mimeType;\n        dependentFiles = info.dependentFiles;\n\n        binaryData = hashInfo.binaryData;\n        if (!binaryData) {\n          binaryData = _fs2.default.readFileSync(cacheFile);\n          binaryData = _zlib2.default.gunzipSync(binaryData);\n        }\n      } else {\n        let buf = _fs2.default.readFileSync(cacheFile);\n        let str = _zlib2.default.gunzipSync(buf).toString('utf8');\n\n        result = JSON.parse(str);\n        code = result.code;\n        mimeType = result.mimeType;\n        dependentFiles = result.dependentFiles;\n      }\n    } catch (e) {\n      d(`Failed to read cache for ${filePath}`);\n    }\n\n    return { hashInfo, code, mimeType, binaryData, dependentFiles };\n  }\n\n  saveSync(hashInfo, codeOrBinaryData, mimeType, dependentFiles) {\n    let buf = null;\n    let target = _path2.default.join(this.getCachePath(), hashInfo.hash);\n    d(`Saving to ${target}`);\n\n    if (hashInfo.isFileBinary) {\n      buf = _zlib2.default.gzipSync(codeOrBinaryData);\n      _fs2.default.writeFileSync(target + '.info', JSON.stringify({ mimeType, dependentFiles }), 'utf8');\n    } else {\n      buf = _zlib2.default.gzipSync(new Buffer(JSON.stringify({ code: codeOrBinaryData, mimeType, dependentFiles })));\n    }\n\n    _fs2.default.writeFileSync(target, buf);\n  }\n\n  getOrFetchSync(filePath, fetcher) {\n    let cacheResult = this.getSync(filePath);\n    if (cacheResult.code || cacheResult.binaryData) return cacheResult;\n\n    let result = fetcher(filePath, cacheResult.hashInfo) || { hashInfo: cacheResult.hashInfo };\n\n    if (result.mimeType && !cacheResult.hashInfo.isInNodeModules) {\n      d(`Cache miss: saving out info for ${filePath}`);\n      this.saveSync(cacheResult.hashInfo, result.code || result.binaryData, result.mimeType, result.dependentFiles);\n    }\n\n    const map = result.sourceMaps;\n    if (map) {\n      d(`source map for ${filePath} found, saving it to ${this.getSourceMapPath()}`);\n      this.saveSourceMapSync(cacheResult.hashInfo, filePath, map);\n    }\n\n    result.hashInfo = cacheResult.hashInfo;\n    return result;\n  }\n\n  buildSourceMapTarget(hashInfo, filePath) {\n    const fileName = _path2.default.basename(filePath);\n    const mapFileName = fileName.replace(_path2.default.extname(fileName), '.js.map');\n\n    const target = _path2.default.join(this.getSourceMapPath(), mapFileName);\n    d(`Sourcemap target is: ${target}`);\n\n    return target;\n  }\n\n  /**\n   * Saves sourcemap string into cache, or specified separate dir\n   *\n   * @param  {Object} hashInfo  The hash information returned from getHashForPath\n   *\n   * @param  {string} filePath Path to original file to construct sourcemap file name\n    * @param  {string} sourceMap Sourcemap data as string\n   *\n   * @memberOf CompileCache\n   */\n  saveSourceMap(hashInfo, filePath, sourceMap) {\n    var _this5 = this;\n\n    return _asyncToGenerator(function* () {\n      const target = _this5.buildSourceMapTarget(hashInfo, filePath);\n      yield _promise.pfs.writeFile(target, sourceMap, 'utf-8');\n    })();\n  }\n\n  saveSourceMapSync(hashInfo, filePath, sourceMap) {\n    const target = this.buildSourceMapTarget(hashInfo, filePath);\n    _fs2.default.writeFileSync(target, sourceMap, 'utf-8');\n  }\n\n  /**\n   * @private\n   */\n  getCachePath() {\n    // NB: This is an evil hack so that createFromCompiler can stomp it\n    // at will\n    return this.cachePath;\n  }\n\n  /**\n   * @private\n   */\n  getSourceMapPath() {\n    return this.sourceMapPath;\n  }\n\n  /**\n   * Returns whether a file should not be compiled. Note that this doesn't\n   * necessarily mean it won't end up in the cache, only that its contents are\n   * saved verbatim instead of trying to find an appropriate compiler.\n   *\n   * @param  {Object} hashInfo  The hash information returned from getHashForPath\n   *\n   * @return {boolean}  True if a file should be ignored\n   */\n  static shouldPassthrough(hashInfo) {\n    return hashInfo.isMinified || hashInfo.isInNodeModules || hashInfo.hasSourceMap || hashInfo.isFileBinary;\n  }\n}\nexports.default = CompileCache;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9jb21waWxlLWNhY2hlLmpzIl0sIm5hbWVzIjpbImQiLCJyZXF1aXJlIiwiQ29tcGlsZUNhY2hlIiwiY29uc3RydWN0b3IiLCJjYWNoZVBhdGgiLCJmaWxlQ2hhbmdlQ2FjaGUiLCJzb3VyY2VNYXBQYXRoIiwiY3JlYXRlRnJvbUNvbXBpbGVyIiwiY29tcGlsZXIiLCJyZWFkT25seU1vZGUiLCJuZXdDYWNoZVBhdGgiLCJnZXRDYWNoZVBhdGgiLCJkaWdlc3RPYmoiLCJuYW1lIiwiT2JqZWN0IiwiZ2V0UHJvdG90eXBlT2YiLCJ2ZXJzaW9uIiwiZ2V0Q29tcGlsZXJWZXJzaW9uIiwib3B0aW9ucyIsImNvbXBpbGVyT3B0aW9ucyIsInBhdGgiLCJqb2luIiwiSlNPTiIsInN0cmluZ2lmeSIsIm1rZGlycCIsInN5bmMiLCJyZXQiLCJuZXdTb3VyY2VNYXBQYXRoIiwiZ2V0U291cmNlTWFwUGF0aCIsImdldCIsImZpbGVQYXRoIiwiaGFzaEluZm8iLCJnZXRIYXNoRm9yUGF0aCIsInJlc29sdmUiLCJjb2RlIiwibWltZVR5cGUiLCJiaW5hcnlEYXRhIiwiZGVwZW5kZW50RmlsZXMiLCJjYWNoZUZpbGUiLCJoYXNoIiwicmVzdWx0IiwiaXNGaWxlQmluYXJ5IiwiaW5mbyIsInBhcnNlIiwicGZzIiwicmVhZEZpbGUiLCJwemxpYiIsImd1bnppcCIsImJ1ZiIsInN0ciIsInRvU3RyaW5nIiwiZSIsIm1lc3NhZ2UiLCJzYXZlIiwiY29kZU9yQmluYXJ5RGF0YSIsInRhcmdldCIsImd6aXAiLCJ3cml0ZUZpbGUiLCJCdWZmZXIiLCJnZXRPckZldGNoIiwiZmV0Y2hlciIsImNhY2hlUmVzdWx0IiwiYW55RGVwZW5kZW5jaWVzQ2hhbmdlZCIsImhhdmVBbnlEZXBlbmRlbnRGaWxlc0NoYW5nZWQiLCJpc0luTm9kZU1vZHVsZXMiLCJtYXAiLCJzb3VyY2VNYXBzIiwic2F2ZVNvdXJjZU1hcCIsImxlbmd0aCIsImRlcGVuZGVudEZpbGUiLCJoYXNGaWxlQ2hhbmdlZCIsImRlcGVuZGVudEZpbGVDYWNoZVJlc3VsdCIsImFueVN1YmRlcGVuZGVudEZpbGVzQ2hhbmdlZCIsImdldFN5bmMiLCJnZXRIYXNoRm9yUGF0aFN5bmMiLCJmcyIsInJlYWRGaWxlU3luYyIsInpsaWIiLCJndW56aXBTeW5jIiwic2F2ZVN5bmMiLCJnemlwU3luYyIsIndyaXRlRmlsZVN5bmMiLCJnZXRPckZldGNoU3luYyIsInNhdmVTb3VyY2VNYXBTeW5jIiwiYnVpbGRTb3VyY2VNYXBUYXJnZXQiLCJmaWxlTmFtZSIsImJhc2VuYW1lIiwibWFwRmlsZU5hbWUiLCJyZXBsYWNlIiwiZXh0bmFtZSIsInNvdXJjZU1hcCIsInNob3VsZFBhc3N0aHJvdWdoIiwiaXNNaW5pZmllZCIsImhhc1NvdXJjZU1hcCJdLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUE7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7QUFDQTs7Ozs7Ozs7QUFFQSxNQUFNQSxJQUFJQyxRQUFRLE9BQVIsRUFBaUIsZ0NBQWpCLENBQVY7O0FBRUE7Ozs7Ozs7O0FBUWUsTUFBTUMsWUFBTixDQUFtQjtBQUNoQzs7Ozs7Ozs7OztBQVVBQyxjQUFZQyxTQUFaLEVBQXVCQyxlQUF2QixFQUE4RDtBQUFBLFFBQXRCQyxhQUFzQix1RUFBTixJQUFNOztBQUM1RCxTQUFLRixTQUFMLEdBQWlCQSxTQUFqQjtBQUNBLFNBQUtDLGVBQUwsR0FBdUJBLGVBQXZCO0FBQ0EsU0FBS0MsYUFBTCxHQUFxQkEsaUJBQWlCLEtBQUtGLFNBQTNDO0FBQ0Q7O0FBRUQ7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFzQkEsU0FBT0csa0JBQVAsQ0FBMEJILFNBQTFCLEVBQXFDSSxRQUFyQyxFQUErQ0gsZUFBL0MsRUFBNEc7QUFBQSxRQUE1Q0ksWUFBNEMsdUVBQTdCLEtBQTZCO0FBQUEsUUFBdEJILGFBQXNCLHVFQUFOLElBQU07O0FBQzFHLFFBQUlJLGVBQWUsSUFBbkI7QUFDQSxRQUFJQyxlQUFlLE1BQU07QUFDdkIsVUFBSUQsWUFBSixFQUFr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ZS1jYWNoZS5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBmcyBmcm9tICdmcyc7XG5pbXBvcnQgcGF0aCBmcm9tICdwYXRoJztcbmltcG9ydCB6bGliIGZyb20gJ3psaWInO1xuaW1wb3J0IGNyZWF0ZURpZ2VzdEZvck9iamVjdCBmcm9tICcuL2RpZ2VzdC1mb3Itb2JqZWN0JztcbmltcG9ydCB7cGZzLCBwemxpYn0gZnJvbSAnLi9wcm9taXNlJztcbmltcG9ydCBta2RpcnAgZnJvbSAnbWtkaXJwJztcblxuY29uc3QgZCA9IHJlcXVpcmUoJ2RlYnVnJykoJ2VsZWN0cm9uLWNvbXBpbGU6Y29tcGlsZS1jYWNoZScpO1xuXG4vKipcbiAqIENvbXBpbGVDYWNoZSBtYW5hZ2VzIGdldHRpbmcgYW5kIHNldHRpbmcgZW50cmllcyBmb3IgYSBzaW5nbGUgY29tcGlsZXI7IGVhY2hcbiAqIGluLXVzZSBjb21waWxlciB3aWxsIGhhdmUgYW4gaW5zdGFuY2Ugb2YgdGhpcyBjbGFzcywgdXN1YWxseSBjcmVhdGVkIHZpYVxuICoge0BsaW5rIGNyZWF0ZUZyb21Db21waWxlcn0uXG4gKlxuICogWW91IHVzdWFsbHkgd2lsbCBub3QgdXNlIHRoaXMgY2xhc3MgZGlyZWN0bHksIGl0IGlzIGFuIGltcGxlbWVudGF0aW9uIGNsYXNzXG4gKiBmb3Ige0BsaW5rIENvbXBpbGVIb3N0fS5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQ29tcGlsZUNhY2hlIHtcbiAgLyoqXG4gICAqIENyZWF0ZXMgYW4gaW5zdGFuY2UsIHVzdWFsbHkgdXNlZCBmb3IgdGVzdGluZyBvbmx5LlxuICAgKlxuICAgKiBAcGFyYW0gIHtzdHJpbmd9IGNhY2hlUGF0aCAgVGhlIHJvb3QgZGlyZWN0b3J5IHRvIHVzZSBhcyBhIGNhY2hlIHBhdGhcbiAgICpcbiAgICogQHBhcmFtICB7RmlsZUNoYW5nZWRDYWNoZX0gZmlsZUNoYW5nZUNhY2hlICBBIGZpbGUtY2hhbmdlIGNhY2hlIHRoYXQgaXNcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25hbGx5IHByZS1sb2FkZWQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzb3VyY2VNYXBQYXRoIFRoZSBkaXJlY3RvcnkgdG8gc3RvcmUgc291cmNlbWFwIHNlcGFyYXRlbHkgaWYgY29tcGlsZXIgb3B0aW9uIGVuYWJsZWQgdG8gZW1pdC5cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgRGVmYXVsdCB0byBjYWNoZVBhdGggaWYgbm90IHNwZWNpZmllZC5cbiAgICovXG4gIGNvbnN0cnVjdG9yKGNhY2hlUGF0aCwgZmlsZUNoYW5nZUNhY2hlLCBzb3VyY2VNYXBQYXRoID0gbnVsbCkge1xuICAgIHRoaXMuY2FjaGVQYXRoID0gY2FjaGVQYXRoO1xuICAgIHRoaXMuZmlsZUNoYW5nZUNhY2hlID0gZmlsZUNoYW5nZUNhY2hlO1xuICAgIHRoaXMuc291cmNlTWFwUGF0aCA9IHNvdXJjZU1hcFBhdGggfHwgdGhpcy5jYWNoZVBhdGg7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIENvbXBpbGVDYWNoZSBmcm9tIGEgY2xhc3MgY29tcGF0aWJsZSB3aXRoIHRoZSBDb21waWxlckJhc2VcbiAgICogaW50ZXJmYWNlLiBUaGlzIG1ldGhvZCB1c2VzIHRoZSBjb21waWxlciBuYW1lIC8gdmVyc2lvbiAvIG9wdGlvbnMgdG9cbiAgICogZ2VuZXJhdGUgYSB1bmlxdWUgZGlyZWN0b3J5IG5hbWUgZm9yIGNhY2hlZCByZXN1bHRzXG4gICAqXG4gICAqIEBwYXJhbSAge3N0cmluZ30gY2FjaGVQYXRoICBUaGUgcm9vdCBwYXRoIHRvIHVzZSBmb3IgdGhlIGNhY2hlLCBhIGRpcmVjdG9yeVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVwcmVzZW50aW5nIHRoZSBoYXNoIG9mIHRoZSBjb21waWxlciBwYXJhbWV0ZXJzXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aWxsIGJlIGNyZWF0ZWQgaGVyZS5cbiAgICpcbiAgICogQHBhcmFtICB7Q29tcGlsZXJCYXNlfSBjb21waWxlciAgVGhlIGNvbXBpbGVyIHRvIHVzZSBmb3IgdmVyc2lvbiAvIG9wdGlvblxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmZvcm1hdGlvbi5cbiAgICpcbiAgICogQHBhcmFtICB7RmlsZUNoYW5nZWRDYWNoZX0gZmlsZUNoYW5nZUNhY2hlICBBIGZpbGUtY2hhbmdlIGNhY2hlIHRoYXQgaXNcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25hbGx5IHByZS1sb2FkZWQuXG4gICAqXG4gICAqIEBwYXJhbSAge2Jvb2xlYW59IHJlYWRPbmx5TW9kZSAgRG9uJ3QgYXR0ZW1wdCB0byBjcmVhdGUgdGhlIGNhY2hlIGRpcmVjdG9yeS5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHNvdXJjZU1hcFBhdGggVGhlIGRpcmVjdG9yeSB0byBzdG9yZSBzb3VyY2VtYXAgc2VwYXJhdGVseSBpZiBjb21waWxlciBvcHRpb24gZW5hYmxlZCB0byBlbWl0LlxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBEZWZhdWx0IHRvIGNhY2hlUGF0aCBpZiBub3Qgc3BlY2lmaWVkLlxuICAgKlxuICAgKiBAcmV0dXJuIHtDb21waWxlQ2FjaGV9ICBBIGNvbmZpZ3VyZWQgQ29tcGlsZUNhY2hlIGluc3RhbmNlLlxuICAgKi9cbiAgc3RhdGljIGNyZWF0ZUZyb21Db21waWxlcihjYWNoZVBhdGgsIGNvbXBpbGVyLCBmaWxlQ2hhbmdlQ2FjaGUsIHJlYWRPbmx5TW9kZSA9IGZhbHNlLCBzb3VyY2VNYXBQYXRoID0gbnVsbCkge1xuICAgIGxldCBuZXdDYWNoZVBhdGggPSBudWxsO1xuICAgIGxldCBnZXRDYWNoZVBhdGggPSAoKSA9PiB7XG4gICAgICBpZiAobmV3Q2FjaGVQYXRoKSByZXR1cm4gbmV3Q2FjaGVQYXRoO1xuXG4gICAgICBjb25zdCBkaWdlc3RPYmogPSB7XG4gICAgICAgIG5hbWU6IGNvbXBpbGVyLm5hbWUgfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKGNvbXBpbGVyKS5jb25zdHJ1Y3Rvci5uYW1lLFxuICAgICAgICB2ZXJzaW9uOiBjb21waWxlci5nZXRDb21waWxlclZlcnNpb24oKSxcbiAgICAgICAgb3B0aW9uczogY29tcGlsZXIuY29tcGlsZXJPcHRpb25zXG4gICAgICB9O1xuXG4gICAgICBuZXdDYWNoZVBhdGggPSBwYXRoLmpvaW4oY2FjaGVQYXRoLCBjcmVhdGVEaWdlc3RGb3JPYmplY3QoZGlnZXN0T2JqKSk7XG5cbiAgICAgIGQoYFBhdGggZm9yICR7ZGlnZXN0T2JqLm5hbWV9OiAke25ld0NhY2hlUGF0aH1gKTtcbiAgICAgIGQoYFNldCB1cCB3aXRoIHBhcmFtZXRlcnM6ICR7SlNPTi5zdHJpbmdpZnkoZGlnZXN0T2JqKX1gKTtcblxuICAgICAgaWYgKCFyZWFkT25seU1vZGUpIG1rZGlycC5zeW5jKG5ld0NhY2hlUGF0aCk7XG4gICAgICByZXR1cm4gbmV3Q2FjaGVQYXRoO1xuICAgIH07XG5cbiAgICBsZXQgcmV0ID0gbmV3IENvbXBpbGVDYWNoZSgnJywgZmlsZUNoYW5nZUNhY2hlKTtcbiAgICByZXQuZ2V0Q2FjaGVQYXRoID0gZ2V0Q2FjaGVQYXRoO1xuXG4gICAgY29uc3QgbmV3U291cmNlTWFwUGF0aCA9IHNvdXJjZU1hcFBhdGg7XG4gICAgcmV0LmdldFNvdXJjZU1hcFBhdGggPSAoKSA9PiBuZXdTb3VyY2VNYXBQYXRoIHx8IGdldENhY2hlUGF0aCgpO1xuXG4gICAgcmV0dXJuIHJldDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgZmlsZSdzIGNvbXBpbGVkIGNvbnRlbnRzIGZyb20gdGhlIGNhY2hlLlxuICAgKlxuICAgKiBAcGFyYW0gIHtzdHJpbmd9IGZpbGVQYXRoICBUaGUgcGF0aCB0byB0aGUgZmlsZS4gRmlsZUNoYW5nZWRDYWNoZSB3aWxsIGxvb2tcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgdXAgdGhlIGhhc2ggYW5kIHVzZSB0aGF0IGFzIHRoZSBrZXkgaW4gdGhlIGNhY2hlLlxuICAgKlxuICAgKiBAcmV0dXJuIHtQcm9taXNlPE9iamVjdD59ICBBbiBvYmplY3Qgd2l0aCBhbGwga2luZHMgb2YgaW5mb3JtYXRpb25cbiAgICpcbiAgICogQHByb3BlcnR5IHtPYmplY3R9IGhhc2hJbmZvICBUaGUgaGFzaCBpbmZvcm1hdGlvbiByZXR1cm5lZCBmcm9tIGdldEhhc2hGb3JQYXRoXG4gICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBjb2RlICBUaGUgc291cmNlIGNvZGUgaWYgdGhlIGZpbGUgd2FzIGEgdGV4dCBmaWxlXG4gICAqIEBwcm9wZXJ0eSB7QnVmZmVyfSBiaW5hcnlEYXRhICBUaGUgZmlsZSBpZiBpdCB3YXMgYSBiaW5hcnkgZmlsZVxuICAgKiBAcHJvcGVydHkge3N0cmluZ30gbWltZVR5cGUgIFRoZSBNSU1FIHR5cGUgc2F2ZWQgaW4gdGhlIGNhY2hlLlxuICAgKiBAcHJvcGVydHkge3N0cmluZ1tdfSBkZXBlbmRlbnRGaWxlcyAgVGhlIGRlcGVuZGVudCBmaWxlcyByZXR1cm5lZCBmcm9tXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb21waWxpbmcgdGhlIGZpbGUsIGlmIGFueS5cbiAgICovXG4gIGFzeW5jIGdldChmaWxlUGF0aCkge1xuICAgIGQoYEZldGNoaW5nICR7ZmlsZVBhdGh9IGZyb20gY2FjaGVgKTtcbiAgICBsZXQgaGFzaEluZm8gPSBhd2FpdCB0aGlzLmZpbGVDaGFuZ2VDYWNoZS5nZXRIYXNoRm9yUGF0aChwYXRoLnJlc29sdmUoZmlsZVBhdGgpKTtcblxuICAgIGxldCBjb2RlID0gbnVsbDtcbiAgICBsZXQgbWltZVR5cGUgPSBudWxsO1xuICAgIGxldCBiaW5hcnlEYXRhID0gbnVsbDtcbiAgICBsZXQgZGVwZW5kZW50RmlsZXMgPSBudWxsO1xuXG4gICAgbGV0IGNhY2hlRmlsZSA9IG51bGw7XG4gICAgdHJ5IHtcbiAgICAgIGNhY2hlRmlsZSA9IHBhdGguam9pbih0aGlzLmdldENhY2hlUGF0aCgpLCBoYXNoSW5mby5oYXNoKTtcbiAgICAgIGxldCByZXN1bHQgPSBudWxsO1xuXG4gICAgICBpZiAoaGFzaEluZm8uaXNGaWxlQmluYXJ5KSB7XG4gICAgICAgIGQoXCJGaWxlIGlzIGJpbmFyeSwgcmVhZGluZyBvdXQgaW5mb1wiKTtcbiAgICAgICAgbGV0IGluZm8gPSBKU09OLnBhcnNlKGF3YWl0IHBmcy5yZWFkRmlsZShjYWNoZUZpbGUgKyAnLmluZm8nKSk7XG4gICAgICAgIG1pbWVUeXBlID0gaW5mby5taW1lVHlwZTtcbiAgICAgICAgZGVwZW5kZW50RmlsZXMgPSBpbmZvLmRlcGVuZGVudEZpbGVzO1xuXG4gICAgICAgIGJpbmFyeURhdGEgPSBoYXNoSW5mby5iaW5hcnlEYXRhO1xuICAgICAgICBpZiAoIWJpbmFyeURhdGEpIHtcbiAgICAgICAgICBiaW5hcnlEYXRhID0gYXdhaXQgcGZzLnJlYWRGaWxlKGNhY2hlRmlsZSk7XG4gICAgICAgICAgYmluYXJ5RGF0YSA9IGF3YWl0IHB6bGliLmd1bnppcChiaW5hcnlEYXRhKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGV0IGJ1ZiA9IGF3YWl0IHBmcy5yZWFkRmlsZShjYWNoZUZpbGUpO1xuICAgICAgICBsZXQgc3RyID0gKGF3YWl0IHB6bGliLmd1bnppcChidWYpKS50b1N0cmluZygndXRmOCcpO1xuXG4gICAgICAgIHJlc3VsdCA9IEpTT04ucGFyc2Uoc3RyKTtcbiAgICAgICAgY29kZSA9IHJlc3VsdC5jb2RlO1xuICAgICAgICBtaW1lVHlwZSA9IHJlc3VsdC5taW1lVHlwZTtcbiAgICAgICAgZGVwZW5kZW50RmlsZXMgPSByZXN1bHQuZGVwZW5kZW50RmlsZXM7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgZChgRmFpbGVkIHRvIHJlYWQgY2FjaGUgZm9yICR7ZmlsZVBhdGh9LCBsb29rZWQgaW4gJHtjYWNoZUZpbGV9OiAke2UubWVzc2FnZX1gKTtcbiAgICB9XG5cbiAgICByZXR1cm4geyBoYXNoSW5mbywgY29kZSwgbWltZVR5cGUsIGJpbmFyeURhdGEsIGRlcGVuZGVudEZpbGVzIH07XG4gIH1cblxuXG4gIC8qKlxuICAgKiBTYXZlcyBhIGNvbXBpbGVkIHJlc3VsdCB0byBjYWNoZVxuICAgKlxuICAgKiBAcGFyYW0gIHtPYmplY3R9IGhhc2hJbmZvICBUaGUgaGFzaCBpbmZvcm1hdGlvbiByZXR1cm5lZCBmcm9tIGdldEhhc2hGb3JQYXRoXG4gICAqXG4gICAqIEBwYXJhbSAge3N0cmluZyAvIEJ1ZmZlcn0gY29kZU9yQmluYXJ5RGF0YSAgIFRoZSBmaWxlJ3MgY29udGVudHMsIGVpdGhlciBhc1xuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhIHN0cmluZyBvciBhIEJ1ZmZlci5cbiAgICogQHBhcmFtICB7c3RyaW5nfSBtaW1lVHlwZSAgVGhlIE1JTUUgdHlwZSByZXR1cm5lZCBieSB0aGUgY29tcGlsZXIuXG4gICAqXG4gICAqIEBwYXJhbSAge3N0cmluZ1tdfSBkZXBlbmRlbnRGaWxlcyAgVGhlIGxpc3Qgb2YgZGVwZW5kZW50IGZpbGVzIHJldHVybmVkIGJ5XG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhlIGNvbXBpbGVyLlxuICAgKiBAcmV0dXJuIHtQcm9taXNlfSAgQ29tcGxldGlvbi5cbiAgICovXG4gIGFzeW5jIHNhdmUoaGFzaEluZm8sIGNvZGVPckJpbmFyeURhdGEsIG1pbWVUeXBlLCBkZXBlbmRlbnRGaWxlcykge1xuICAgIGxldCBidWYgPSBudWxsO1xuICAgIGxldCB0YXJnZXQgPSBwYXRoLmpvaW4odGhpcy5nZXRDYWNoZVBhdGgoKSwgaGFzaEluZm8uaGFzaCk7XG4gICAgZChgU2F2aW5nIHRvICR7dGFyZ2V0fWApO1xuXG4gICAgaWYgKGhhc2hJbmZvLmlzRmlsZUJpbmFyeSkge1xuICAgICAgYnVmID0gYXdhaXQgcHpsaWIuZ3ppcChjb2RlT3JCaW5hcnlEYXRhKTtcbiAgICAgIGF3YWl0IHBmcy53cml0ZUZpbGUodGFyZ2V0ICsgJy5pbmZvJywgSlNPTi5zdHJpbmdpZnkoe21pbWVUeXBlLCBkZXBlbmRlbnRGaWxlc30pLCAndXRmOCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICBidWYgPSBhd2FpdCBwemxpYi5nemlwKG5ldyBCdWZmZXIoSlNPTi5zdHJpbmdpZnkoe2NvZGU6IGNvZGVPckJpbmFyeURhdGEsIG1pbWVUeXBlLCBkZXBlbmRlbnRGaWxlc30pKSk7XG4gICAgfVxuXG4gICAgYXdhaXQgcGZzLndyaXRlRmlsZSh0YXJnZXQsIGJ1Zik7XG4gIH1cblxuICAvKipcbiAgICogQXR0ZW1wdHMgdG8gZmlyc3QgZ2V0IGEga2V5IHZpYSB7QGxpbmsgZ2V0fSwgdGhlbiBpZiBpdCBmYWlscywgY2FsbCBhIG1ldGhvZFxuICAgKiB0byByZXRyaWV2ZSB0aGUgY29udGVudHMsIHRoZW4gc2F2ZSB0aGUgcmVzdWx0IHRvIGNhY2hlLlxuICAgKlxuICAgKiBUaGUgZmV0Y2hlciBwYXJhbWV0ZXIgaXMgZXhwZWN0ZWQgdG8gaGF2ZSB0aGUgc2lnbmF0dXJlOlxuICAgKlxuICAgKiBQcm9taXNlPE9iamVjdD4gZmV0Y2hlcihmaWxlUGF0aCA6IHN0cmluZywgaGFzaEluZm8gOiBPYmplY3QpO1xuICAgKlxuICAgKiBoYXNoSW5mbyBpcyBhIHZhbHVlIHJldHVybmVkIGZyb20gZ2V0SGFzaEZvclBhdGhcbiAgICogVGhlIHJldHVybiB2YWx1ZSBvZiBmZXRjaGVyIG11c3QgYmUgYW4gT2JqZWN0IHdpdGggdGhlIHByb3BlcnRpZXM6XG4gICAqXG4gICAqIG1pbWVUeXBlIC0gdGhlIE1JTUUgdHlwZSBvZiB0aGUgZGF0YSB0byBzYXZlXG4gICAqIGNvZGUgKG9wdGlvbmFsKSAtIHRoZSBzb3VyY2UgY29kZSBhcyBhIHN0cmluZywgaWYgZmlsZSBpcyB0ZXh0XG4gICAqIGJpbmFyeURhdGEgKG9wdGlvbmFsKSAtIHRoZSBmaWxlIGNvbnRlbnRzIGFzIGEgQnVmZmVyLCBpZiBmaWxlIGlzIGJpbmFyeVxuICAgKiBkZXBlbmRlbnRGaWxlcyAtIHRoZSBkZXBlbmRlbnQgZmlsZXMgcmV0dXJuZWQgYnkgdGhlIGNvbXBpbGVyLlxuICAgKlxuICAgKiBAcGFyYW0gIHtzdHJpbmd9IGZpbGVQYXRoICBUaGUgcGF0aCB0byB0aGUgZmlsZS4gRmlsZUNoYW5nZWRDYWNoZSB3aWxsIGxvb2tcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgdXAgdGhlIGhhc2ggYW5kIHVzZSB0aGF0IGFzIHRoZSBrZXkgaW4gdGhlIGNhY2hlLlxuICAgKlxuICAgKiBAcGFyYW0gIHtGdW5jdGlvbn0gZmV0Y2hlciAgQSBtZXRob2Qgd2hpY2ggY29uZm9ybXMgdG8gdGhlIGRlc2NyaXB0aW9uIGFib3ZlLlxuICAgKlxuICAgKiBAcmV0dXJuIHtQcm9taXNlPE9iamVjdD59ICBBbiBPYmplY3Qgd2hpY2ggaGFzIHRoZSBzYW1lIGZpZWxkcyBhcyB0aGVcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAge0BsaW5rIGdldH0gbWV0aG9kIHJldHVybiByZXN1bHQuXG4gICAqL1xuICBhc3luYyBnZXRPckZldGNoKGZpbGVQYXRoLCBmZXRjaGVyKSB7XG4gICAgbGV0IGNhY2hlUmVzdWx0ID0gYXdhaXQgdGhpcy5nZXQoZmlsZVBhdGgpO1xuICAgIGxldCBhbnlEZXBlbmRlbmNpZXNDaGFuZ2VkID0gYXdhaXQgdGhpcy5oYXZlQW55RGVwZW5kZW50RmlsZXNDaGFuZ2VkKGNhY2hlUmVzdWx0KTtcblxuICAgIGlmICgoY2FjaGVSZXN1bHQuY29kZSB8fCBjYWNoZVJlc3VsdC5iaW5hcnlEYXRhKSAmJiAhYW55RGVwZW5kZW5jaWVzQ2hhbmdlZCkge1xuICAgICAgcmV0dXJuIGNhY2hlUmVzdWx0O1xuICAgIH1cblxuICAgIGxldCByZXN1bHQgPSBhd2FpdCBmZXRjaGVyKGZpbGVQYXRoLCBjYWNoZVJlc3VsdC5oYXNoSW5mbykgfHwgeyBoYXNoSW5mbzogY2FjaGVSZXN1bHQuaGFzaEluZm8gfTtcblxuICAgIGlmIChyZXN1bHQubWltZVR5cGUgJiYgIWNhY2hlUmVzdWx0Lmhhc2hJbmZvLmlzSW5Ob2RlTW9kdWxlcykge1xuICAgICAgZChgQ2FjaGUgbWlzczogc2F2aW5nIG91dCBpbmZvIGZvciAke2ZpbGVQYXRofWApO1xuICAgICAgYXdhaXQgdGhpcy5zYXZlKGNhY2hlUmVzdWx0Lmhhc2hJbmZvLCByZXN1bHQuY29kZSB8fCByZXN1bHQuYmluYXJ5RGF0YSwgcmVzdWx0Lm1pbWVUeXBlLCByZXN1bHQuZGVwZW5kZW50RmlsZXMpO1xuXG4gICAgICBjb25zdCBtYXAgPSByZXN1bHQuc291cmNlTWFwcztcbiAgICAgIGlmIChtYXApIHtcbiAgICAgICAgZChgc291cmNlIG1hcCBmb3IgJHtmaWxlUGF0aH0gZm91bmQsIHNhdmluZyBpdCB0byAke3RoaXMuZ2V0U291cmNlTWFwUGF0aCgpfWApO1xuICAgICAgICBhd2FpdCB0aGlzLnNhdmVTb3VyY2VNYXAoY2FjaGVSZXN1bHQuaGFzaEluZm8sIGZpbGVQYXRoLCBtYXApO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJlc3VsdC5oYXNoSW5mbyA9IGNhY2hlUmVzdWx0Lmhhc2hJbmZvO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGUgQ2hlY2sgaWYgYW55IG9mIGEgZmlsZSdzIGRlcGVuZGVuY2llcyBoYXZlIGNoYW5nZWRcbiAgICovXG4gIGFzeW5jIGhhdmVBbnlEZXBlbmRlbnRGaWxlc0NoYW5nZWQoY2FjaGVSZXN1bHQpIHtcbiAgICBpZiAoIWNhY2hlUmVzdWx0LmNvZGUgfHwgIWNhY2hlUmVzdWx0LmRlcGVuZGVudEZpbGVzLmxlbmd0aCkgcmV0dXJuIGZhbHNlO1xuXG4gICAgZm9yIChsZXQgZGVwZW5kZW50RmlsZSBvZiBjYWNoZVJlc3VsdC5kZXBlbmRlbnRGaWxlcykge1xuICAgICAgbGV0IGhhc0ZpbGVDaGFuZ2VkID0gYXdhaXQgdGhpcy5maWxlQ2hhbmdlQ2FjaGUuaGFzRmlsZUNoYW5nZWQoZGVwZW5kZW50RmlsZSk7XG4gICAgICBpZiAoaGFzRmlsZUNoYW5nZWQpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIGxldCBkZXBlbmRlbnRGaWxlQ2FjaGVSZXN1bHQgPSBhd2FpdCB0aGlzLmdldChkZXBlbmRlbnRGaWxlKTtcbiAgICAgIGlmIChkZXBlbmRlbnRGaWxlQ2FjaGVSZXN1bHQuZGVwZW5kZW50RmlsZXMgJiYgZGVwZW5kZW50RmlsZUNhY2hlUmVzdWx0LmRlcGVuZGVudEZpbGVzLmxlbmd0aCkge1xuICAgICAgICBsZXQgYW55U3ViZGVwZW5kZW50RmlsZXNDaGFuZ2VkID0gYXdhaXQgdGhpcy5oYXZlQW55RGVwZW5kZW50RmlsZXNDaGFuZ2VkKGRlcGVuZGVudEZpbGVDYWNoZVJlc3VsdCk7XG4gICAgICAgIGlmIChhbnlTdWJkZXBlbmRlbnRGaWxlc0NoYW5nZWQpIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG5cbiAgZ2V0U3luYyhmaWxlUGF0aCkge1xuICAgIGQoYEZldGNoaW5nICR7ZmlsZVBhdGh9IGZyb20gY2FjaGVgKTtcbiAgICBsZXQgaGFzaEluZm8gPSB0aGlzLmZpbGVDaGFuZ2VDYWNoZS5nZXRIYXNoRm9yUGF0aFN5bmMocGF0aC5yZXNvbHZlKGZpbGVQYXRoKSk7XG5cbiAgICBsZXQgY29kZSA9IG51bGw7XG4gICAgbGV0IG1pbWVUeXBlID0gbnVsbDtcbiAgICBsZXQgYmluYXJ5RGF0YSA9IG51bGw7XG4gICAgbGV0IGRlcGVuZGVudEZpbGVzID0gbnVsbDtcblxuICAgIHRyeSB7XG4gICAgICBsZXQgY2FjaGVGaWxlID0gcGF0aC5qb2luKHRoaXMuZ2V0Q2FjaGVQYXRoKCksIGhhc2hJbmZvLmhhc2gpO1xuXG4gICAgICBsZXQgcmVzdWx0ID0gbnVsbDtcbiAgICAgIGlmIChoYXNoSW5mby5pc0ZpbGVCaW5hcnkpIHtcbiAgICAgICAgZChcIkZpbGUgaXMgYmluYXJ5LCByZWFkaW5nIG91dCBpbmZvXCIpO1xuICAgICAgICBsZXQgaW5mbyA9IEpTT04ucGFyc2UoZnMucmVhZEZpbGVTeW5jKGNhY2hlRmlsZSArICcuaW5mbycpKTtcbiAgICAgICAgbWltZVR5cGUgPSBpbmZvLm1pbWVUeXBlO1xuICAgICAgICBkZXBlbmRlbnRGaWxlcyA9IGluZm8uZGVwZW5kZW50RmlsZXM7XG5cbiAgICAgICAgYmluYXJ5RGF0YSA9IGhhc2hJbmZvLmJpbmFyeURhdGE7XG4gICAgICAgIGlmICghYmluYXJ5RGF0YSkge1xuICAgICAgICAgIGJpbmFyeURhdGEgPSBmcy5yZWFkRmlsZVN5bmMoY2FjaGVGaWxlKTtcbiAgICAgICAgICBiaW5hcnlEYXRhID0gemxpYi5ndW56aXBTeW5jKGJpbmFyeURhdGEpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsZXQgYnVmID0gZnMucmVhZEZpbGVTeW5jKGNhY2hlRmlsZSk7XG4gICAgICAgIGxldCBzdHIgPSAoemxpYi5ndW56aXBTeW5jKGJ1ZikpLnRvU3RyaW5nKCd1dGY4Jyk7XG5cbiAgICAgICAgcmVzdWx0ID0gSlNPTi5wYXJzZShzdHIpO1xuICAgICAgICBjb2RlID0gcmVzdWx0LmNvZGU7XG4gICAgICAgIG1pbWVUeXBlID0gcmVzdWx0Lm1pbWVUeXBlO1xuICAgICAgICBkZXBlbmRlbnRGaWxlcyA9IHJlc3VsdC5kZXBlbmRlbnRGaWxlcztcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBkKGBGYWlsZWQgdG8gcmVhZCBjYWNoZSBmb3IgJHtmaWxlUGF0aH1gKTtcbiAgICB9XG5cbiAgICByZXR1cm4geyBoYXNoSW5mbywgY29kZSwgbWltZVR5cGUsIGJpbmFyeURhdGEsIGRlcGVuZGVudEZpbGVzIH07XG4gIH1cblxuICBzYXZlU3luYyhoYXNoSW5mbywgY29kZU9yQmluYXJ5RGF0YSwgbWltZVR5cGUsIGRlcGVuZGVudEZpbGVzKSB7XG4gICAgbGV0IGJ1ZiA9IG51bGw7XG4gICAgbGV0IHRhcmdldCA9IHBhdGguam9pbih0aGlzLmdldENhY2hlUGF0aCgpLCBoYXNoSW5mby5oYXNoKTtcbiAgICBkKGBTYXZpbmcgdG8gJHt0YXJnZXR9YCk7XG5cbiAgICBpZiAoaGFzaEluZm8uaXNGaWxlQmluYXJ5KSB7XG4gICAgICBidWYgPSB6bGliLmd6aXBTeW5jKGNvZGVPckJpbmFyeURhdGEpO1xuICAgICAgZnMud3JpdGVGaWxlU3luYyh0YXJnZXQgKyAnLmluZm8nLCBKU09OLnN0cmluZ2lmeSh7bWltZVR5cGUsIGRlcGVuZGVudEZpbGVzfSksICd1dGY4Jyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGJ1ZiA9IHpsaWIuZ3ppcFN5bmMobmV3IEJ1ZmZlcihKU09OLnN0cmluZ2lmeSh7Y29kZTogY29kZU9yQmluYXJ5RGF0YSwgbWltZVR5cGUsIGRlcGVuZGVudEZpbGVzfSkpKTtcbiAgICB9XG5cbiAgICBmcy53cml0ZUZpbGVTeW5jKHRhcmdldCwgYnVmKTtcbiAgfVxuXG4gIGdldE9yRmV0Y2hTeW5jKGZpbGVQYXRoLCBmZXRjaGVyKSB7XG4gICAgbGV0IGNhY2hlUmVzdWx0ID0gdGhpcy5nZXRTeW5jKGZpbGVQYXRoKTtcbiAgICBpZiAoY2FjaGVSZXN1bHQuY29kZSB8fCBjYWNoZVJlc3VsdC5iaW5hcnlEYXRhKSByZXR1cm4gY2FjaGVSZXN1bHQ7XG5cbiAgICBsZXQgcmVzdWx0ID0gZmV0Y2hlcihmaWxlUGF0aCwgY2FjaGVSZXN1bHQuaGFzaEluZm8pIHx8IHsgaGFzaEluZm86IGNhY2hlUmVzdWx0Lmhhc2hJbmZvIH07XG5cbiAgICBpZiAocmVzdWx0Lm1pbWVUeXBlICYmICFjYWNoZVJlc3VsdC5oYXNoSW5mby5pc0luTm9kZU1vZHVsZXMpIHtcbiAgICAgIGQoYENhY2hlIG1pc3M6IHNhdmluZyBvdXQgaW5mbyBmb3IgJHtmaWxlUGF0aH1gKTtcbiAgICAgIHRoaXMuc2F2ZVN5bmMoY2FjaGVSZXN1bHQuaGFzaEluZm8sIHJlc3VsdC5jb2RlIHx8IHJlc3VsdC5iaW5hcnlEYXRhLCByZXN1bHQubWltZVR5cGUsIHJlc3VsdC5kZXBlbmRlbnRGaWxlcyk7XG4gICAgfVxuXG4gICAgY29uc3QgbWFwID0gcmVzdWx0LnNvdXJjZU1hcHM7XG4gICAgaWYgKG1hcCkge1xuICAgICAgZChgc291cmNlIG1hcCBmb3IgJHtmaWxlUGF0aH0gZm91bmQsIHNhdmluZyBpdCB0byAke3RoaXMuZ2V0U291cmNlTWFwUGF0aCgpfWApO1xuICAgICAgdGhpcy5zYXZlU291cmNlTWFwU3luYyhjYWNoZVJlc3VsdC5oYXNoSW5mbywgZmlsZVBhdGgsIG1hcCk7XG4gICAgfVxuXG4gICAgcmVzdWx0Lmhhc2hJbmZvID0gY2FjaGVSZXN1bHQuaGFzaEluZm87XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIGJ1aWxkU291cmNlTWFwVGFyZ2V0KGhhc2hJbmZvLCBmaWxlUGF0aCkge1xuICAgIGNvbnN0IGZpbGVOYW1lID0gcGF0aC5iYXNlbmFtZShmaWxlUGF0aCk7XG4gICAgY29uc3QgbWFwRmlsZU5hbWUgPSBmaWxlTmFtZS5yZXBsYWNlKHBhdGguZXh0bmFtZShmaWxlTmFtZSksICcuanMubWFwJyk7XG5cbiAgICBjb25zdCB0YXJnZXQgPSBwYXRoLmpvaW4odGhpcy5nZXRTb3VyY2VNYXBQYXRoKCksIG1hcEZpbGVOYW1lKTtcbiAgICBkKGBTb3VyY2VtYXAgdGFyZ2V0IGlzOiAke3RhcmdldH1gKTtcblxuICAgIHJldHVybiB0YXJnZXQ7XG4gIH1cblxuICAvKipcbiAgICogU2F2ZXMgc291cmNlbWFwIHN0cmluZyBpbnRvIGNhY2hlLCBvciBzcGVjaWZpZWQgc2VwYXJhdGUgZGlyXG4gICAqXG4gICAqIEBwYXJhbSAge09iamVjdH0gaGFzaEluZm8gIFRoZSBoYXNoIGluZm9ybWF0aW9uIHJldHVybmVkIGZyb20gZ2V0SGFzaEZvclBhdGhcbiAgICpcbiAgICogQHBhcmFtICB7c3RyaW5nfSBmaWxlUGF0aCBQYXRoIHRvIG9yaWdpbmFsIGZpbGUgdG8gY29uc3RydWN0IHNvdXJjZW1hcCBmaWxlIG5hbWVcblxuICAgKiBAcGFyYW0gIHtzdHJpbmd9IHNvdXJjZU1hcCBTb3VyY2VtYXAgZGF0YSBhcyBzdHJpbmdcbiAgICpcbiAgICogQG1lbWJlck9mIENvbXBpbGVDYWNoZVxuICAgKi9cbiAgYXN5bmMgc2F2ZVNvdXJjZU1hcChoYXNoSW5mbywgZmlsZVBhdGgsIHNvdXJjZU1hcCkge1xuICAgIGNvbnN0IHRhcmdldCA9IHRoaXMuYnVpbGRTb3VyY2VNYXBUYXJnZXQoaGFzaEluZm8sIGZpbGVQYXRoKTtcbiAgICBhd2FpdCBwZnMud3JpdGVGaWxlKHRhcmdldCwgc291cmNlTWFwLCAndXRmLTgnKTtcbiAgfVxuXG4gIHNhdmVTb3VyY2VNYXBTeW5jKGhhc2hJbmZvLCBmaWxlUGF0aCwgc291cmNlTWFwKSB7XG4gICAgY29uc3QgdGFyZ2V0ID0gdGhpcy5idWlsZFNvdXJjZU1hcFRhcmdldChoYXNoSW5mbywgZmlsZVBhdGgpO1xuICAgIGZzLndyaXRlRmlsZVN5bmModGFyZ2V0LCBzb3VyY2VNYXAsICd1dGYtOCcpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBnZXRDYWNoZVBhdGgoKSB7XG4gICAgLy8gTkI6IFRoaXMgaXMgYW4gZXZpbCBoYWNrIHNvIHRoYXQgY3JlYXRlRnJvbUNvbXBpbGVyIGNhbiBzdG9tcCBpdFxuICAgIC8vIGF0IHdpbGxcbiAgICByZXR1cm4gdGhpcy5jYWNoZVBhdGg7XG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGdldFNvdXJjZU1hcFBhdGgoKSB7XG4gICAgcmV0dXJuIHRoaXMuc291cmNlTWFwUGF0aDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHdoZXRoZXIgYSBmaWxlIHNob3VsZCBub3QgYmUgY29tcGlsZWQuIE5vdGUgdGhhdCB0aGlzIGRvZXNuJ3RcbiAgICogbmVjZXNzYXJpbHkgbWVhbiBpdCB3b24ndCBlbmQgdXAgaW4gdGhlIGNhY2hlLCBvbmx5IHRoYXQgaXRzIGNvbnRlbnRzIGFyZVxuICAgKiBzYXZlZCB2ZXJiYXRpbSBpbnN0ZWFkIG9mIHRyeWluZyB0byBmaW5kIGFuIGFwcHJvcHJpYXRlIGNvbXBpbGVyLlxuICAgKlxuICAgKiBAcGFyYW0gIHtPYmplY3R9IGhhc2hJbmZvICBUaGUgaGFzaCBpbmZvcm1hdGlvbiByZXR1cm5lZCBmcm9tIGdldEhhc2hGb3JQYXRoXG4gICAqXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59ICBUcnVlIGlmIGEgZmlsZSBzaG91bGQgYmUgaWdub3JlZFxuICAgKi9cbiAgc3RhdGljIHNob3VsZFBhc3N0aHJvdWdoKGhhc2hJbmZvKSB7XG4gICAgcmV0dXJuIGhhc2hJbmZvLmlzTWluaWZpZWQgfHwgaGFzaEluZm8uaXNJbk5vZGVNb2R1bGVzIHx8IGhhc2hJbmZvLmhhc1NvdXJjZU1hcCB8fCBoYXNoSW5mby5pc0ZpbGVCaW5hcnk7XG4gIH1cbn1cbiJdfQ==\n\n//# sourceURL=webpack:///./node_modules/electron-compile/lib/compile-cache.js?")},"./node_modules/electron-compile/lib/compiler-host.js":
/*!************************************************************!*\
  !*** ./node_modules/electron-compile/lib/compiler-host.js ***!
  \************************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){"use strict";eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nvar _mimeTypes = __webpack_require__(/*! @paulcbetts/mime-types */ \"./node_modules/@paulcbetts/mime-types/index.js\");\n\nvar _mimeTypes2 = _interopRequireDefault(_mimeTypes);\n\nvar _fs = __webpack_require__(/*! fs */ \"fs\");\n\nvar _fs2 = _interopRequireDefault(_fs);\n\nvar _zlib = __webpack_require__(/*! zlib */ \"zlib\");\n\nvar _zlib2 = _interopRequireDefault(_zlib);\n\nvar _path = __webpack_require__(/*! path */ \"path\");\n\nvar _path2 = _interopRequireDefault(_path);\n\nvar _promise = __webpack_require__(/*! ./promise */ \"./node_modules/electron-compile/lib/promise.js\");\n\nvar _forAllFiles = __webpack_require__(/*! ./for-all-files */ \"./node_modules/electron-compile/lib/for-all-files.js\");\n\nvar _compileCache = __webpack_require__(/*! ./compile-cache */ \"./node_modules/electron-compile/lib/compile-cache.js\");\n\nvar _compileCache2 = _interopRequireDefault(_compileCache);\n\nvar _fileChangeCache = __webpack_require__(/*! ./file-change-cache */ \"./node_modules/electron-compile/lib/file-change-cache.js\");\n\nvar _fileChangeCache2 = _interopRequireDefault(_fileChangeCache);\n\nvar _readOnlyCompiler = __webpack_require__(/*! ./read-only-compiler */ \"./node_modules/electron-compile/lib/read-only-compiler.js\");\n\nvar _readOnlyCompiler2 = _interopRequireDefault(_readOnlyCompiler);\n\nvar _browserSignal = __webpack_require__(/*! ./browser-signal */ \"./node_modules/electron-compile/lib/browser-signal.js\");\n\n__webpack_require__(/*! rxjs/add/operator/map */ \"./node_modules/electron-compile/node_modules/rxjs/add/operator/map.js\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step(\"next\", value); }, function (err) { step(\"throw\", err); }); } } return step(\"next\"); }); }; }\n\nconst d = __webpack_require__(/*! debug */ \"./node_modules/debug/src/index.js\")('electron-compile:compiler-host');\n\n__webpack_require__(/*! ./rig-mime-types */ \"./node_modules/electron-compile/lib/rig-mime-types.js\").init();\n\n// This isn't even my\nconst finalForms = {\n  'text/javascript': true,\n  'application/javascript': true,\n  'text/html': true,\n  'text/css': true,\n  'image/svg+xml': true,\n  'application/json': true\n};\n\n/**\n * This class is the top-level class that encapsulates all of the logic of\n * compiling and caching application code. If you're looking for a \"Main class\",\n * this is it.\n *\n * This class can be created directly but it is usually created via the methods\n * in config-parser, which will among other things, set up the compiler options\n * given a project root.\n *\n * CompilerHost is also the top-level class that knows how to serialize all of the\n * information necessary to recreate itself, either as a development host (i.e.\n * will allow cache misses and actual compilation), or as a read-only version of\n * itself for production.\n */\nclass CompilerHost {\n  /**\n   * Creates an instance of CompilerHost. You probably want to use the methods\n   * in config-parser for development, or {@link createReadonlyFromConfiguration}\n   * for production instead.\n   *\n   * @param  {string} rootCacheDir  The root directory to use for the cache\n   *\n   * @param  {Object} compilers  an Object whose keys are input MIME types and\n   *                             whose values are instances of CompilerBase. Create\n   *                             this via the {@link createCompilers} method in\n   *                             config-parser.\n   *\n   * @param  {FileChangedCache} fileChangeCache  A file-change cache that is\n   *                                             optionally pre-loaded.\n   *\n   * @param  {boolean} readOnlyMode  If True, cache misses will fail and\n   *                                 compilation will not be attempted.\n   *\n   * @param  {CompilerBase} fallbackCompiler (optional)  When a file is compiled\n   *                                         which doesn't have a matching compiler,\n   *                                         this compiler will be used instead. If\n   *                                         null, will fail compilation. A good\n   *                                         alternate fallback is the compiler for\n   *                                         'text/plain', which is guaranteed to be\n   *                                         present.\n   *\n   * @param {string} sourceMapPath (optional) The directory to store sourcemap separately\n   *                               if compiler option enabled to emit.\n   *                               Default to cachePath if not specified.\n   */\n  constructor(rootCacheDir, compilers, fileChangeCache, readOnlyMode) {\n    let fallbackCompiler = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;\n    let sourceMapPath = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : null;\n    let mimeTypesToRegister = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : null;\n\n    let compilersByMimeType = Object.assign({}, compilers);\n    Object.assign(this, { rootCacheDir, compilersByMimeType, fileChangeCache, readOnlyMode, fallbackCompiler });\n    this.appRoot = this.fileChangeCache.appRoot;\n\n    this.cachesForCompilers = Object.keys(compilersByMimeType).reduce((acc, x) => {\n      let compiler = compilersByMimeType[x];\n      if (acc.has(compiler)) return acc;\n\n      acc.set(compiler, _compileCache2.default.createFromCompiler(rootCacheDir, compiler, fileChangeCache, readOnlyMode, sourceMapPath));\n      return acc;\n    }, new Map());\n\n    this.mimeTypesToRegister = mimeTypesToRegister || {};\n  }\n\n  /**\n   * Creates a production-mode CompilerHost from the previously saved\n   * configuration\n   *\n   * @param  {string} rootCacheDir  The root directory to use for the cache. This\n   *                                cache must have cache information saved via\n   *                                {@link saveConfiguration}\n   *\n   * @param  {string} appRoot  The top-level directory for your application (i.e.\n   *                           the one which has your package.json).\n   *\n   * @param  {CompilerBase} fallbackCompiler (optional)  When a file is compiled\n   *                                         which doesn't have a matching compiler,\n   *                                         this compiler will be used instead. If\n   *                                         null, will fail compilation. A good\n   *                                         alternate fallback is the compiler for\n   *                                         'text/plain', which is guaranteed to be\n   *                                         present.\n   *\n   * @return {Promise<CompilerHost>}  A read-only CompilerHost\n   */\n  static createReadonlyFromConfiguration(rootCacheDir, appRoot) {\n    let fallbackCompiler = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n    return _asyncToGenerator(function* () {\n      let target = _path2.default.join(rootCacheDir, 'compiler-info.json.gz');\n      let buf = yield _promise.pfs.readFile(target);\n      let info = JSON.parse((yield _promise.pzlib.gunzip(buf)));\n\n      let fileChangeCache = _fileChangeCache2.default.loadFromData(info.fileChangeCache, appRoot, true);\n\n      let compilers = Object.keys(info.compilers).reduce(function (acc, x) {\n        let cur = info.compilers[x];\n        acc[x] = new _readOnlyCompiler2.default(cur.name, cur.compilerVersion, cur.compilerOptions, cur.inputMimeTypes);\n\n        return acc;\n      }, {});\n\n      return new CompilerHost(rootCacheDir, compilers, fileChangeCache, true, fallbackCompiler, null, info.mimeTypesToRegister);\n    })();\n  }\n\n  /**\n   * Creates a development-mode CompilerHost from the previously saved\n   * configuration.\n   *\n   * @param  {string} rootCacheDir  The root directory to use for the cache. This\n   *                                cache must have cache information saved via\n   *                                {@link saveConfiguration}\n   *\n   * @param  {string} appRoot  The top-level directory for your application (i.e.\n   *                           the one which has your package.json).\n   *\n   * @param  {Object} compilersByMimeType  an Object whose keys are input MIME\n   *                                       types and whose values are instances\n   *                                       of CompilerBase. Create this via the\n   *                                       {@link createCompilers} method in\n   *                                       config-parser.\n   *\n   * @param  {CompilerBase} fallbackCompiler (optional)  When a file is compiled\n   *                                         which doesn't have a matching compiler,\n   *                                         this compiler will be used instead. If\n   *                                         null, will fail compilation. A good\n   *                                         alternate fallback is the compiler for\n   *                                         'text/plain', which is guaranteed to be\n   *                                         present.\n   *\n   * @return {Promise<CompilerHost>}  A read-only CompilerHost\n   */\n  static createFromConfiguration(rootCacheDir, appRoot, compilersByMimeType) {\n    let fallbackCompiler = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n    return _asyncToGenerator(function* () {\n      let target = _path2.default.join(rootCacheDir, 'compiler-info.json.gz');\n      let buf = yield _promise.pfs.readFile(target);\n      let info = JSON.parse((yield _promise.pzlib.gunzip(buf)));\n\n      let fileChangeCache = _fileChangeCache2.default.loadFromData(info.fileChangeCache, appRoot, false);\n\n      Object.keys(info.compilers).forEach(function (x) {\n        let cur = info.compilers[x];\n        compilersByMimeType[x].compilerOptions = cur.compilerOptions;\n      });\n\n      return new CompilerHost(rootCacheDir, compilersByMimeType, fileChangeCache, false, fallbackCompiler, null, info.mimeTypesToRegister);\n    })();\n  }\n\n  /**\n   * Saves the current compiler configuration to a file that\n   * {@link createReadonlyFromConfiguration} can use to recreate the current\n   * compiler environment\n   *\n   * @return {Promise}  Completion\n   */\n  saveConfiguration() {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      let serializedCompilerOpts = Object.keys(_this.compilersByMimeType).reduce(function (acc, x) {\n        let compiler = _this.compilersByMimeType[x];\n        let Klass = Object.getPrototypeOf(compiler).constructor;\n\n        let val = {\n          name: Klass.name,\n          inputMimeTypes: Klass.getInputMimeTypes(),\n          compilerOptions: compiler.compilerOptions,\n          compilerVersion: compiler.getCompilerVersion()\n        };\n\n        acc[x] = val;\n        return acc;\n      }, {});\n\n      let info = {\n        fileChangeCache: _this.fileChangeCache.getSavedData(),\n        compilers: serializedCompilerOpts,\n        mimeTypesToRegister: _this.mimeTypesToRegister\n      };\n\n      let target = _path2.default.join(_this.rootCacheDir, 'compiler-info.json.gz');\n      let buf = yield _promise.pzlib.gzip(new Buffer(JSON.stringify(info)));\n      yield _promise.pfs.writeFile(target, buf);\n    })();\n  }\n\n  /**\n   * Compiles a file and returns the compiled result.\n   *\n   * @param  {string} filePath  The path to the file to compile\n   *\n   * @return {Promise<object>}  An Object with the compiled result\n   *\n   * @property {Object} hashInfo  The hash information returned from getHashForPath\n   * @property {string} code  The source code if the file was a text file\n   * @property {Buffer} binaryData  The file if it was a binary file\n   * @property {string} mimeType  The MIME type saved in the cache.\n   * @property {string[]} dependentFiles  The dependent files returned from\n   *                                      compiling the file, if any.\n   */\n  compile(filePath) {\n    var _this2 = this;\n\n    return _asyncToGenerator(function* () {\n      let ret = yield _this2.readOnlyMode ? _this2.compileReadOnly(filePath) : _this2.fullCompile(filePath);\n\n      if (ret.mimeType === 'application/javascript') {\n        _this2.mimeTypesToRegister[_mimeTypes2.default.lookup(filePath)] = true;\n      }\n\n      return ret;\n    })();\n  }\n\n  /**\n   * Handles compilation in read-only mode\n   *\n   * @private\n   */\n  compileReadOnly(filePath) {\n    var _this3 = this;\n\n    return _asyncToGenerator(function* () {\n      // We guarantee that node_modules are always shipped directly\n      let type = _mimeTypes2.default.lookup(filePath);\n      if (_fileChangeCache2.default.isInNodeModules(filePath)) {\n        return {\n          mimeType: type || 'application/javascript',\n          code: yield _promise.pfs.readFile(filePath, 'utf8')\n        };\n      }\n\n      let hashInfo = yield _this3.fileChangeCache.getHashForPath(filePath);\n\n      // NB: Here, we're basically only using the compiler here to find\n      // the appropriate CompileCache\n      let compiler = CompilerHost.shouldPassthrough(hashInfo) ? _this3.getPassthroughCompiler() : _this3.compilersByMimeType[type || '__lolnothere'];\n\n      // NB: We don't put this into shouldPassthrough because Inline HTML\n      // compiler is technically of type finalForms (i.e. a browser can\n      // natively handle this content), yet its compiler is\n      // InlineHtmlCompiler. However, we still want to catch standard CSS files\n      // which will be processed by PassthroughCompiler.\n      if (finalForms[type] && !compiler) {\n        compiler = _this3.getPassthroughCompiler();\n      }\n\n      if (!compiler) {\n        compiler = _this3.fallbackCompiler;\n\n        var _ref = yield compiler.get(filePath);\n\n        let code = _ref.code,\n            binaryData = _ref.binaryData,\n            mimeType = _ref.mimeType;\n\n        return { code: code || binaryData, mimeType };\n      }\n\n      let cache = _this3.cachesForCompilers.get(compiler);\n\n      var _ref2 = yield cache.get(filePath);\n\n      let code = _ref2.code,\n          binaryData = _ref2.binaryData,\n          mimeType = _ref2.mimeType;\n\n\n      code = code || binaryData;\n      if (!code || !mimeType) {\n        throw new Error(`Asked to compile ${filePath} in production, is this file not precompiled?`);\n      }\n\n      return { code, mimeType };\n    })();\n  }\n\n  /**\n   * Handles compilation in read-write mode\n   *\n   * @private\n   */\n  fullCompile(filePath) {\n    var _this4 = this;\n\n    return _asyncToGenerator(function* () {\n      d(`Compiling ${filePath}`);\n      let type = _mimeTypes2.default.lookup(filePath);\n\n      (0, _browserSignal.send)('electron-compile-compiled-file', { filePath, mimeType: type });\n\n      let hashInfo = yield _this4.fileChangeCache.getHashForPath(filePath);\n\n      if (hashInfo.isInNodeModules) {\n        let code = hashInfo.sourceCode || (yield _promise.pfs.readFile(filePath, 'utf8'));\n        code = yield CompilerHost.fixNodeModulesSourceMapping(code, filePath, _this4.fileChangeCache.appRoot);\n        return { code, mimeType: type };\n      }\n\n      let compiler = CompilerHost.shouldPassthrough(hashInfo) ? _this4.getPassthroughCompiler() : _this4.compilersByMimeType[type || '__lolnothere'];\n\n      if (!compiler) {\n        d(`Falling back to passthrough compiler for ${filePath}`);\n        compiler = _this4.fallbackCompiler;\n      }\n\n      if (!compiler) {\n        throw new Error(`Couldn't find a compiler for ${filePath}`);\n      }\n\n      let cache = _this4.cachesForCompilers.get(compiler);\n      return yield cache.getOrFetch(filePath, function (filePath, hashInfo) {\n        return _this4.compileUncached(filePath, hashInfo, compiler);\n      });\n    })();\n  }\n\n  /**\n   * Handles invoking compilers independent of caching\n   *\n   * @private\n   */\n  compileUncached(filePath, hashInfo, compiler) {\n    var _this5 = this;\n\n    return _asyncToGenerator(function* () {\n      let inputMimeType = _mimeTypes2.default.lookup(filePath);\n\n      if (hashInfo.isFileBinary) {\n        return {\n          binaryData: hashInfo.binaryData || (yield _promise.pfs.readFile(filePath)),\n          mimeType: inputMimeType,\n          dependentFiles: []\n        };\n      }\n\n      let ctx = {};\n      let code = hashInfo.sourceCode || (yield _promise.pfs.readFile(filePath, 'utf8'));\n\n      if (!(yield compiler.shouldCompileFile(code, ctx))) {\n        d(`Compiler returned false for shouldCompileFile: ${filePath}`);\n        return { code, mimeType: _mimeTypes2.default.lookup(filePath), dependentFiles: [] };\n      }\n\n      let dependentFiles = yield compiler.determineDependentFiles(code, filePath, ctx);\n\n      d(`Using compiler options: ${JSON.stringify(compiler.compilerOptions)}`);\n      let result = yield compiler.compile(code, filePath, ctx);\n\n      let shouldInlineHtmlify = inputMimeType !== 'text/html' && result.mimeType === 'text/html';\n\n      let isPassthrough = result.mimeType === 'text/plain' || !result.mimeType || CompilerHost.shouldPassthrough(hashInfo);\n\n      if (finalForms[result.mimeType] && !shouldInlineHtmlify || isPassthrough) {\n        // Got something we can use in-browser, let's return it\n        return Object.assign(result, { dependentFiles });\n      } else {\n        d(`Recursively compiling result of ${filePath} with non-final MIME type ${result.mimeType}, input was ${inputMimeType}`);\n\n        hashInfo = Object.assign({ sourceCode: result.code, mimeType: result.mimeType }, hashInfo);\n        compiler = _this5.compilersByMimeType[result.mimeType || '__lolnothere'];\n\n        if (!compiler) {\n          d(`Recursive compile failed - intermediate result: ${JSON.stringify(result)}`);\n\n          throw new Error(`Compiling ${filePath} resulted in a MIME type of ${result.mimeType}, which we don't know how to handle`);\n        }\n\n        return yield _this5.compileUncached(`${filePath}.${_mimeTypes2.default.extension(result.mimeType || 'txt')}`, hashInfo, compiler);\n      }\n    })();\n  }\n\n  /**\n   * Pre-caches an entire directory of files recursively. Usually used for\n   * building custom compiler tooling.\n   *\n   * @param  {string} rootDirectory  The top-level directory to compile\n   *\n   * @param  {Function} shouldCompile (optional)  A Function which allows the\n   *                                  caller to disable compiling certain files.\n   *                                  It takes a fully-qualified path to a file,\n   *                                  and should return a Boolean.\n   *\n   * @return {Promise}  Completion.\n   */\n  compileAll(rootDirectory) {\n    var _this6 = this;\n\n    let shouldCompile = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    return _asyncToGenerator(function* () {\n      let should = shouldCompile || function () {\n        return true;\n      };\n\n      yield (0, _forAllFiles.forAllFiles)(rootDirectory, function (f) {\n        if (!should(f)) return;\n\n        d(`Compiling ${f}`);\n        return _this6.compile(f, _this6.compilersByMimeType);\n      });\n    })();\n  }\n\n  listenToCompileEvents() {\n    return (0, _browserSignal.listen)('electron-compile-compiled-file').map((_ref3) => {\n      var _ref4 = _slicedToArray(_ref3, 1);\n\n      let x = _ref4[0];\n      return x;\n    });\n  }\n\n  /*\n   * Sync Methods\n   */\n\n  compileSync(filePath) {\n    let ret = this.readOnlyMode ? this.compileReadOnlySync(filePath) : this.fullCompileSync(filePath);\n\n    if (ret.mimeType === 'application/javascript') {\n      this.mimeTypesToRegister[_mimeTypes2.default.lookup(filePath)] = true;\n    }\n\n    return ret;\n  }\n\n  static createReadonlyFromConfigurationSync(rootCacheDir, appRoot) {\n    let fallbackCompiler = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n\n    let target = _path2.default.join(rootCacheDir, 'compiler-info.json.gz');\n    let buf = _fs2.default.readFileSync(target);\n    let info = JSON.parse(_zlib2.default.gunzipSync(buf));\n\n    let fileChangeCache = _fileChangeCache2.default.loadFromData(info.fileChangeCache, appRoot, true);\n\n    let compilers = Object.keys(info.compilers).reduce((acc, x) => {\n      let cur = info.compilers[x];\n      acc[x] = new _readOnlyCompiler2.default(cur.name, cur.compilerVersion, cur.compilerOptions, cur.inputMimeTypes);\n\n      return acc;\n    }, {});\n\n    return new CompilerHost(rootCacheDir, compilers, fileChangeCache, true, fallbackCompiler, null, info.mimeTypesToRegister);\n  }\n\n  static createFromConfigurationSync(rootCacheDir, appRoot, compilersByMimeType) {\n    let fallbackCompiler = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n\n    let target = _path2.default.join(rootCacheDir, 'compiler-info.json.gz');\n    let buf = _fs2.default.readFileSync(target);\n    let info = JSON.parse(_zlib2.default.gunzipSync(buf));\n\n    let fileChangeCache = _fileChangeCache2.default.loadFromData(info.fileChangeCache, appRoot, false);\n\n    Object.keys(info.compilers).forEach(x => {\n      let cur = info.compilers[x];\n      compilersByMimeType[x].compilerOptions = cur.compilerOptions;\n    });\n\n    return new CompilerHost(rootCacheDir, compilersByMimeType, fileChangeCache, false, fallbackCompiler, null, info.mimeTypesToRegister);\n  }\n\n  saveConfigurationSync() {\n    let serializedCompilerOpts = Object.keys(this.compilersByMimeType).reduce((acc, x) => {\n      let compiler = this.compilersByMimeType[x];\n      let Klass = Object.getPrototypeOf(compiler).constructor;\n\n      let val = {\n        name: Klass.name,\n        inputMimeTypes: Klass.getInputMimeTypes(),\n        compilerOptions: compiler.compilerOptions,\n        compilerVersion: compiler.getCompilerVersion()\n      };\n\n      acc[x] = val;\n      return acc;\n    }, {});\n\n    let info = {\n      fileChangeCache: this.fileChangeCache.getSavedData(),\n      compilers: serializedCompilerOpts,\n      mimeTypesToRegister: this.mimeTypesToRegister\n    };\n\n    let target = _path2.default.join(this.rootCacheDir, 'compiler-info.json.gz');\n    let buf = _zlib2.default.gzipSync(new Buffer(JSON.stringify(info)));\n    _fs2.default.writeFileSync(target, buf);\n  }\n\n  compileReadOnlySync(filePath) {\n    // We guarantee that node_modules are always shipped directly\n    let type = _mimeTypes2.default.lookup(filePath);\n    if (_fileChangeCache2.default.isInNodeModules(filePath)) {\n      return {\n        mimeType: type || 'application/javascript',\n        code: _fs2.default.readFileSync(filePath, 'utf8')\n      };\n    }\n\n    let hashInfo = this.fileChangeCache.getHashForPathSync(filePath);\n\n    // We guarantee that node_modules are always shipped directly\n    if (hashInfo.isInNodeModules) {\n      return {\n        mimeType: type,\n        code: hashInfo.sourceCode || _fs2.default.readFileSync(filePath, 'utf8')\n      };\n    }\n\n    // NB: Here, we're basically only using the compiler here to find\n    // the appropriate CompileCache\n    let compiler = CompilerHost.shouldPassthrough(hashInfo) ? this.getPassthroughCompiler() : this.compilersByMimeType[type || '__lolnothere'];\n\n    // NB: We don't put this into shouldPassthrough because Inline HTML\n    // compiler is technically of type finalForms (i.e. a browser can\n    // natively handle this content), yet its compiler is\n    // InlineHtmlCompiler. However, we still want to catch standard CSS files\n    // which will be processed by PassthroughCompiler.\n    if (finalForms[type] && !compiler) {\n      compiler = this.getPassthroughCompiler();\n    }\n\n    if (!compiler) {\n      compiler = this.fallbackCompiler;\n\n      var _compiler$getSync = compiler.getSync(filePath);\n\n      let code = _compiler$getSync.code,\n          binaryData = _compiler$getSync.binaryData,\n          mimeType = _compiler$getSync.mimeType;\n\n      return { code: code || binaryData, mimeType };\n    }\n\n    let cache = this.cachesForCompilers.get(compiler);\n\n    var _cache$getSync = cache.getSync(filePath);\n\n    let code = _cache$getSync.code,\n        binaryData = _cache$getSync.binaryData,\n        mimeType = _cache$getSync.mimeType;\n\n\n    code = code || binaryData;\n    if (!code || !mimeType) {\n      throw new Error(`Asked to compile ${filePath} in production, is this file not precompiled?`);\n    }\n\n    return { code, mimeType };\n  }\n\n  fullCompileSync(filePath) {\n    d(`Compiling ${filePath}`);\n\n    let type = _mimeTypes2.default.lookup(filePath);\n\n    (0, _browserSignal.send)('electron-compile-compiled-file', { filePath, mimeType: type });\n\n    let hashInfo = this.fileChangeCache.getHashForPathSync(filePath);\n\n    if (hashInfo.isInNodeModules) {\n      let code = hashInfo.sourceCode || _fs2.default.readFileSync(filePath, 'utf8');\n      code = CompilerHost.fixNodeModulesSourceMappingSync(code, filePath, this.fileChangeCache.appRoot);\n      return { code, mimeType: type };\n    }\n\n    let compiler = CompilerHost.shouldPassthrough(hashInfo) ? this.getPassthroughCompiler() : this.compilersByMimeType[type || '__lolnothere'];\n\n    if (!compiler) {\n      d(`Falling back to passthrough compiler for ${filePath}`);\n      compiler = this.fallbackCompiler;\n    }\n\n    if (!compiler) {\n      throw new Error(`Couldn't find a compiler for ${filePath}`);\n    }\n\n    let cache = this.cachesForCompilers.get(compiler);\n    return cache.getOrFetchSync(filePath, (filePath, hashInfo) => this.compileUncachedSync(filePath, hashInfo, compiler));\n  }\n\n  compileUncachedSync(filePath, hashInfo, compiler) {\n    let inputMimeType = _mimeTypes2.default.lookup(filePath);\n\n    if (hashInfo.isFileBinary) {\n      return {\n        binaryData: hashInfo.binaryData || _fs2.default.readFileSync(filePath),\n        mimeType: inputMimeType,\n        dependentFiles: []\n      };\n    }\n\n    let ctx = {};\n    let code = hashInfo.sourceCode || _fs2.default.readFileSync(filePath, 'utf8');\n\n    if (!compiler.shouldCompileFileSync(code, ctx)) {\n      d(`Compiler returned false for shouldCompileFile: ${filePath}`);\n      return { code, mimeType: _mimeTypes2.default.lookup(filePath), dependentFiles: [] };\n    }\n\n    let dependentFiles = compiler.determineDependentFilesSync(code, filePath, ctx);\n\n    let result = compiler.compileSync(code, filePath, ctx);\n\n    let shouldInlineHtmlify = inputMimeType !== 'text/html' && result.mimeType === 'text/html';\n\n    let isPassthrough = result.mimeType === 'text/plain' || !result.mimeType || CompilerHost.shouldPassthrough(hashInfo);\n\n    if (finalForms[result.mimeType] && !shouldInlineHtmlify || isPassthrough) {\n      // Got something we can use in-browser, let's return it\n      return Object.assign(result, { dependentFiles });\n    } else {\n      d(`Recursively compiling result of ${filePath} with non-final MIME type ${result.mimeType}, input was ${inputMimeType}`);\n\n      hashInfo = Object.assign({ sourceCode: result.code, mimeType: result.mimeType }, hashInfo);\n      compiler = this.compilersByMimeType[result.mimeType || '__lolnothere'];\n\n      if (!compiler) {\n        d(`Recursive compile failed - intermediate result: ${JSON.stringify(result)}`);\n\n        throw new Error(`Compiling ${filePath} resulted in a MIME type of ${result.mimeType}, which we don't know how to handle`);\n      }\n\n      return this.compileUncachedSync(`${filePath}.${_mimeTypes2.default.extension(result.mimeType || 'txt')}`, hashInfo, compiler);\n    }\n  }\n\n  compileAllSync(rootDirectory) {\n    let shouldCompile = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n\n    let should = shouldCompile || function () {\n      return true;\n    };\n\n    (0, _forAllFiles.forAllFilesSync)(rootDirectory, f => {\n      if (!should(f)) return;\n      return this.compileSync(f, this.compilersByMimeType);\n    });\n  }\n\n  /*\n   * Other stuff\n   */\n\n  /**\n   * Returns the passthrough compiler\n   *\n   * @private\n   */\n  getPassthroughCompiler() {\n    return this.compilersByMimeType['text/plain'];\n  }\n\n  /**\n   * Determines whether we should even try to compile the content. Note that in\n   * some cases, content will still be in cache even if this returns true, and\n   * in other cases (isInNodeModules), we'll know explicitly to not even bother\n   * looking in the cache.\n   *\n   * @private\n   */\n  static shouldPassthrough(hashInfo) {\n    return hashInfo.isMinified || hashInfo.isInNodeModules || hashInfo.hasSourceMap || hashInfo.isFileBinary;\n  }\n\n  /**\n   * Look at the code of a node modules and see the sourceMapping path.\n   * If there is any, check the path and try to fix it with and\n   * root relative path.\n   * @private\n   */\n  static fixNodeModulesSourceMapping(sourceCode, sourcePath, appRoot) {\n    return _asyncToGenerator(function* () {\n      let regexSourceMapping = /\\/\\/#.*sourceMappingURL=(?!data:)([^\"'].*)/i;\n      let sourceMappingCheck = sourceCode.match(regexSourceMapping);\n\n      if (sourceMappingCheck && sourceMappingCheck[1] && sourceMappingCheck[1] !== '') {\n        let sourceMapPath = sourceMappingCheck[1];\n\n        try {\n          yield _promise.pfs.stat(sourceMapPath);\n        } catch (error) {\n          let normRoot = _path2.default.normalize(appRoot);\n          let absPathToModule = _path2.default.dirname(sourcePath.replace(normRoot, '').substring(1));\n          let newMapPath = _path2.default.join(absPathToModule, sourceMapPath);\n\n          return sourceCode.replace(regexSourceMapping, `//# sourceMappingURL=${newMapPath}`);\n        }\n      }\n\n      return sourceCode;\n    })();\n  }\n\n  /**\n   * Look at the code of a node modules and see the sourceMapping path.\n   * If there is any, check the path and try to fix it with and\n   * root relative path.\n   * @private\n   */\n  static fixNodeModulesSourceMappingSync(sourceCode, sourcePath, appRoot) {\n    let regexSourceMapping = /\\/\\/#.*sourceMappingURL=(?!data:)([^\"'].*)/i;\n    let sourceMappingCheck = sourceCode.match(regexSourceMapping);\n\n    if (sourceMappingCheck && sourceMappingCheck[1] && sourceMappingCheck[1] !== '') {\n      let sourceMapPath = sourceMappingCheck[1];\n\n      try {\n        _fs2.default.statSync(sourceMapPath);\n      } catch (error) {\n        let normRoot = _path2.default.normalize(appRoot);\n        let absPathToModule = _path2.default.dirname(sourcePath.replace(normRoot, '').substring(1));\n        let newMapPath = _path2.default.join(absPathToModule, sourceMapPath);\n\n        return sourceCode.replace(regexSourceMapping, `//# sourceMappingURL=${newMapPath}`);\n      }\n    }\n\n    return sourceCode;\n  }\n}\nexports.default = CompilerHost;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9jb21waWxlci1ob3N0LmpzIl0sIm5hbWVzIjpbImQiLCJyZXF1aXJlIiwiaW5pdCIsImZpbmFsRm9ybXMiLCJDb21waWxlckhvc3QiLCJjb25zdHJ1Y3RvciIsInJvb3RDYWNoZURpciIsImNvbXBpbGVycyIsImZpbGVDaGFuZ2VDYWNoZSIsInJlYWRPbmx5TW9kZSIsImZhbGxiYWNrQ29tcGlsZXIiLCJzb3VyY2VNYXBQYXRoIiwibWltZVR5cGVzVG9SZWdpc3RlciIsImNvbXBpbGVyc0J5TWltZVR5cGUiLCJPYmplY3QiLCJhc3NpZ24iLCJhcHBSb290IiwiY2FjaGVzRm9yQ29tcGlsZXJzIiwia2V5cyIsInJlZHVjZSIsImFjYyIsIngiLCJjb21waWxlciIsImhhcyIsInNldCIsIkNvbXBpbGVDYWNoZSIsImNyZWF0ZUZyb21Db21waWxlciIsIk1hcCIsImNyZWF0ZVJlYWRvbmx5RnJvbUNvbmZpZ3VyYXRpb24iLCJ0YXJnZXQiLCJwYXRoIiwiam9pbiIsImJ1ZiIsInBmcyIsInJlYWRGaWxlIiwiaW5mbyIsIkpTT04iLCJwYXJzZSIsInB6bGliIiwiZ3VuemlwIiwiRmlsZUNoYW5nZWRDYWNoZSIsImxvYWRGcm9tRGF0YSIsImN1ciIsIlJlYWRPbmx5Q29tcGlsZXIiLCJuYW1lIiwiY29tcGlsZXJWZXJzaW9uIiwiY29tcGlsZXJPcHRpb25zIiwiaW5wdXRNaW1lVHlwZXMiLCJjcmVhdGVGcm9tQ29uZmlndXJhdGlvbiIsImZvckVhY2giLCJzYXZlQ29uZmlndXJhdGlvbiIsInNlcmlhbGl6ZWRDb21waWxlck9wdHMiLCJLbGFzcyIsImdldFByb3RvdHlwZU9mIiwidmFsIiwiZ2V0SW5wdXRNaW1lVHlwZXMiLCJnZXRDb21waWxlclZlcnNpb24iLCJnZXRTYXZlZERhdGEiLCJnemlwIiwiQnVmZmVyIiwic3RyaW5naWZ5Iiwid3JpdGVGaWxlIiwiY29tcGlsZSIsImZpbGVQYXRoIiwicmV0IiwiY29tcGlsZVJlYWRPbmx5IiwiZnVsbENvbXBpbGUiLCJtaW1lVHlwZSIsIm1pbWVUeXBlcyIsImxvb2t1cCIsInR5cGUiLCJpc0luTm9kZU1vZHVsZXMiLCJjb2RlIiwiaGFzaEluZm8iLCJnZXRIYXNoRm9yUGF0aCIsInNob3VsZFBhc3N0aHJvdWdoIiwiZ2V0UGFzc3Rocm91Z2hDb21waWxlciIsImdldCIsImJpbmFyeURhdGEiLCJjYWNoZSIsIkVycm9yIiwic291cmNlQ29kZSIsImZpeE5vZGVNb2R1bGVzU291cmNlTWFwcGluZyIsImdldE9yRmV0Y2giLCJjb21waWxlVW5jYWNoZWQiLCJpbnB1dE1pbWVUeXBlIiwiaXNGaWxlQmluYXJ5IiwiZGVwZW5kZW50RmlsZXMiLCJjdHgiLCJzaG91bGRDb21waWxlRmlsZSIsImRldGVybWluZURlcGVuZGVudEZpbGVzIiwicmVzdWx0Iiwic2hvdWxkSW5saW5lSHRtbGlmeSIsImlzUGFzc3Rocm91Z2giLCJleHRlbnNpb24iLCJjb21waWxlQWxsIiwicm9vdERpcmVjdG9yeSIsInNob3VsZENvbXBpbGUiLCJzaG91bGQiLCJmIiwibGlzdGVuVG9Db21waWxlRXZlbnRzIiwibWFwIiwiY29tcGlsZVN5bmMiLCJjb21waWxlUmVhZE9ubHlTeW5jIiwiZnVsbENvbXBpbGVTeW5jIiwiY3JlYXRlUmVhZG9ubHlGcm9tQ29uZmlndXJhdGlvblN5bmMiLCJmcyIsInJlYWRGaWxlU3luYyIsInpsaWIiLCJndW56aXBTeW5jIiwiY3JlYXRlRnJvbUNvbmZpZ3VyYXRpb25TeW5jIiwic2F2ZUNvbmZpZ3VyYXRpb25TeW5jIiwiZ3ppcFN5bmMiLCJ3cml0ZUZpbGVTeW5jIiwiZ2V0SGFzaEZvclBhdGhTeW5jIiwiZ2V0U3luYyIsImZpeE5vZGVNb2R1bGVzU291cmNlTWFwcGluZ1N5bmMiLCJnZXRPckZldGNoU3luYyIsImNvbXBpbGVVbmNhY2hlZFN5bmMiLCJzaG91bGRDb21waWxlRmlsZVN5bmMiLCJkZXRlcm1pbmVEZXBlbmRlbnRGaWxlc1N5bmMiLCJjb21waWxlQWxsU3luYyIsImlzTWluaWZpZWQiLCJoYXNTb3VyY2VNYXAiLCJzb3VyY2VQYXRoIiwicmVnZXhTb3VyY2VNYXBwaW5nIiwic291cmNlTWFwcGluZ0NoZWNrIiwibWF0Y2giLCJzdGF0IiwiZXJyb3IiLCJub3JtUm9vdCIsIm5vcm1hbGl6ZSIsImFic1BhdGhUb01vZHVsZSIsImRpcm5hbWUiLCJyZXBsYWNlIiwic3Vic3RyaW5nIiwibmV3TWFwUGF0aCIsInN0YXRTeW5jIl0sIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7O0FBRUE7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7O0FBSUE7Ozs7OztBQUZBLE1BQU1BLElBQUlDLFFBQVEsT0FBUixFQUFpQixnQ0FBakIsQ0FBVjs7QUFJQUEsUUFBUSxrQkFBUixFQUE0QkMsSUFBNUI7O0FBRUE7QUFDQSxNQUFNQyxhQUFhO0FBQ2pCLHFCQUFtQixJQURGO0FBRWpCLDRCQUEwQixJQUZUO0FBR2pCLGVBQWEsSUFISTtBQUlqQixjQUFZLElBSks7QUFLakIsbUJBQWlCLElBTEE7QUFNakIsc0JBQW9CO0FBTkgsQ0FBbkI7O0FBU0E7Ozs7Ozs7Ozs7Ozs7O0FBY2UsTUFBTUMsWUFBTixDQUFtQjtBQUNoQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBOEJBQyxjQUFZQyxZQUFaLEVBQTBCQyxTQUExQixFQUFxQ0MsZUFBckMsRUFBc0RDLFlBQXRELEVBQStJO0FBQUEsUUFBM0VDLGdCQUEyRSx1RUFBeEQsSUFBd0Q7QUFBQSxRQUFsREMsYUFBa0QsdUVBQWxDLElBQWtDO0FBQUEsUUFBNUJDLG1CQUE0Qix1RUFBTixJQUFNOztBQUM3SSxRQUFJQyxzQkFBc0JDLE9BQU9DLE1BQVAsQ0FBYyxFQUFkLEVBQWtCUixTQUFsQixDQUExQjtBQUNBTyxXQUFPQyxNQUFQLENBQWMsSUFBZCxFQUFvQixFQUFDVCxZQUFELEVBQWVPLG1CQUFmLEVBQW9DTCxlQUFwQyxFQUFxREMsWUFBckQsRUFBbUVDLGdCQUFuRSxFQUFwQjtB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Q0FBcEI7O0FBRUEsVUFBSTtBQUNGcEIscUJBQUcrQixRQUFILENBQVk5SCxhQUFaO0FBQ0QsT0FGRCxDQUVFLE9BQU9zSCxLQUFQLEVBQWM7QUFDZCxZQUFJQyxXQUFXcEcsZUFBS3FHLFNBQUwsQ0FBZW5ILE9BQWYsQ0FBZjtBQUNBLFlBQUlvSCxrQkFBa0J0RyxlQUFLdUcsT0FBTCxDQUFhVCxXQUFXVSxPQUFYLENBQW1CSixRQUFuQixFQUE2QixFQUE3QixFQUFpQ0ssU0FBakMsQ0FBMkMsQ0FBM0MsQ0FBYixDQUF0QjtBQUNBLFlBQUlDLGFBQWExRyxlQUFLQyxJQUFMLENBQVVxRyxlQUFWLEVBQTJCekgsYUFBM0IsQ0FBakI7O0FBRUEsZUFBT3NFLFdBQVdxRCxPQUFYLENBQW1CVCxrQkFBbkIsRUFBd0Msd0JBQXVCVyxVQUFXLEVBQTFFLENBQVA7QUFDRDtBQUNGOztBQUVELFdBQU92RCxVQUFQO0FBQ0Q7QUE1cEIrQjtrQkFBYjdFLFkiLCJmaWxlIjoiY29tcGlsZXItaG9zdC5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBtaW1lVHlwZXMgZnJvbSAnQHBhdWxjYmV0dHMvbWltZS10eXBlcyc7XG5pbXBvcnQgZnMgZnJvbSAnZnMnO1xuaW1wb3J0IHpsaWIgZnJvbSAnemxpYic7XG5pbXBvcnQgcGF0aCBmcm9tICdwYXRoJztcbmltcG9ydCB7cGZzLCBwemxpYn0gZnJvbSAnLi9wcm9taXNlJztcblxuaW1wb3J0IHtmb3JBbGxGaWxlcywgZm9yQWxsRmlsZXNTeW5jfSBmcm9tICcuL2Zvci1hbGwtZmlsZXMnO1xuaW1wb3J0IENvbXBpbGVDYWNoZSBmcm9tICcuL2NvbXBpbGUtY2FjaGUnO1xuaW1wb3J0IEZpbGVDaGFuZ2VkQ2FjaGUgZnJvbSAnLi9maWxlLWNoYW5nZS1jYWNoZSc7XG5pbXBvcnQgUmVhZE9ubHlDb21waWxlciBmcm9tICcuL3JlYWQtb25seS1jb21waWxlcic7XG5pbXBvcnQge2xpc3Rlbiwgc2VuZH0gZnJvbSAnLi9icm93c2VyLXNpZ25hbCc7XG5cbmNvbnN0IGQgPSByZXF1aXJlKCdkZWJ1ZycpKCdlbGVjdHJvbi1jb21waWxlOmNvbXBpbGVyLWhvc3QnKTtcblxuaW1wb3J0ICdyeGpzL2FkZC9vcGVyYXRvci9tYXAnO1xuXG5yZXF1aXJlKCcuL3JpZy1taW1lLXR5cGVzJykuaW5pdCgpO1xuXG4vLyBUaGlzIGlzbid0IGV2ZW4gbXlcbmNvbnN0IGZpbmFsRm9ybXMgPSB7XG4gICd0ZXh0L2phdmFzY3JpcHQnOiB0cnVlLFxuICAnYXBwbGljYXRpb24vamF2YXNjcmlwdCc6IHRydWUsXG4gICd0ZXh0L2h0bWwnOiB0cnVlLFxuICAndGV4dC9jc3MnOiB0cnVlLFxuICAnaW1hZ2Uvc3ZnK3htbCc6IHRydWUsXG4gICdhcHBsaWNhdGlvbi9qc29uJzogdHJ1ZVxufTtcblxuLyoqXG4gKiBUaGlzIGNsYXNzIGlzIHRoZSB0b3AtbGV2ZWwgY2xhc3MgdGhhdCBlbmNhcHN1bGF0ZXMgYWxsIG9mIHRoZSBsb2dpYyBvZlxuICogY29tcGlsaW5nIGFuZCBjYWNoaW5nIGFwcGxpY2F0aW9uIGNvZGUuIElmIHlvdSdyZSBsb29raW5nIGZvciBhIFwiTWFpbiBjbGFzc1wiLFxuICogdGhpcyBpcyBpdC5cbiAqXG4gKiBUaGlzIGNsYXNzIGNhbiBiZSBjcmVhdGVkIGRpcmVjdGx5IGJ1dCBpdCBpcyB1c3VhbGx5IGNyZWF0ZWQgdmlhIHRoZSBtZXRob2RzXG4gKiBpbiBjb25maWctcGFyc2VyLCB3aGljaCB3aWxsIGFtb25nIG90aGVyIHRoaW5ncywgc2V0IHVwIHRoZSBjb21waWxlciBvcHRpb25zXG4gKiBnaXZlbiBhIHByb2plY3Qgcm9vdC5cbiAqXG4gKiBDb21waWxlckhvc3QgaXMgYWxzbyB0aGUgdG9wLWxldmVsIGNsYXNzIHRoYXQga25vd3MgaG93IHRvIHNlcmlhbGl6ZSBhbGwgb2YgdGhlXG4gKiBpbmZvcm1hdGlvbiBuZWNlc3NhcnkgdG8gcmVjcmVhdGUgaXRzZWxmLCBlaXRoZXIgYXMgYSBkZXZlbG9wbWVudCBob3N0IChpLmUuXG4gKiB3aWxsIGFsbG93IGNhY2hlIG1pc3NlcyBhbmQgYWN0dWFsIGNvbXBpbGF0aW9uKSwgb3IgYXMgYSByZWFkLW9ubHkgdmVyc2lvbiBvZlxuICogaXRzZWxmIGZvciBwcm9kdWN0aW9uLlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDb21waWxlckhvc3Qge1xuICAvKipcbiAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiBDb21waWxlckhvc3QuIFlvdSBwcm9iYWJseSB3YW50IHRvIHVzZSB0aGUgbWV0aG9kc1xuICAgKiBpbiBjb25maWctcGFyc2VyIGZvciBkZXZlbG9wbWVudCwgb3Ige0BsaW5rIGNyZWF0ZVJlYWRvbmx5RnJvbUNvbmZpZ3VyYXRpb259XG4gICAqIGZvciBwcm9kdWN0aW9uIGluc3RlYWQuXG4gICAqXG4gICAqIEBwYXJhbSAge3N0cmluZ30gcm9vdENhY2hlRGlyICBUaGUgcm9vdCBkaXJlY3RvcnkgdG8gdXNlIGZvciB0aGUgY2FjaGVcbiAgICpcbiAgICogQHBhcmFtICB7T2JqZWN0fSBjb21waWxlcnMgIGFuIE9iamVjdCB3aG9zZSBrZXlzIGFyZSBpbnB1dCBNSU1FIHR5cGVzIGFuZFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2hvc2UgdmFsdWVzIGFyZSBpbnN0YW5jZXMgb2YgQ29tcGlsZXJCYXNlLiBDcmVhdGVcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMgdmlhIHRoZSB7QGxpbmsgY3JlYXRlQ29tcGlsZXJzfSBtZXRob2QgaW5cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpZy1wYXJzZXIuXG4gICAqXG4gICAqIEBwYXJhbSAge0ZpbGVDaGFuZ2VkQ2FjaGV9IGZpbGVDaGFuZ2VDYWNoZSAgQSBmaWxlLWNoYW5nZSBjYWNoZSB0aGF0IGlzXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9uYWxseSBwcmUtbG9hZGVkLlxuICAgKlxuICAgKiBAcGFyYW0gIHtib29sZWFufSByZWFkT25seU1vZGUgIElmIFRydWUsIGNhY2hlIG1pc3NlcyB3aWxsIGZhaWwgYW5kXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29tcGlsYXRpb24gd2lsbCBub3QgYmUgYXR0ZW1wdGVkLlxuICAgKlxuICAgKiBAcGFyYW0gIHtDb21waWxlckJhc2V9IGZhbGxiYWNrQ29tcGlsZXIgKG9wdGlvbmFsKSAgV2hlbiBhIGZpbGUgaXMgY29tcGlsZWRcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoaWNoIGRvZXNuJ3QgaGF2ZSBhIG1hdGNoaW5nIGNvbXBpbGVyLFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcyBjb21waWxlciB3aWxsIGJlIHVzZWQgaW5zdGVhZC4gSWZcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG51bGwsIHdpbGwgZmFpbCBjb21waWxhdGlvbi4gQSBnb29kXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbHRlcm5hdGUgZmFsbGJhY2sgaXMgdGhlIGNvbXBpbGVyIGZvclxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3RleHQvcGxhaW4nLCB3aGljaCBpcyBndWFyYW50ZWVkIHRvIGJlXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmVzZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gc291cmNlTWFwUGF0aCAob3B0aW9uYWwpIFRoZSBkaXJlY3RvcnkgdG8gc3RvcmUgc291cmNlbWFwIHNlcGFyYXRlbHlcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgY29tcGlsZXIgb3B0aW9uIGVuYWJsZWQgdG8gZW1pdC5cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgRGVmYXVsdCB0byBjYWNoZVBhdGggaWYgbm90IHNwZWNpZmllZC5cbiAgICovXG4gIGNvbnN0cnVjdG9yKHJvb3RDYWNoZURpciwgY29tcGlsZXJzLCBmaWxlQ2hhbmdlQ2FjaGUsIHJlYWRPbmx5TW9kZSwgZmFsbGJhY2tDb21waWxlciA9IG51bGwsIHNvdXJjZU1hcFBhdGggPSBudWxsLCBtaW1lVHlwZXNUb1JlZ2lzdGVyID0gbnVsbCkge1xuICAgIGxldCBjb21waWxlcnNCeU1pbWVUeXBlID0gT2JqZWN0LmFzc2lnbih7fSwgY29tcGlsZXJzKTtcbiAgICBPYmplY3QuYXNzaWduKHRoaXMsIHtyb290Q2FjaGVEaXIsIGNvbXBpbGVyc0J5TWltZVR5cGUsIGZpbGVDaGFuZ2VDYWNoZSwgcmVhZE9ubHlNb2RlLCBmYWxsYmFja0NvbXBpbGVyfSk7XG4gICAgdGhpcy5hcHBSb290ID0gdGhpcy5maWxlQ2hhbmdlQ2FjaGUuYXBwUm9vdDtcblxuICAgIHRoaXMuY2FjaGVzRm9yQ29tcGlsZXJzID0gT2JqZWN0LmtleXMoY29tcGlsZXJzQnlNaW1lVHlwZSkucmVkdWNlKChhY2MsIHgpID0+IHtcbiAgICAgIGxldCBjb21waWxlciA9IGNvbXBpbGVyc0J5TWltZVR5cGVbeF07XG4gICAgICBpZiAoYWNjLmhhcyhjb21waWxlcikpIHJldHVybiBhY2M7XG5cbiAgICAgIGFjYy5zZXQoXG4gICAgICAgIGNvbXBpbGVyLFxuICAgICAgICBDb21waWxlQ2FjaGUuY3JlYXRlRnJvbUNvbXBpbGVyKHJvb3RDYWNoZURpciwgY29tcGlsZXIsIGZpbGVDaGFuZ2VDYWNoZSwgcmVhZE9ubHlNb2RlLCBzb3VyY2VNYXBQYXRoKSk7XG4gICAgICByZXR1cm4gYWNjO1xuICAgIH0sIG5ldyBNYXAoKSk7XG5cbiAgICB0aGlzLm1pbWVUeXBlc1RvUmVnaXN0ZXIgPSBtaW1lVHlwZXNUb1JlZ2lzdGVyIHx8IHt9O1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBwcm9kdWN0aW9uLW1vZGUgQ29tcGlsZXJIb3N0IGZyb20gdGhlIHByZXZpb3VzbHkgc2F2ZWRcbiAgICogY29uZmlndXJhdGlvblxuICAgKlxuICAgKiBAcGFyYW0gIHtzdHJpbmd9IHJvb3RDYWNoZURpciAgVGhlIHJvb3QgZGlyZWN0b3J5IHRvIHVzZSBmb3IgdGhlIGNhY2hlLiBUaGlzXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWNoZSBtdXN0IGhhdmUgY2FjaGUgaW5mb3JtYXRpb24gc2F2ZWQgdmlhXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7QGxpbmsgc2F2ZUNvbmZpZ3VyYXRpb259XG4gICAqXG4gICAqIEBwYXJhbSAge3N0cmluZ30gYXBwUm9vdCAgVGhlIHRvcC1sZXZlbCBkaXJlY3RvcnkgZm9yIHlvdXIgYXBwbGljYXRpb24gKGkuZS5cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICB0aGUgb25lIHdoaWNoIGhhcyB5b3VyIHBhY2thZ2UuanNvbikuXG4gICAqXG4gICAqIEBwYXJhbSAge0NvbXBpbGVyQmFzZX0gZmFsbGJhY2tDb21waWxlciAob3B0aW9uYWwpICBXaGVuIGEgZmlsZSBpcyBjb21waWxlZFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2hpY2ggZG9lc24ndCBoYXZlIGEgbWF0Y2hpbmcgY29tcGlsZXIsXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzIGNvbXBpbGVyIHdpbGwgYmUgdXNlZCBpbnN0ZWFkLiBJZlxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbnVsbCwgd2lsbCBmYWlsIGNvbXBpbGF0aW9uLiBBIGdvb2RcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFsdGVybmF0ZSBmYWxsYmFjayBpcyB0aGUgY29tcGlsZXIgZm9yXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAndGV4dC9wbGFpbicsIHdoaWNoIGlzIGd1YXJhbnRlZWQgdG8gYmVcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByZXNlbnQuXG4gICAqXG4gICAqIEByZXR1cm4ge1Byb21pc2U8Q29tcGlsZXJIb3N0Pn0gIEEgcmVhZC1vbmx5IENvbXBpbGVySG9zdFxuICAgKi9cbiAgc3RhdGljIGFzeW5jIGNyZWF0ZVJlYWRvbmx5RnJvbUNvbmZpZ3VyYXRpb24ocm9vdENhY2hlRGlyLCBhcHBSb290LCBmYWxsYmFja0NvbXBpbGVyPW51bGwpIHtcbiAgICBsZXQgdGFyZ2V0ID0gcGF0aC5qb2luKHJvb3RDYWNoZURpciwgJ2NvbXBpbGVyLWluZm8uanNvbi5neicpO1xuICAgIGxldCBidWYgPSBhd2FpdCBwZnMucmVhZEZpbGUodGFyZ2V0KTtcbiAgICBsZXQgaW5mbyA9IEpTT04ucGFyc2UoYXdhaXQgcHpsaWIuZ3VuemlwKGJ1ZikpO1xuXG4gICAgbGV0IGZpbGVDaGFuZ2VDYWNoZSA9IEZpbGVDaGFuZ2VkQ2FjaGUubG9hZEZyb21EYXRhKGluZm8uZmlsZUNoYW5nZUNhY2hlLCBhcHBSb290LCB0cnVlKTtcblxuICAgIGxldCBjb21waWxlcnMgPSBPYmplY3Qua2V5cyhpbmZvLmNvbXBpbGVycykucmVkdWNlKChhY2MsIHgpID0+IHtcbiAgICAgIGxldCBjdXIgPSBpbmZvLmNvbXBpbGVyc1t4XTtcbiAgICAgIGFjY1t4XSA9IG5ldyBSZWFkT25seUNvbXBpbGVyKGN1ci5uYW1lLCBjdXIuY29tcGlsZXJWZXJzaW9uLCBjdXIuY29tcGlsZXJPcHRpb25zLCBjdXIuaW5wdXRNaW1lVHlwZXMpO1xuXG4gICAgICByZXR1cm4gYWNjO1xuICAgIH0sIHt9KTtcblxuICAgIHJldHVybiBuZXcgQ29tcGlsZXJIb3N0KHJvb3RDYWNoZURpciwgY29tcGlsZXJzLCBmaWxlQ2hhbmdlQ2FjaGUsIHRydWUsIGZhbGxiYWNrQ29tcGlsZXIsIG51bGwsIGluZm8ubWltZVR5cGVzVG9SZWdpc3Rlcik7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIGRldmVsb3BtZW50LW1vZGUgQ29tcGlsZXJIb3N0IGZyb20gdGhlIHByZXZpb3VzbHkgc2F2ZWRcbiAgICogY29uZmlndXJhdGlvbi5cbiAgICpcbiAgICogQHBhcmFtICB7c3RyaW5nfSByb290Q2FjaGVEaXIgIFRoZSByb290IGRpcmVjdG9yeSB0byB1c2UgZm9yIHRoZSBjYWNoZS4gVGhpc1xuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FjaGUgbXVzdCBoYXZlIGNhY2hlIGluZm9ybWF0aW9uIHNhdmVkIHZpYVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge0BsaW5rIHNhdmVDb25maWd1cmF0aW9ufVxuICAgKlxuICAgKiBAcGFyYW0gIHtzdHJpbmd9IGFwcFJvb3QgIFRoZSB0b3AtbGV2ZWwgZGlyZWN0b3J5IGZvciB5b3VyIGFwcGxpY2F0aW9uIChpLmUuXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhlIG9uZSB3aGljaCBoYXMgeW91ciBwYWNrYWdlLmpzb24pLlxuICAgKlxuICAgKiBAcGFyYW0gIHtPYmplY3R9IGNvbXBpbGVyc0J5TWltZVR5cGUgIGFuIE9iamVjdCB3aG9zZSBrZXlzIGFyZSBpbnB1dCBNSU1FXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZXMgYW5kIHdob3NlIHZhbHVlcyBhcmUgaW5zdGFuY2VzXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2YgQ29tcGlsZXJCYXNlLiBDcmVhdGUgdGhpcyB2aWEgdGhlXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge0BsaW5rIGNyZWF0ZUNvbXBpbGVyc30gbWV0aG9kIGluXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlnLXBhcnNlci5cbiAgICpcbiAgICogQHBhcmFtICB7Q29tcGlsZXJCYXNlfSBmYWxsYmFja0NvbXBpbGVyIChvcHRpb25hbCkgIFdoZW4gYSBmaWxlIGlzIGNvbXBpbGVkXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aGljaCBkb2Vzbid0IGhhdmUgYSBtYXRjaGluZyBjb21waWxlcixcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMgY29tcGlsZXIgd2lsbCBiZSB1c2VkIGluc3RlYWQuIElmXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBudWxsLCB3aWxsIGZhaWwgY29tcGlsYXRpb24uIEEgZ29vZFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWx0ZXJuYXRlIGZhbGxiYWNrIGlzIHRoZSBjb21waWxlciBmb3JcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICd0ZXh0L3BsYWluJywgd2hpY2ggaXMgZ3VhcmFudGVlZCB0byBiZVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJlc2VudC5cbiAgICpcbiAgICogQHJldHVybiB7UHJvbWlzZTxDb21waWxlckhvc3Q+fSAgQSByZWFkLW9ubHkgQ29tcGlsZXJIb3N0XG4gICAqL1xuICBzdGF0aWMgYXN5bmMgY3JlYXRlRnJvbUNvbmZpZ3VyYXRpb24ocm9vdENhY2hlRGlyLCBhcHBSb290LCBjb21waWxlcnNCeU1pbWVUeXBlLCBmYWxsYmFja0NvbXBpbGVyPW51bGwpIHtcbiAgICBsZXQgdGFyZ2V0ID0gcGF0aC5qb2luKHJvb3RDYWNoZURpciwgJ2NvbXBpbGVyLWluZm8uanNvbi5neicpO1xuICAgIGxldCBidWYgPSBhd2FpdCBwZnMucmVhZEZpbGUodGFyZ2V0KTtcbiAgICBsZXQgaW5mbyA9IEpTT04ucGFyc2UoYXdhaXQgcHpsaWIuZ3VuemlwKGJ1ZikpO1xuXG4gICAgbGV0IGZpbGVDaGFuZ2VDYWNoZSA9IEZpbGVDaGFuZ2VkQ2FjaGUubG9hZEZyb21EYXRhKGluZm8uZmlsZUNoYW5nZUNhY2hlLCBhcHBSb290LCBmYWxzZSk7XG5cbiAgICBPYmplY3Qua2V5cyhpbmZvLmNvbXBpbGVycykuZm9yRWFjaCgoeCkgPT4ge1xuICAgICAgbGV0IGN1ciA9IGluZm8uY29tcGlsZXJzW3hdO1xuICAgICAgY29tcGlsZXJzQnlNaW1lVHlwZVt4XS5jb21waWxlck9wdGlvbnMgPSBjdXIuY29tcGlsZXJPcHRpb25zO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIG5ldyBDb21waWxlckhvc3Qocm9vdENhY2hlRGlyLCBjb21waWxlcnNCeU1pbWVUeXBlLCBmaWxlQ2hhbmdlQ2FjaGUsIGZhbHNlLCBmYWxsYmFja0NvbXBpbGVyLCBudWxsLCBpbmZvLm1pbWVUeXBlc1RvUmVnaXN0ZXIpO1xuICB9XG5cblxuICAvKipcbiAgICogU2F2ZXMgdGhlIGN1cnJlbnQgY29tcGlsZXIgY29uZmlndXJhdGlvbiB0byBhIGZpbGUgdGhhdFxuICAgKiB7QGxpbmsgY3JlYXRlUmVhZG9ubHlGcm9tQ29uZmlndXJhdGlvbn0gY2FuIHVzZSB0byByZWNyZWF0ZSB0aGUgY3VycmVudFxuICAgKiBjb21waWxlciBlbnZpcm9ubWVudFxuICAgKlxuICAgKiBAcmV0dXJuIHtQcm9taXNlfSAgQ29tcGxldGlvblxuICAgKi9cbiAgYXN5bmMgc2F2ZUNvbmZpZ3VyYXRpb24oKSB7XG4gICAgbGV0IHNlcmlhbGl6ZWRDb21waWxlck9wdHMgPSBPYmplY3Qua2V5cyh0aGlzLmNvbXBpbGVyc0J5TWltZVR5cGUpLnJlZHVjZSgoYWNjLCB4KSA9PiB7XG4gICAgICBsZXQgY29tcGlsZXIgPSB0aGlzLmNvbXBpbGVyc0J5TWltZVR5cGVbeF07XG4gICAgICBsZXQgS2xhc3MgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YoY29tcGlsZXIpLmNvbnN0cnVjdG9yO1xuXG4gICAgICBsZXQgdmFsID0ge1xuICAgICAgICBuYW1lOiBLbGFzcy5uYW1lLFxuICAgICAgICBpbnB1dE1pbWVUeXBlczogS2xhc3MuZ2V0SW5wdXRNaW1lVHlwZXMoKSxcbiAgICAgICAgY29tcGlsZXJPcHRpb25zOiBjb21waWxlci5jb21waWxlck9wdGlvbnMsXG4gICAgICAgIGNvbXBpbGVyVmVyc2lvbjogY29tcGlsZXIuZ2V0Q29tcGlsZXJWZXJzaW9uKClcbiAgICAgIH07XG5cbiAgICAgIGFjY1t4XSA9IHZhbDtcbiAgICAgIHJldHVybiBhY2M7XG4gICAgfSwge30pO1xuXG4gICAgbGV0IGluZm8gPSB7XG4gICAgICBmaWxlQ2hhbmdlQ2FjaGU6IHRoaXMuZmlsZUNoYW5nZUNhY2hlLmdldFNhdmVkRGF0YSgpLFxuICAgICAgY29tcGlsZXJzOiBzZXJpYWxpemVkQ29tcGlsZXJPcHRzLFxuICAgICAgbWltZVR5cGVzVG9SZWdpc3RlcjogdGhpcy5taW1lVHlwZXNUb1JlZ2lzdGVyXG4gICAgfTtcblxuICAgIGxldCB0YXJnZXQgPSBwYXRoLmpvaW4odGhpcy5yb290Q2FjaGVEaXIsICdjb21waWxlci1pbmZvLmpzb24uZ3onKTtcbiAgICBsZXQgYnVmID0gYXdhaXQgcHpsaWIuZ3ppcChuZXcgQnVmZmVyKEpTT04uc3RyaW5naWZ5KGluZm8pKSk7XG4gICAgYXdhaXQgcGZzLndyaXRlRmlsZSh0YXJnZXQsIGJ1Zik7XG4gIH1cblxuICAvKipcbiAgICogQ29tcGlsZXMgYSBmaWxlIGFuZCByZXR1cm5zIHRoZSBjb21waWxlZCByZXN1bHQuXG4gICAqXG4gICAqIEBwYXJhbSAge3N0cmluZ30gZmlsZVBhdGggIFRoZSBwYXRoIHRvIHRoZSBmaWxlIHRvIGNvbXBpbGVcbiAgICpcbiAgICogQHJldHVybiB7UHJvbWlzZTxvYmplY3Q+fSAgQW4gT2JqZWN0IHdpdGggdGhlIGNvbXBpbGVkIHJlc3VsdFxuICAgKlxuICAgKiBAcHJvcGVydHkge09iamVjdH0gaGFzaEluZm8gIFRoZSBoYXNoIGluZm9ybWF0aW9uIHJldHVybmVkIGZyb20gZ2V0SGFzaEZvclBhdGhcbiAgICogQHByb3BlcnR5IHtzdHJpbmd9IGNvZGUgIFRoZSBzb3VyY2UgY29kZSBpZiB0aGUgZmlsZSB3YXMgYSB0ZXh0IGZpbGVcbiAgICogQHByb3BlcnR5IHtCdWZmZXJ9IGJpbmFyeURhdGEgIFRoZSBmaWxlIGlmIGl0IHdhcyBhIGJpbmFyeSBmaWxlXG4gICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBtaW1lVHlwZSAgVGhlIE1JTUUgdHlwZSBzYXZlZCBpbiB0aGUgY2FjaGUuXG4gICAqIEBwcm9wZXJ0eSB7c3RyaW5nW119IGRlcGVuZGVudEZpbGVzICBUaGUgZGVwZW5kZW50IGZpbGVzIHJldHVybmVkIGZyb21cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBpbGluZyB0aGUgZmlsZSwgaWYgYW55LlxuICAgKi9cbiAgYXN5bmMgY29tcGlsZShmaWxlUGF0aCkge1xuICAgIGxldCByZXQgPSBhd2FpdCAodGhpcy5yZWFkT25seU1vZGUgPyB0aGlzLmNvbXBpbGVSZWFkT25seShmaWxlUGF0aCkgOiB0aGlzLmZ1bGxDb21waWxlKGZpbGVQYXRoKSk7XG5cbiAgICBpZiAocmV0Lm1pbWVUeXBlID09PSAnYXBwbGljYXRpb24vamF2YXNjcmlwdCcpIHtcbiAgICAgIHRoaXMubWltZVR5cGVzVG9SZWdpc3RlclttaW1lVHlwZXMubG9va3VwKGZpbGVQYXRoKV0gPSB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiByZXQ7XG4gIH1cblxuXG4gIC8qKlxuICAgKiBIYW5kbGVzIGNvbXBpbGF0aW9uIGluIHJlYWQtb25seSBtb2RlXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBhc3luYyBjb21waWxlUmVhZE9ubHkoZmlsZVBhdGgpIHtcbiAgICAvLyBXZSBndWFyYW50ZWUgdGhhdCBub2RlX21vZHVsZXMgYXJlIGFsd2F5cyBzaGlwcGVkIGRpcmVjdGx5XG4gICAgbGV0IHR5cGUgPSBtaW1lVHlwZXMubG9va3VwKGZpbGVQYXRoKTtcbiAgICBpZiAoRmlsZUNoYW5nZWRDYWNoZS5pc0luTm9kZU1vZHVsZXMoZmlsZVBhdGgpKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBtaW1lVHlwZTogdHlwZSB8fCAnYXBwbGljYXRpb24vamF2YXNjcmlwdCcsXG4gICAgICAgIGNvZGU6IGF3YWl0IHBmcy5yZWFkRmlsZShmaWxlUGF0aCwgJ3V0ZjgnKVxuICAgICAgfTtcbiAgICB9XG5cbiAgICBsZXQgaGFzaEluZm8gPSBhd2FpdCB0aGlzLmZpbGVDaGFuZ2VDYWNoZS5nZXRIYXNoRm9yUGF0aChmaWxlUGF0aCk7XG5cbiAgICAvLyBOQjogSGVyZSwgd2UncmUgYmFzaWNhbGx5IG9ubHkgdXNpbmcgdGhlIGNvbXBpbGVyIGhlcmUgdG8gZmluZFxuICAgIC8vIHRoZSBhcHByb3ByaWF0ZSBDb21waWxlQ2FjaGVcbiAgICBsZXQgY29tcGlsZXIgPSBDb21waWxlckhvc3Quc2hvdWxkUGFzc3Rocm91Z2goaGFzaEluZm8pID9cbiAgICAgIHRoaXMuZ2V0UGFzc3Rocm91Z2hDb21waWxlcigpIDpcbiAgICAgIHRoaXMuY29tcGlsZXJzQnlNaW1lVHlwZVt0eXBlIHx8ICdfX2xvbG5vdGhlcmUnXTtcblxuXG4gICAgLy8gTkI6IFdlIGRvbid0IHB1dCB0aGlzIGludG8gc2hvdWxkUGFzc3Rocm91Z2ggYmVjYXVzZSBJbmxpbmUgSFRNTFxuICAgIC8vIGNvbXBpbGVyIGlzIHRlY2huaWNhbGx5IG9mIHR5cGUgZmluYWxGb3JtcyAoaS5lLiBhIGJyb3dzZXIgY2FuXG4gICAgLy8gbmF0aXZlbHkgaGFuZGxlIHRoaXMgY29udGVudCksIHlldCBpdHMgY29tcGlsZXIgaXNcbiAgICAvLyBJbmxpbmVIdG1sQ29tcGlsZXIuIEhvd2V2ZXIsIHdlIHN0aWxsIHdhbnQgdG8gY2F0Y2ggc3RhbmRhcmQgQ1NTIGZpbGVzXG4gICAgLy8gd2hpY2ggd2lsbCBiZSBwcm9jZXNzZWQgYnkgUGFzc3Rocm91Z2hDb21waWxlci5cbiAgICBpZiAoZmluYWxGb3Jtc1t0eXBlXSAmJiAhY29tcGlsZXIpIHtcbiAgICAgIGNvbXBpbGVyID0gdGhpcy5nZXRQYXNzdGhyb3VnaENvbXBpbGVyKCk7XG4gICAgfVxuXG4gICAgaWYgKCFjb21waWxlcikge1xuICAgICAgY29tcGlsZXIgPSB0aGlzLmZhbGxiYWNrQ29tcGlsZXI7XG5cbiAgICAgIGxldCB7IGNvZGUsIGJpbmFyeURhdGEsIG1pbWVUeXBlIH0gPSBhd2FpdCBjb21waWxlci5nZXQoZmlsZVBhdGgpO1xuICAgICAgcmV0dXJuIHsgY29kZTogY29kZSB8fCBiaW5hcnlEYXRhLCBtaW1lVHlwZSB9O1xuICAgIH1cblxuICAgIGxldCBjYWNoZSA9IHRoaXMuY2FjaGVzRm9yQ29tcGlsZXJzLmdldChjb21waWxlcik7XG4gICAgbGV0IHtjb2RlLCBiaW5hcnlEYXRhLCBtaW1lVHlwZX0gPSBhd2FpdCBjYWNoZS5nZXQoZmlsZVBhdGgpO1xuXG4gICAgY29kZSA9IGNvZGUgfHwgYmluYXJ5RGF0YTtcbiAgICBpZiAoIWNvZGUgfHwgIW1pbWVUeXBlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEFza2VkIHRvIGNvbXBpbGUgJHtmaWxlUGF0aH0gaW4gcHJvZHVjdGlvbiwgaXMgdGhpcyBmaWxlIG5vdCBwcmVjb21waWxlZD9gKTtcbiAgICB9XG5cbiAgICByZXR1cm4geyBjb2RlLCBtaW1lVHlwZSB9O1xuICB9XG5cbiAgLyoqXG4gICAqIEhhbmRsZXMgY29tcGlsYXRpb24gaW4gcmVhZC13cml0ZSBtb2RlXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBhc3luYyBmdWxsQ29tcGlsZShmaWxlUGF0aCkge1xuICAgIGQoYENvbXBpbGluZyAke2ZpbGVQYXRofWApO1xuICAgIGxldCB0eXBlID0gbWltZVR5cGVzLmxvb2t1cChmaWxlUGF0aCk7XG5cbiAgICBzZW5kKCdlbGVjdHJvbi1jb21waWxlLWNvbXBpbGVkLWZpbGUnLCB7IGZpbGVQYXRoLCBtaW1lVHlwZTogdHlwZSB9KTtcblxuICAgIGxldCBoYXNoSW5mbyA9IGF3YWl0IHRoaXMuZmlsZUNoYW5nZUNhY2hlLmdldEhhc2hGb3JQYXRoKGZpbGVQYXRoKTtcblxuICAgIGlmIChoYXNoSW5mby5pc0luTm9kZU1vZHVsZXMpIHtcbiAgICAgIGxldCBjb2RlID0gaGFzaEluZm8uc291cmNlQ29kZSB8fCBhd2FpdCBwZnMucmVhZEZpbGUoZmlsZVBhdGgsICd1dGY4Jyk7XG4gICAgICBjb2RlID0gYXdhaXQgQ29tcGlsZXJIb3N0LmZpeE5vZGVNb2R1bGVzU291cmNlTWFwcGluZyhjb2RlLCBmaWxlUGF0aCwgdGhpcy5maWxlQ2hhbmdlQ2FjaGUuYXBwUm9vdCk7XG4gICAgICByZXR1cm4geyBjb2RlLCBtaW1lVHlwZTogdHlwZSB9O1xuICAgIH1cblxuICAgIGxldCBjb21waWxlciA9IENvbXBpbGVySG9zdC5zaG91bGRQYXNzdGhyb3VnaChoYXNoSW5mbykgP1xuICAgICAgdGhpcy5nZXRQYXNzdGhyb3VnaENvbXBpbGVyKCkgOlxuICAgICAgdGhpcy5jb21waWxlcnNCeU1pbWVUeXBlW3R5cGUgfHwgJ19fbG9sbm90aGVyZSddO1xuXG4gICAgaWYgKCFjb21waWxlcikge1xuICAgICAgZChgRmFsbGluZyBiYWNrIHRvIHBhc3N0aHJvdWdoIGNvbXBpbGVyIGZvciAke2ZpbGVQYXRofWApO1xuICAgICAgY29tcGlsZXIgPSB0aGlzLmZhbGxiYWNrQ29tcGlsZXI7XG4gICAgfVxuXG4gICAgaWYgKCFjb21waWxlcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBDb3VsZG4ndCBmaW5kIGEgY29tcGlsZXIgZm9yICR7ZmlsZVBhdGh9YCk7XG4gICAgfVxuXG4gICAgbGV0IGNhY2hlID0gdGhpcy5jYWNoZXNGb3JDb21waWxlcnMuZ2V0KGNvbXBpbGVyKTtcbiAgICByZXR1cm4gYXdhaXQgY2FjaGUuZ2V0T3JGZXRjaChcbiAgICAgIGZpbGVQYXRoLFxuICAgICAgKGZpbGVQYXRoLCBoYXNoSW5mbykgPT4gdGhpcy5jb21waWxlVW5jYWNoZWQoZmlsZVBhdGgsIGhhc2hJbmZvLCBjb21waWxlcikpO1xuICB9XG5cbiAgLyoqXG4gICAqIEhhbmRsZXMgaW52b2tpbmcgY29tcGlsZXJzIGluZGVwZW5kZW50IG9mIGNhY2hpbmdcbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGFzeW5jIGNvbXBpbGVVbmNhY2hlZChmaWxlUGF0aCwgaGFzaEluZm8sIGNvbXBpbGVyKSB7XG4gICAgbGV0IGlucHV0TWltZVR5cGUgPSBtaW1lVHlwZXMubG9va3VwKGZpbGVQYXRoKTtcblxuICAgIGlmIChoYXNoSW5mby5pc0ZpbGVCaW5hcnkpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGJpbmFyeURhdGE6IGhhc2hJbmZvLmJpbmFyeURhdGEgfHwgYXdhaXQgcGZzLnJlYWRGaWxlKGZpbGVQYXRoKSxcbiAgICAgICAgbWltZVR5cGU6IGlucHV0TWltZVR5cGUsXG4gICAgICAgIGRlcGVuZGVudEZpbGVzOiBbXVxuICAgICAgfTtcbiAgICB9XG5cbiAgICBsZXQgY3R4ID0ge307XG4gICAgbGV0IGNvZGUgPSBoYXNoSW5mby5zb3VyY2VDb2RlIHx8IGF3YWl0IHBmcy5yZWFkRmlsZShmaWxlUGF0aCwgJ3V0ZjgnKTtcblxuICAgIGlmICghKGF3YWl0IGNvbXBpbGVyLnNob3VsZENvbXBpbGVGaWxlKGNvZGUsIGN0eCkpKSB7XG4gICAgICBkKGBDb21waWxlciByZXR1cm5lZCBmYWxzZSBmb3Igc2hvdWxkQ29tcGlsZUZpbGU6ICR7ZmlsZVBhdGh9YCk7XG4gICAgICByZXR1cm4geyBjb2RlLCBtaW1lVHlwZTogbWltZVR5cGVzLmxvb2t1cChmaWxlUGF0aCksIGRlcGVuZGVudEZpbGVzOiBbXSB9O1xuICAgIH1cblxuICAgIGxldCBkZXBlbmRlbnRGaWxlcyA9IGF3YWl0IGNvbXBpbGVyLmRldGVybWluZURlcGVuZGVudEZpbGVzKGNvZGUsIGZpbGVQYXRoLCBjdHgpO1xuXG4gICAgZChgVXNpbmcgY29tcGlsZXIgb3B0aW9uczogJHtKU09OLnN0cmluZ2lmeShjb21waWxlci5jb21waWxlck9wdGlvbnMpfWApO1xuICAgIGxldCByZXN1bHQgPSBhd2FpdCBjb21waWxlci5jb21waWxlKGNvZGUsIGZpbGVQYXRoLCBjdHgpO1xuXG4gICAgbGV0IHNob3VsZElubGluZUh0bWxpZnkgPVxuICAgICAgaW5wdXRNaW1lVHlwZSAhPT0gJ3RleHQvaHRtbCcgJiZcbiAgICAgIHJlc3VsdC5taW1lVHlwZSA9PT0gJ3RleHQvaHRtbCc7XG5cbiAgICBsZXQgaXNQYXNzdGhyb3VnaCA9XG4gICAgICByZXN1bHQubWltZVR5cGUgPT09ICd0ZXh0L3BsYWluJyB8fFxuICAgICAgIXJlc3VsdC5taW1lVHlwZSB8fFxuICAgICAgQ29tcGlsZXJIb3N0LnNob3VsZFBhc3N0aHJvdWdoKGhhc2hJbmZvKTtcblxuICAgIGlmICgoZmluYWxGb3Jtc1tyZXN1bHQubWltZVR5cGVdICYmICFzaG91bGRJbmxpbmVIdG1saWZ5KSB8fCBpc1Bhc3N0aHJvdWdoKSB7XG4gICAgICAvLyBHb3Qgc29tZXRoaW5nIHdlIGNhbiB1c2UgaW4tYnJvd3NlciwgbGV0J3MgcmV0dXJuIGl0XG4gICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihyZXN1bHQsIHtkZXBlbmRlbnRGaWxlc30pO1xuICAgIH0gZWxzZSB7XG4gICAgICBkKGBSZWN1cnNpdmVseSBjb21waWxpbmcgcmVzdWx0IG9mICR7ZmlsZVBhdGh9IHdpdGggbm9uLWZpbmFsIE1JTUUgdHlwZSAke3Jlc3VsdC5taW1lVHlwZX0sIGlucHV0IHdhcyAke2lucHV0TWltZVR5cGV9YCk7XG5cbiAgICAgIGhhc2hJbmZvID0gT2JqZWN0LmFzc2lnbih7IHNvdXJjZUNvZGU6IHJlc3VsdC5jb2RlLCBtaW1lVHlwZTogcmVzdWx0Lm1pbWVUeXBlIH0sIGhhc2hJbmZvKTtcbiAgICAgIGNvbXBpbGVyID0gdGhpcy5jb21waWxlcnNCeU1pbWVUeXBlW3Jlc3VsdC5taW1lVHlwZSB8fCAnX19sb2xub3RoZXJlJ107XG5cbiAgICAgIGlmICghY29tcGlsZXIpIHtcbiAgICAgICAgZChgUmVjdXJzaXZlIGNvbXBpbGUgZmFpbGVkIC0gaW50ZXJtZWRpYXRlIHJlc3VsdDogJHtKU09OLnN0cmluZ2lmeShyZXN1bHQpfWApO1xuXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgQ29tcGlsaW5nICR7ZmlsZVBhdGh9IHJlc3VsdGVkIGluIGEgTUlNRSB0eXBlIG9mICR7cmVzdWx0Lm1pbWVUeXBlfSwgd2hpY2ggd2UgZG9uJ3Qga25vdyBob3cgdG8gaGFuZGxlYCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBhd2FpdCB0aGlzLmNvbXBpbGVVbmNhY2hlZChcbiAgICAgICAgYCR7ZmlsZVBhdGh9LiR7bWltZVR5cGVzLmV4dGVuc2lvbihyZXN1bHQubWltZVR5cGUgfHwgJ3R4dCcpfWAsXG4gICAgICAgIGhhc2hJbmZvLCBjb21waWxlcik7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFByZS1jYWNoZXMgYW4gZW50aXJlIGRpcmVjdG9yeSBvZiBmaWxlcyByZWN1cnNpdmVseS4gVXN1YWxseSB1c2VkIGZvclxuICAgKiBidWlsZGluZyBjdXN0b20gY29tcGlsZXIgdG9vbGluZy5cbiAgICpcbiAgICogQHBhcmFtICB7c3RyaW5nfSByb290RGlyZWN0b3J5ICBUaGUgdG9wLWxldmVsIGRpcmVjdG9yeSB0byBjb21waWxlXG4gICAqXG4gICAqIEBwYXJhbSAge0Z1bmN0aW9ufSBzaG91bGRDb21waWxlIChvcHRpb25hbCkgIEEgRnVuY3Rpb24gd2hpY2ggYWxsb3dzIHRoZVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxsZXIgdG8gZGlzYWJsZSBjb21waWxpbmcgY2VydGFpbiBmaWxlcy5cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgSXQgdGFrZXMgYSBmdWxseS1xdWFsaWZpZWQgcGF0aCB0byBhIGZpbGUsXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFuZCBzaG91bGQgcmV0dXJuIGEgQm9vbGVhbi5cbiAgICpcbiAgICogQHJldHVybiB7UHJvbWlzZX0gIENvbXBsZXRpb24uXG4gICAqL1xuICBhc3luYyBjb21waWxlQWxsKHJvb3REaXJlY3RvcnksIHNob3VsZENvbXBpbGU9bnVsbCkge1xuICAgIGxldCBzaG91bGQgPSBzaG91bGRDb21waWxlIHx8IGZ1bmN0aW9uKCkge3JldHVybiB0cnVlO307XG5cbiAgICBhd2FpdCBmb3JBbGxGaWxlcyhyb290RGlyZWN0b3J5LCAoZikgPT4ge1xuICAgICAgaWYgKCFzaG91bGQoZikpIHJldHVybjtcblxuICAgICAgZChgQ29tcGlsaW5nICR7Zn1gKTtcbiAgICAgIHJldHVybiB0aGlzLmNvbXBpbGUoZiwgdGhpcy5jb21waWxlcnNCeU1pbWVUeXBlKTtcbiAgICB9KTtcbiAgfVxuXG4gIGxpc3RlblRvQ29tcGlsZUV2ZW50cygpIHtcbiAgICByZXR1cm4gbGlzdGVuKCdlbGVjdHJvbi1jb21waWxlLWNvbXBpbGVkLWZpbGUnKS5tYXAoKFt4XSkgPT4geCk7XG4gIH1cblxuICAvKlxuICAgKiBTeW5jIE1ldGhvZHNcbiAgICovXG5cbiAgY29tcGlsZVN5bmMoZmlsZVBhdGgpIHtcbiAgICBsZXQgcmV0ID0gKHRoaXMucmVhZE9ubHlNb2RlID9cbiAgICAgIHRoaXMuY29tcGlsZVJlYWRPbmx5U3luYyhmaWxlUGF0aCkgOlxuICAgICAgdGhpcy5mdWxsQ29tcGlsZVN5bmMoZmlsZVBhdGgpKTtcblxuICAgIGlmIChyZXQubWltZVR5cGUgPT09ICdhcHBsaWNhdGlvbi9qYXZhc2NyaXB0Jykge1xuICAgICAgdGhpcy5taW1lVHlwZXNUb1JlZ2lzdGVyW21pbWVUeXBlcy5sb29rdXAoZmlsZVBhdGgpXSA9IHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJldDtcbiAgfVxuXG4gIHN0YXRpYyBjcmVhdGVSZWFkb25seUZyb21Db25maWd1cmF0aW9uU3luYyhyb290Q2FjaGVEaXIsIGFwcFJvb3QsIGZhbGxiYWNrQ29tcGlsZXI9bnVsbCkge1xuICAgIGxldCB0YXJnZXQgPSBwYXRoLmpvaW4ocm9vdENhY2hlRGlyLCAnY29tcGlsZXItaW5mby5qc29uLmd6Jyk7XG4gICAgbGV0IGJ1ZiA9IGZzLnJlYWRGaWxlU3luYyh0YXJnZXQpO1xuICAgIGxldCBpbmZvID0gSlNPTi5wYXJzZSh6bGliLmd1bnppcFN5bmMoYnVmKSk7XG5cbiAgICBsZXQgZmlsZUNoYW5nZUNhY2hlID0gRmlsZUNoYW5nZWRDYWNoZS5sb2FkRnJvbURhdGEoaW5mby5maWxlQ2hhbmdlQ2FjaGUsIGFwcFJvb3QsIHRydWUpO1xuXG4gICAgbGV0IGNvbXBpbGVycyA9IE9iamVjdC5rZXlzKGluZm8uY29tcGlsZXJzKS5yZWR1Y2UoKGFjYywgeCkgPT4ge1xuICAgICAgbGV0IGN1ciA9IGluZm8uY29tcGlsZXJzW3hdO1xuICAgICAgYWNjW3hdID0gbmV3IFJlYWRPbmx5Q29tcGlsZXIoY3VyLm5hbWUsIGN1ci5jb21waWxlclZlcnNpb24sIGN1ci5jb21waWxlck9wdGlvbnMsIGN1ci5pbnB1dE1pbWVUeXBlcyk7XG5cbiAgICAgIHJldHVybiBhY2M7XG4gICAgfSwge30pO1xuXG4gICAgcmV0dXJuIG5ldyBDb21waWxlckhvc3Qocm9vdENhY2hlRGlyLCBjb21waWxlcnMsIGZpbGVDaGFuZ2VDYWNoZSwgdHJ1ZSwgZmFsbGJhY2tDb21waWxlciwgbnVsbCwgaW5mby5taW1lVHlwZXNUb1JlZ2lzdGVyKTtcbiAgfVxuXG4gIHN0YXRpYyBjcmVhdGVGcm9tQ29uZmlndXJhdGlvblN5bmMocm9vdENhY2hlRGlyLCBhcHBSb290LCBjb21waWxlcnNCeU1pbWVUeXBlLCBmYWxsYmFja0NvbXBpbGVyPW51bGwpIHtcbiAgICBsZXQgdGFyZ2V0ID0gcGF0aC5qb2luKHJvb3RDYWNoZURpciwgJ2NvbXBpbGVyLWluZm8uanNvbi5neicpO1xuICAgIGxldCBidWYgPSBmcy5yZWFkRmlsZVN5bmModGFyZ2V0KTtcbiAgICBsZXQgaW5mbyA9IEpTT04ucGFyc2UoemxpYi5ndW56aXBTeW5jKGJ1ZikpO1xuXG4gICAgbGV0IGZpbGVDaGFuZ2VDYWNoZSA9IEZpbGVDaGFuZ2VkQ2FjaGUubG9hZEZyb21EYXRhKGluZm8uZmlsZUNoYW5nZUNhY2hlLCBhcHBSb290LCBmYWxzZSk7XG5cbiAgICBPYmplY3Qua2V5cyhpbmZvLmNvbXBpbGVycykuZm9yRWFjaCgoeCkgPT4ge1xuICAgICAgbGV0IGN1ciA9IGluZm8uY29tcGlsZXJzW3hdO1xuICAgICAgY29tcGlsZXJzQnlNaW1lVHlwZVt4XS5jb21waWxlck9wdGlvbnMgPSBjdXIuY29tcGlsZXJPcHRpb25zO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIG5ldyBDb21waWxlckhvc3Qocm9vdENhY2hlRGlyLCBjb21waWxlcnNCeU1pbWVUeXBlLCBmaWxlQ2hhbmdlQ2FjaGUsIGZhbHNlLCBmYWxsYmFja0NvbXBpbGVyLCBudWxsLCBpbmZvLm1pbWVUeXBlc1RvUmVnaXN0ZXIpO1xuICB9XG5cbiAgc2F2ZUNvbmZpZ3VyYXRpb25TeW5jKCkge1xuICAgIGxldCBzZXJpYWxpemVkQ29tcGlsZXJPcHRzID0gT2JqZWN0LmtleXModGhpcy5jb21waWxlcnNCeU1pbWVUeXBlKS5yZWR1Y2UoKGFjYywgeCkgPT4ge1xuICAgICAgbGV0IGNvbXBpbGVyID0gdGhpcy5jb21waWxlcnNCeU1pbWVUeXBlW3hdO1xuICAgICAgbGV0IEtsYXNzID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKGNvbXBpbGVyKS5jb25zdHJ1Y3RvcjtcblxuICAgICAgbGV0IHZhbCA9IHtcbiAgICAgICAgbmFtZTogS2xhc3MubmFtZSxcbiAgICAgICAgaW5wdXRNaW1lVHlwZXM6IEtsYXNzLmdldElucHV0TWltZVR5cGVzKCksXG4gICAgICAgIGNvbXBpbGVyT3B0aW9uczogY29tcGlsZXIuY29tcGlsZXJPcHRpb25zLFxuICAgICAgICBjb21waWxlclZlcnNpb246IGNvbXBpbGVyLmdldENvbXBpbGVyVmVyc2lvbigpXG4gICAgICB9O1xuXG4gICAgICBhY2NbeF0gPSB2YWw7XG4gICAgICByZXR1cm4gYWNjO1xuICAgIH0sIHt9KTtcblxuICAgIGxldCBpbmZvID0ge1xuICAgICAgZmlsZUNoYW5nZUNhY2hlOiB0aGlzLmZpbGVDaGFuZ2VDYWNoZS5nZXRTYXZlZERhdGEoKSxcbiAgICAgIGNvbXBpbGVyczogc2VyaWFsaXplZENvbXBpbGVyT3B0cyxcbiAgICAgIG1pbWVUeXBlc1RvUmVnaXN0ZXI6IHRoaXMubWltZVR5cGVzVG9SZWdpc3RlclxuICAgIH07XG5cbiAgICBsZXQgdGFyZ2V0ID0gcGF0aC5qb2luKHRoaXMucm9vdENhY2hlRGlyLCAnY29tcGlsZXItaW5mby5qc29uLmd6Jyk7XG4gICAgbGV0IGJ1ZiA9IHpsaWIuZ3ppcFN5bmMobmV3IEJ1ZmZlcihKU09OLnN0cmluZ2lmeShpbmZvKSkpO1xuICAgIGZzLndyaXRlRmlsZVN5bmModGFyZ2V0LCBidWYpO1xuICB9XG5cbiAgY29tcGlsZVJlYWRPbmx5U3luYyhmaWxlUGF0aCkge1xuICAgIC8vIFdlIGd1YXJhbnRlZSB0aGF0IG5vZGVfbW9kdWxlcyBhcmUgYWx3YXlzIHNoaXBwZWQgZGlyZWN0bHlcbiAgICBsZXQgdHlwZSA9IG1pbWVUeXBlcy5sb29rdXAoZmlsZVBhdGgpO1xuICAgIGlmIChGaWxlQ2hhbmdlZENhY2hlLmlzSW5Ob2RlTW9kdWxlcyhmaWxlUGF0aCkpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG1pbWVUeXBlOiB0eXBlIHx8ICdhcHBsaWNhdGlvbi9qYXZhc2NyaXB0JyxcbiAgICAgICAgY29kZTogZnMucmVhZEZpbGVTeW5jKGZpbGVQYXRoLCAndXRmOCcpXG4gICAgICB9O1xuICAgIH1cblxuICAgIGxldCBoYXNoSW5mbyA9IHRoaXMuZmlsZUNoYW5nZUNhY2hlLmdldEhhc2hGb3JQYXRoU3luYyhmaWxlUGF0aCk7XG5cbiAgICAvLyBXZSBndWFyYW50ZWUgdGhhdCBub2RlX21vZHVsZXMgYXJlIGFsd2F5cyBzaGlwcGVkIGRpcmVjdGx5XG4gICAgaWYgKGhhc2hJbmZvLmlzSW5Ob2RlTW9kdWxlcykge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbWltZVR5cGU6IHR5cGUsXG4gICAgICAgIGNvZGU6IGhhc2hJbmZvLnNvdXJjZUNvZGUgfHwgZnMucmVhZEZpbGVTeW5jKGZpbGVQYXRoLCAndXRmOCcpXG4gICAgICB9O1xuICAgIH1cblxuICAgIC8vIE5COiBIZXJlLCB3ZSdyZSBiYXNpY2FsbHkgb25seSB1c2luZyB0aGUgY29tcGlsZXIgaGVyZSB0byBmaW5kXG4gICAgLy8gdGhlIGFwcHJvcHJpYXRlIENvbXBpbGVDYWNoZVxuICAgIGxldCBjb21waWxlciA9IENvbXBpbGVySG9zdC5zaG91bGRQYXNzdGhyb3VnaChoYXNoSW5mbykgP1xuICAgICAgdGhpcy5nZXRQYXNzdGhyb3VnaENvbXBpbGVyKCkgOlxuICAgICAgdGhpcy5jb21waWxlcnNCeU1pbWVUeXBlW3R5cGUgfHwgJ19fbG9sbm90aGVyZSddO1xuXG4gICAgLy8gTkI6IFdlIGRvbid0IHB1dCB0aGlzIGludG8gc2hvdWxkUGFzc3Rocm91Z2ggYmVjYXVzZSBJbmxpbmUgSFRNTFxuICAgIC8vIGNvbXBpbGVyIGlzIHRlY2huaWNhbGx5IG9mIHR5cGUgZmluYWxGb3JtcyAoaS5lLiBhIGJyb3dzZXIgY2FuXG4gICAgLy8gbmF0aXZlbHkgaGFuZGxlIHRoaXMgY29udGVudCksIHlldCBpdHMgY29tcGlsZXIgaXNcbiAgICAvLyBJbmxpbmVIdG1sQ29tcGlsZXIuIEhvd2V2ZXIsIHdlIHN0aWxsIHdhbnQgdG8gY2F0Y2ggc3RhbmRhcmQgQ1NTIGZpbGVzXG4gICAgLy8gd2hpY2ggd2lsbCBiZSBwcm9jZXNzZWQgYnkgUGFzc3Rocm91Z2hDb21waWxlci5cbiAgICBpZiAoZmluYWxGb3Jtc1t0eXBlXSAmJiAhY29tcGlsZXIpIHtcbiAgICAgIGNvbXBpbGVyID0gdGhpcy5nZXRQYXNzdGhyb3VnaENvbXBpbGVyKCk7XG4gICAgfVxuXG4gICAgaWYgKCFjb21waWxlcikge1xuICAgICAgY29tcGlsZXIgPSB0aGlzLmZhbGxiYWNrQ29tcGlsZXI7XG5cbiAgICAgIGxldCB7IGNvZGUsIGJpbmFyeURhdGEsIG1pbWVUeXBlIH0gPSBjb21waWxlci5nZXRTeW5jKGZpbGVQYXRoKTtcbiAgICAgIHJldHVybiB7IGNvZGU6IGNvZGUgfHwgYmluYXJ5RGF0YSwgbWltZVR5cGUgfTtcbiAgICB9XG5cbiAgICBsZXQgY2FjaGUgPSB0aGlzLmNhY2hlc0ZvckNvbXBpbGVycy5nZXQoY29tcGlsZXIpO1xuICAgIGxldCB7Y29kZSwgYmluYXJ5RGF0YSwgbWltZVR5cGV9ID0gY2FjaGUuZ2V0U3luYyhmaWxlUGF0aCk7XG5cbiAgICBjb2RlID0gY29kZSB8fCBiaW5hcnlEYXRhO1xuICAgIGlmICghY29kZSB8fCAhbWltZVR5cGUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgQXNrZWQgdG8gY29tcGlsZSAke2ZpbGVQYXRofSBpbiBwcm9kdWN0aW9uLCBpcyB0aGlzIGZpbGUgbm90IHByZWNvbXBpbGVkP2ApO1xuICAgIH1cblxuICAgIHJldHVybiB7IGNvZGUsIG1pbWVUeXBlIH07XG4gIH1cblxuICBmdWxsQ29tcGlsZVN5bmMoZmlsZVBhdGgpIHtcbiAgICBkKGBDb21waWxpbmcgJHtmaWxlUGF0aH1gKTtcblxuICAgIGxldCB0eXBlID0gbWltZVR5cGVzLmxvb2t1cChmaWxlUGF0aCk7XG5cbiAgICBzZW5kKCdlbGVjdHJvbi1jb21waWxlLWNvbXBpbGVkLWZpbGUnLCB7IGZpbGVQYXRoLCBtaW1lVHlwZTogdHlwZSB9KTtcblxuICAgIGxldCBoYXNoSW5mbyA9IHRoaXMuZmlsZUNoYW5nZUNhY2hlLmdldEhhc2hGb3JQYXRoU3luYyhmaWxlUGF0aCk7XG5cbiAgICBpZiAoaGFzaEluZm8uaXNJbk5vZGVNb2R1bGVzKSB7XG4gICAgICBsZXQgY29kZSA9IGhhc2hJbmZvLnNvdXJjZUNvZGUgfHwgZnMucmVhZEZpbGVTeW5jKGZpbGVQYXRoLCAndXRmOCcpO1xuICAgICAgY29kZSA9IENvbXBpbGVySG9zdC5maXhOb2RlTW9kdWxlc1NvdXJjZU1hcHBpbmdTeW5jKGNvZGUsIGZpbGVQYXRoLCB0aGlzLmZpbGVDaGFuZ2VDYWNoZS5hcHBSb290KTtcbiAgICAgIHJldHVybiB7IGNvZGUsIG1pbWVUeXBlOiB0eXBlIH07XG4gICAgfVxuXG4gICAgbGV0IGNvbXBpbGVyID0gQ29tcGlsZXJIb3N0LnNob3VsZFBhc3N0aHJvdWdoKGhhc2hJbmZvKSA/XG4gICAgICB0aGlzLmdldFBhc3N0aHJvdWdoQ29tcGlsZXIoKSA6XG4gICAgICB0aGlzLmNvbXBpbGVyc0J5TWltZVR5cGVbdHlwZSB8fCAnX19sb2xub3RoZXJlJ107XG5cbiAgICBpZiAoIWNvbXBpbGVyKSB7XG4gICAgICBkKGBGYWxsaW5nIGJhY2sgdG8gcGFzc3Rocm91Z2ggY29tcGlsZXIgZm9yICR7ZmlsZVBhdGh9YCk7XG4gICAgICBjb21waWxlciA9IHRoaXMuZmFsbGJhY2tDb21waWxlcjtcbiAgICB9XG5cbiAgICBpZiAoIWNvbXBpbGVyKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYENvdWxkbid0IGZpbmQgYSBjb21waWxlciBmb3IgJHtmaWxlUGF0aH1gKTtcbiAgICB9XG5cbiAgICBsZXQgY2FjaGUgPSB0aGlzLmNhY2hlc0ZvckNvbXBpbGVycy5nZXQoY29tcGlsZXIpO1xuICAgIHJldHVybiBjYWNoZS5nZXRPckZldGNoU3luYyhcbiAgICAgIGZpbGVQYXRoLFxuICAgICAgKGZpbGVQYXRoLCBoYXNoSW5mbykgPT4gdGhpcy5jb21waWxlVW5jYWNoZWRTeW5jKGZpbGVQYXRoLCBoYXNoSW5mbywgY29tcGlsZXIpKTtcbiAgfVxuXG4gIGNvbXBpbGVVbmNhY2hlZFN5bmMoZmlsZVBhdGgsIGhhc2hJbmZvLCBjb21waWxlcikge1xuICAgIGxldCBpbnB1dE1pbWVUeXBlID0gbWltZVR5cGVzLmxvb2t1cChmaWxlUGF0aCk7XG5cbiAgICBpZiAoaGFzaEluZm8uaXNGaWxlQmluYXJ5KSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBiaW5hcnlEYXRhOiBoYXNoSW5mby5iaW5hcnlEYXRhIHx8IGZzLnJlYWRGaWxlU3luYyhmaWxlUGF0aCksXG4gICAgICAgIG1pbWVUeXBlOiBpbnB1dE1pbWVUeXBlLFxuICAgICAgICBkZXBlbmRlbnRGaWxlczogW11cbiAgICAgIH07XG4gICAgfVxuXG4gICAgbGV0IGN0eCA9IHt9O1xuICAgIGxldCBjb2RlID0gaGFzaEluZm8uc291cmNlQ29kZSB8fCBmcy5yZWFkRmlsZVN5bmMoZmlsZVBhdGgsICd1dGY4Jyk7XG5cbiAgICBpZiAoIShjb21waWxlci5zaG91bGRDb21waWxlRmlsZVN5bmMoY29kZSwgY3R4KSkpIHtcbiAgICAgIGQoYENvbXBpbGVyIHJldHVybmVkIGZhbHNlIGZvciBzaG91bGRDb21waWxlRmlsZTogJHtmaWxlUGF0aH1gKTtcbiAgICAgIHJldHVybiB7IGNvZGUsIG1pbWVUeXBlOiBtaW1lVHlwZXMubG9va3VwKGZpbGVQYXRoKSwgZGVwZW5kZW50RmlsZXM6IFtdIH07XG4gICAgfVxuXG4gICAgbGV0IGRlcGVuZGVudEZpbGVzID0gY29tcGlsZXIuZGV0ZXJtaW5lRGVwZW5kZW50RmlsZXNTeW5jKGNvZGUsIGZpbGVQYXRoLCBjdHgpO1xuXG4gICAgbGV0IHJlc3VsdCA9IGNvbXBpbGVyLmNvbXBpbGVTeW5jKGNvZGUsIGZpbGVQYXRoLCBjdHgpO1xuXG4gICAgbGV0IHNob3VsZElubGluZUh0bWxpZnkgPVxuICAgICAgaW5wdXRNaW1lVHlwZSAhPT0gJ3RleHQvaHRtbCcgJiZcbiAgICAgIHJlc3VsdC5taW1lVHlwZSA9PT0gJ3RleHQvaHRtbCc7XG5cbiAgICBsZXQgaXNQYXNzdGhyb3VnaCA9XG4gICAgICByZXN1bHQubWltZVR5cGUgPT09ICd0ZXh0L3BsYWluJyB8fFxuICAgICAgIXJlc3VsdC5taW1lVHlwZSB8fFxuICAgICAgQ29tcGlsZXJIb3N0LnNob3VsZFBhc3N0aHJvdWdoKGhhc2hJbmZvKTtcblxuICAgIGlmICgoZmluYWxGb3Jtc1tyZXN1bHQubWltZVR5cGVdICYmICFzaG91bGRJbmxpbmVIdG1saWZ5KSB8fCBpc1Bhc3N0aHJvdWdoKSB7XG4gICAgICAvLyBHb3Qgc29tZXRoaW5nIHdlIGNhbiB1c2UgaW4tYnJvd3NlciwgbGV0J3MgcmV0dXJuIGl0XG4gICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihyZXN1bHQsIHtkZXBlbmRlbnRGaWxlc30pO1xuICAgIH0gZWxzZSB7XG4gICAgICBkKGBSZWN1cnNpdmVseSBjb21waWxpbmcgcmVzdWx0IG9mICR7ZmlsZVBhdGh9IHdpdGggbm9uLWZpbmFsIE1JTUUgdHlwZSAke3Jlc3VsdC5taW1lVHlwZX0sIGlucHV0IHdhcyAke2lucHV0TWltZVR5cGV9YCk7XG5cbiAgICAgIGhhc2hJbmZvID0gT2JqZWN0LmFzc2lnbih7IHNvdXJjZUNvZGU6IHJlc3VsdC5jb2RlLCBtaW1lVHlwZTogcmVzdWx0Lm1pbWVUeXBlIH0sIGhhc2hJbmZvKTtcbiAgICAgIGNvbXBpbGVyID0gdGhpcy5jb21waWxlcnNCeU1pbWVUeXBlW3Jlc3VsdC5taW1lVHlwZSB8fCAnX19sb2xub3RoZXJlJ107XG5cbiAgICAgIGlmICghY29tcGlsZXIpIHtcbiAgICAgICAgZChgUmVjdXJzaXZlIGNvbXBpbGUgZmFpbGVkIC0gaW50ZXJtZWRpYXRlIHJlc3VsdDogJHtKU09OLnN0cmluZ2lmeShyZXN1bHQpfWApO1xuXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgQ29tcGlsaW5nICR7ZmlsZVBhdGh9IHJlc3VsdGVkIGluIGEgTUlNRSB0eXBlIG9mICR7cmVzdWx0Lm1pbWVUeXBlfSwgd2hpY2ggd2UgZG9uJ3Qga25vdyBob3cgdG8gaGFuZGxlYCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLmNvbXBpbGVVbmNhY2hlZFN5bmMoXG4gICAgICAgIGAke2ZpbGVQYXRofS4ke21pbWVUeXBlcy5leHRlbnNpb24ocmVzdWx0Lm1pbWVUeXBlIHx8ICd0eHQnKX1gLFxuICAgICAgICBoYXNoSW5mbywgY29tcGlsZXIpO1xuICAgIH1cbiAgfVxuXG4gIGNvbXBpbGVBbGxTeW5jKHJvb3REaXJlY3RvcnksIHNob3VsZENvbXBpbGU9bnVsbCkge1xuICAgIGxldCBzaG91bGQgPSBzaG91bGRDb21waWxlIHx8IGZ1bmN0aW9uKCkge3JldHVybiB0cnVlO307XG5cbiAgICBmb3JBbGxGaWxlc1N5bmMocm9vdERpcmVjdG9yeSwgKGYpID0+IHtcbiAgICAgIGlmICghc2hvdWxkKGYpKSByZXR1cm47XG4gICAgICByZXR1cm4gdGhpcy5jb21waWxlU3luYyhmLCB0aGlzLmNvbXBpbGVyc0J5TWltZVR5cGUpO1xuICAgIH0pO1xuICB9XG5cbiAgLypcbiAgICogT3RoZXIgc3R1ZmZcbiAgICovXG5cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgcGFzc3Rocm91Z2ggY29tcGlsZXJcbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGdldFBhc3N0aHJvdWdoQ29tcGlsZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29tcGlsZXJzQnlNaW1lVHlwZVsndGV4dC9wbGFpbiddO1xuICB9XG5cblxuICAvKipcbiAgICogRGV0ZXJtaW5lcyB3aGV0aGVyIHdlIHNob3VsZCBldmVuIHRyeSB0byBjb21waWxlIHRoZSBjb250ZW50LiBOb3RlIHRoYXQgaW5cbiAgICogc29tZSBjYXNlcywgY29udGVudCB3aWxsIHN0aWxsIGJlIGluIGNhY2hlIGV2ZW4gaWYgdGhpcyByZXR1cm5zIHRydWUsIGFuZFxuICAgKiBpbiBvdGhlciBjYXNlcyAoaXNJbk5vZGVNb2R1bGVzKSwgd2UnbGwga25vdyBleHBsaWNpdGx5IHRvIG5vdCBldmVuIGJvdGhlclxuICAgKiBsb29raW5nIGluIHRoZSBjYWNoZS5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG4gIHN0YXRpYyBzaG91bGRQYXNzdGhyb3VnaChoYXNoSW5mbykge1xuICAgIHJldHVybiBoYXNoSW5mby5pc01pbmlmaWVkIHx8IGhhc2hJbmZvLmlzSW5Ob2RlTW9kdWxlcyB8fCBoYXNoSW5mby5oYXNTb3VyY2VNYXAgfHwgaGFzaEluZm8uaXNGaWxlQmluYXJ5O1xuICB9XG5cbiAgLyoqXG4gICAqIExvb2sgYXQgdGhlIGNvZGUgb2YgYSBub2RlIG1vZHVsZXMgYW5kIHNlZSB0aGUgc291cmNlTWFwcGluZyBwYXRoLlxuICAgKiBJZiB0aGVyZSBpcyBhbnksIGNoZWNrIHRoZSBwYXRoIGFuZCB0cnkgdG8gZml4IGl0IHdpdGggYW5kXG4gICAqIHJvb3QgcmVsYXRpdmUgcGF0aC5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHN0YXRpYyBhc3luYyBmaXhOb2RlTW9kdWxlc1NvdXJjZU1hcHBpbmcoc291cmNlQ29kZSwgc291cmNlUGF0aCwgYXBwUm9vdCkge1xuICAgIGxldCByZWdleFNvdXJjZU1hcHBpbmcgPSAvXFwvXFwvIy4qc291cmNlTWFwcGluZ1VSTD0oPyFkYXRhOikoW15cIiddLiopL2k7XG4gICAgbGV0IHNvdXJjZU1hcHBpbmdDaGVjayA9IHNvdXJjZUNvZGUubWF0Y2gocmVnZXhTb3VyY2VNYXBwaW5nKTtcblxuICAgIGlmIChzb3VyY2VNYXBwaW5nQ2hlY2sgJiYgc291cmNlTWFwcGluZ0NoZWNrWzFdICYmIHNvdXJjZU1hcHBpbmdDaGVja1sxXSAhPT0gJycpe1xuICAgICAgbGV0IHNvdXJjZU1hcFBhdGggPSBzb3VyY2VNYXBwaW5nQ2hlY2tbMV07XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGF3YWl0IHBmcy5zdGF0KHNvdXJjZU1hcFBhdGgpO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgbGV0IG5vcm1Sb290ID0gcGF0aC5ub3JtYWxpemUoYXBwUm9vdCk7XG4gICAgICAgIGxldCBhYnNQYXRoVG9Nb2R1bGUgPSBwYXRoLmRpcm5hbWUoc291cmNlUGF0aC5yZXBsYWNlKG5vcm1Sb290LCAnJykuc3Vic3RyaW5nKDEpKTtcbiAgICAgICAgbGV0IG5ld01hcFBhdGggPSBwYXRoLmpvaW4oYWJzUGF0aFRvTW9kdWxlLCBzb3VyY2VNYXBQYXRoKTtcblxuICAgICAgICByZXR1cm4gc291cmNlQ29kZS5yZXBsYWNlKHJlZ2V4U291cmNlTWFwcGluZywgYC8vIyBzb3VyY2VNYXBwaW5nVVJMPSR7bmV3TWFwUGF0aH1gKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gc291cmNlQ29kZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBMb29rIGF0IHRoZSBjb2RlIG9mIGEgbm9kZSBtb2R1bGVzIGFuZCBzZWUgdGhlIHNvdXJjZU1hcHBpbmcgcGF0aC5cbiAgICogSWYgdGhlcmUgaXMgYW55LCBjaGVjayB0aGUgcGF0aCBhbmQgdHJ5IHRvIGZpeCBpdCB3aXRoIGFuZFxuICAgKiByb290IHJlbGF0aXZlIHBhdGguXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBzdGF0aWMgZml4Tm9kZU1vZHVsZXNTb3VyY2VNYXBwaW5nU3luYyhzb3VyY2VDb2RlLCBzb3VyY2VQYXRoLCBhcHBSb290KSB7XG4gICAgbGV0IHJlZ2V4U291cmNlTWFwcGluZyA9IC9cXC9cXC8jLipzb3VyY2VNYXBwaW5nVVJMPSg/IWRhdGE6KShbXlwiJ10uKikvaTtcbiAgICBsZXQgc291cmNlTWFwcGluZ0NoZWNrID0gc291cmNlQ29kZS5tYXRjaChyZWdleFNvdXJjZU1hcHBpbmcpO1xuXG4gICAgaWYgKHNvdXJjZU1hcHBpbmdDaGVjayAmJiBzb3VyY2VNYXBwaW5nQ2hlY2tbMV0gJiYgc291cmNlTWFwcGluZ0NoZWNrWzFdICE9PSAnJyl7XG4gICAgICBsZXQgc291cmNlTWFwUGF0aCA9IHNvdXJjZU1hcHBpbmdDaGVja1sxXTtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgZnMuc3RhdFN5bmMoc291cmNlTWFwUGF0aCk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBsZXQgbm9ybVJvb3QgPSBwYXRoLm5vcm1hbGl6ZShhcHBSb290KTtcbiAgICAgICAgbGV0IGFic1BhdGhUb01vZHVsZSA9IHBhdGguZGlybmFtZShzb3VyY2VQYXRoLnJlcGxhY2Uobm9ybVJvb3QsICcnKS5zdWJzdHJpbmcoMSkpO1xuICAgICAgICBsZXQgbmV3TWFwUGF0aCA9IHBhdGguam9pbihhYnNQYXRoVG9Nb2R1bGUsIHNvdXJjZU1hcFBhdGgpO1xuXG4gICAgICAgIHJldHVybiBzb3VyY2VDb2RlLnJlcGxhY2UocmVnZXhTb3VyY2VNYXBwaW5nLCBgLy8jIHNvdXJjZU1hcHBpbmdVUkw9JHtuZXdNYXBQYXRofWApO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBzb3VyY2VDb2RlO1xuICB9XG59XG4iXX0=\n\n//# sourceURL=webpack:///./node_modules/electron-compile/lib/compiler-host.js?")},"./node_modules/electron-compile/lib/config-parser.js":
/*!************************************************************!*\
  !*** ./node_modules/electron-compile/lib/config-parser.js ***!
  \************************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){"use strict";eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createCompilerHostFromProjectRoot = exports.createCompilerHostFromConfigFile = exports.createCompilerHostFromBabelRc = undefined;\n\n/**\n * Creates a compiler host from a .babelrc file. This method is usually called\n * from {@link createCompilerHostFromProjectRoot} instead of used directly.\n *\n * @param  {string} file  The path to a .babelrc file\n *\n * @param  {string} rootCacheDir (optional)  The directory to use as a cache.\n *\n * @return {Promise<CompilerHost>}  A set-up compiler host\n */\nlet createCompilerHostFromBabelRc = exports.createCompilerHostFromBabelRc = (() => {\n  var _ref = _asyncToGenerator(function* (file) {\n    let rootCacheDir = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    let sourceMapPath = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n\n    let info = JSON.parse((yield _promise.pfs.readFile(file, 'utf8')));\n\n    // package.json\n    if ('babel' in info) {\n      info = info.babel;\n    }\n\n    if ('env' in info) {\n      let ourEnv = process.env.BABEL_ENV || \"development\" || 'development';\n      info = info.env[ourEnv];\n    }\n\n    // Are we still package.json (i.e. is there no babel info whatsoever?)\n    if ('name' in info && 'version' in info) {\n      let appRoot = _path2.default.dirname(file);\n      return createCompilerHostFromConfiguration({\n        appRoot: appRoot,\n        options: getDefaultConfiguration(appRoot),\n        rootCacheDir,\n        sourceMapPath\n      });\n    }\n\n    return createCompilerHostFromConfiguration({\n      appRoot: _path2.default.dirname(file),\n      options: {\n        'application/javascript': info\n      },\n      rootCacheDir,\n      sourceMapPath\n    });\n  });\n\n  return function createCompilerHostFromBabelRc(_x5) {\n    return _ref.apply(this, arguments);\n  };\n})();\n\n/**\n * Creates a compiler host from a .compilerc file. This method is usually called\n * from {@link createCompilerHostFromProjectRoot} instead of used directly.\n *\n * @param  {string} file  The path to a .compilerc file\n *\n * @param  {string} rootCacheDir (optional)  The directory to use as a cache.\n *\n * @return {Promise<CompilerHost>}  A set-up compiler host\n */\n\n\nlet createCompilerHostFromConfigFile = exports.createCompilerHostFromConfigFile = (() => {\n  var _ref2 = _asyncToGenerator(function* (file) {\n    let rootCacheDir = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    let sourceMapPath = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n\n    let info = JSON.parse((yield _promise.pfs.readFile(file, 'utf8')));\n\n    if ('env' in info) {\n      let ourEnv = process.env.ELECTRON_COMPILE_ENV || \"development\" || 'development';\n      info = info.env[ourEnv];\n    }\n\n    return createCompilerHostFromConfiguration({\n      appRoot: _path2.default.dirname(file),\n      options: info,\n      rootCacheDir,\n      sourceMapPath\n    });\n  });\n\n  return function createCompilerHostFromConfigFile(_x8) {\n    return _ref2.apply(this, arguments);\n  };\n})();\n\n/**\n * Creates a configured {@link CompilerHost} instance from the project root\n * directory. This method first searches for a .compilerc (or .compilerc.json), then falls back to the\n * default locations for Babel configuration info. If neither are found, defaults\n * to standard settings\n *\n * @param  {string} rootDir  The root application directory (i.e. the directory\n *                           that has the app's package.json)\n *\n * @param  {string} rootCacheDir (optional)  The directory to use as a cache.\n *\n * @param {string} sourceMapPath (optional) The directory to store sourcemap separately\n *                               if compiler option enabled to emit.\n *\n * @return {Promise<CompilerHost>}  A set-up compiler host\n */\n\n\nlet createCompilerHostFromProjectRoot = exports.createCompilerHostFromProjectRoot = (() => {\n  var _ref3 = _asyncToGenerator(function* (rootDir) {\n    let rootCacheDir = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    let sourceMapPath = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n\n    let compilerc = _path2.default.join(rootDir, '.compilerc');\n    if (statSyncNoException(compilerc)) {\n      d(`Found a .compilerc at ${compilerc}, using it`);\n      return yield createCompilerHostFromConfigFile(compilerc, rootCacheDir, sourceMapPath);\n    }\n    compilerc += '.json';\n    if (statSyncNoException(compilerc)) {\n      d(`Found a .compilerc at ${compilerc}, using it`);\n      return yield createCompilerHostFromConfigFile(compilerc, rootCacheDir, sourceMapPath);\n    }\n\n    let babelrc = _path2.default.join(rootDir, '.babelrc');\n    if (statSyncNoException(babelrc)) {\n      d(`Found a .babelrc at ${babelrc}, using it`);\n      return yield createCompilerHostFromBabelRc(babelrc, rootCacheDir, sourceMapPath);\n    }\n\n    d(`Using package.json or default parameters at ${rootDir}`);\n    return yield createCompilerHostFromBabelRc(_path2.default.join(rootDir, 'package.json'), rootCacheDir, sourceMapPath);\n  });\n\n  return function createCompilerHostFromProjectRoot(_x11) {\n    return _ref3.apply(this, arguments);\n  };\n})();\n\nexports.initializeGlobalHooks = initializeGlobalHooks;\nexports.init = init;\nexports.createCompilerHostFromConfiguration = createCompilerHostFromConfiguration;\nexports.createCompilerHostFromBabelRcSync = createCompilerHostFromBabelRcSync;\nexports.createCompilerHostFromConfigFileSync = createCompilerHostFromConfigFileSync;\nexports.createCompilerHostFromProjectRootSync = createCompilerHostFromProjectRootSync;\nexports.calculateDefaultCompileCacheDirectory = calculateDefaultCompileCacheDirectory;\nexports.getDefaultConfiguration = getDefaultConfiguration;\nexports.createCompilers = createCompilers;\n\nvar _fs = __webpack_require__(/*! fs */ \"fs\");\n\nvar _fs2 = _interopRequireDefault(_fs);\n\nvar _path = __webpack_require__(/*! path */ \"path\");\n\nvar _path2 = _interopRequireDefault(_path);\n\nvar _zlib = __webpack_require__(/*! zlib */ \"zlib\");\n\nvar _zlib2 = _interopRequireDefault(_zlib);\n\nvar _mkdirp = __webpack_require__(/*! mkdirp */ \"./node_modules/mkdirp/index.js\");\n\nvar _mkdirp2 = _interopRequireDefault(_mkdirp);\n\nvar _promise = __webpack_require__(/*! ./promise */ \"./node_modules/electron-compile/lib/promise.js\");\n\nvar _fileChangeCache = __webpack_require__(/*! ./file-change-cache */ \"./node_modules/electron-compile/lib/file-change-cache.js\");\n\nvar _fileChangeCache2 = _interopRequireDefault(_fileChangeCache);\n\nvar _compilerHost = __webpack_require__(/*! ./compiler-host */ \"./node_modules/electron-compile/lib/compiler-host.js\");\n\nvar _compilerHost2 = _interopRequireDefault(_compilerHost);\n\nvar _requireHook = __webpack_require__(/*! ./require-hook */ \"./node_modules/electron-compile/lib/require-hook.js\");\n\nvar _requireHook2 = _interopRequireDefault(_requireHook);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step(\"next\", value); }, function (err) { step(\"throw\", err); }); } } return step(\"next\"); }); }; }\n\nconst d = __webpack_require__(/*! debug */ \"./node_modules/debug/src/index.js\")('electron-compile:config-parser');\n\n// NB: We intentionally delay-load this so that in production, you can create\n// cache-only versions of these compilers\nlet allCompilerClasses = null;\n\nfunction statSyncNoException(fsPath) {\n  if ('statSyncNoException' in _fs2.default) {\n    return _fs2.default.statSyncNoException(fsPath);\n  }\n\n  try {\n    return _fs2.default.statSync(fsPath);\n  } catch (e) {\n    return null;\n  }\n}\n\n/**\n * Initialize the global hooks (protocol hook for file:, node.js hook)\n * independent of initializing the compiler. This method is usually called by\n * init instead of directly\n *\n * @param {CompilerHost} compilerHost  The compiler host to use.\n *\n */\nfunction initializeGlobalHooks(compilerHost) {\n  let isProduction = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n  let globalVar = global || window;\n  globalVar.globalCompilerHost = compilerHost;\n\n  (0, _requireHook2.default)(compilerHost, isProduction);\n\n  if ('type' in process && process.type === 'browser') {\n    var _require = __webpack_require__(/*! electron */ \"electron\");\n\n    const app = _require.app;\n\n    var _require2 = __webpack_require__(/*! ./protocol-hook */ \"./node_modules/electron-compile/lib/protocol-hook.js\");\n\n    const initializeProtocolHook = _require2.initializeProtocolHook;\n\n\n    let protoify = function () {\n      initializeProtocolHook(compilerHost);\n    };\n    if (app.isReady()) {\n      protoify();\n    } else {\n      app.on('ready', protoify);\n    }\n  }\n}\n\n/**\n * Initialize electron-compile and set it up, either for development or\n * production use. This is almost always the only method you need to use in order\n * to use electron-compile.\n *\n * @param  {string} appRoot  The top-level directory for your application (i.e.\n *                           the one which has your package.json).\n *\n * @param  {string} mainModule  The module to require in, relative to the module\n *                              calling init, that will start your app. Write this\n *                              as if you were writing a require call from here.\n *\n * @param  {bool} productionMode   If explicitly True/False, will set read-only\n *                                 mode to be disabled/enabled. If not, we'll\n *                                 guess based on the presence of a production\n *                                 cache.\n *\n * @param  {string} cacheDir  If not passed in, read-only will look in\n *                            `appRoot/.cache` and dev mode will compile to a\n *                            temporary directory. If it is passed in, both modes\n *                            will cache to/from `appRoot/{cacheDir}`\n *\n * @param {string} sourceMapPath (optional) The directory to store sourcemap separately\n *                               if compiler option enabled to emit.\n *                               Default to cachePath if not specified, will be ignored for read-only mode.\n */\nfunction init(appRoot, mainModule) {\n  let productionMode = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n  let cacheDir = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n  let sourceMapPath = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;\n\n  let compilerHost = null;\n  let rootCacheDir = _path2.default.join(appRoot, cacheDir || '.cache');\n\n  if (productionMode === null) {\n    productionMode = !!statSyncNoException(rootCacheDir);\n  }\n\n  if (productionMode) {\n    compilerHost = _compilerHost2.default.createReadonlyFromConfigurationSync(rootCacheDir, appRoot);\n  } else {\n    // if cacheDir was passed in, pass it along. Otherwise, default to a tempdir.\n    const cachePath = cacheDir ? rootCacheDir : null;\n    const mapPath = sourceMapPath ? _path2.default.join(appRoot, sourceMapPath) : cachePath;\n    compilerHost = createCompilerHostFromProjectRootSync(appRoot, cachePath, mapPath);\n  }\n\n  initializeGlobalHooks(compilerHost, productionMode);\n  (void 0)(mainModule);\n}\n\n/**\n * Creates a {@link CompilerHost} with the given information. This method is\n * usually called by {@link createCompilerHostFromProjectRoot}.\n *\n * @private\n */\nfunction createCompilerHostFromConfiguration(info) {\n  let compilers = createCompilers();\n  let rootCacheDir = info.rootCacheDir || calculateDefaultCompileCacheDirectory();\n  const sourceMapPath = info.sourceMapPath || info.rootCacheDir;\n\n  if (info.sourceMapPath) {\n    createSourceMapDirectory(sourceMapPath);\n  }\n\n  d(`Creating CompilerHost: ${JSON.stringify(info)}, rootCacheDir = ${rootCacheDir}, sourceMapPath = ${sourceMapPath}`);\n  let fileChangeCache = new _fileChangeCache2.default(info.appRoot);\n\n  let compilerInfo = _path2.default.join(rootCacheDir, 'compiler-info.json.gz');\n  let json = {};\n  if (_fs2.default.existsSync(compilerInfo)) {\n    let buf = _fs2.default.readFileSync(compilerInfo);\n    json = JSON.parse(_zlib2.default.gunzipSync(buf));\n    fileChangeCache = _fileChangeCache2.default.loadFromData(json.fileChangeCache, info.appRoot, false);\n  }\n\n  Object.keys(info.options || {}).forEach(x => {\n    let opts = info.options[x];\n    if (!(x in compilers)) {\n      throw new Error(`Found compiler settings for missing compiler: ${x}`);\n    }\n\n    // NB: Let's hope this isn't a valid compiler option...\n    if (opts.passthrough) {\n      compilers[x] = compilers['text/plain'];\n      delete opts.passthrough;\n    }\n\n    d(`Setting options for ${x}: ${JSON.stringify(opts)}`);\n    compilers[x].compilerOptions = opts;\n  });\n\n  let ret = new _compilerHost2.default(rootCacheDir, compilers, fileChangeCache, false, compilers['text/plain'], null, json.mimeTypesToRegister);\n\n  // NB: It's super important that we guarantee that the configuration is saved\n  // out, because we'll need to re-read it in the renderer process\n  d(`Created compiler host with options: ${JSON.stringify(info)}`);\n  ret.saveConfigurationSync();\n  return ret;\n}function createCompilerHostFromBabelRcSync(file) {\n  let rootCacheDir = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n  let sourceMapPath = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n\n  let info = JSON.parse(_fs2.default.readFileSync(file, 'utf8'));\n\n  // package.json\n  if ('babel' in info) {\n    info = info.babel;\n  }\n\n  if ('env' in info) {\n    let ourEnv = process.env.BABEL_ENV || \"development\" || 'development';\n    info = info.env[ourEnv];\n  }\n\n  // Are we still package.json (i.e. is there no babel info whatsoever?)\n  if ('name' in info && 'version' in info) {\n    let appRoot = _path2.default.dirname(file);\n    return createCompilerHostFromConfiguration({\n      appRoot: appRoot,\n      options: getDefaultConfiguration(appRoot),\n      rootCacheDir,\n      sourceMapPath\n    });\n  }\n\n  return createCompilerHostFromConfiguration({\n    appRoot: _path2.default.dirname(file),\n    options: {\n      'application/javascript': info\n    },\n    rootCacheDir,\n    sourceMapPath\n  });\n}\n\nfunction createCompilerHostFromConfigFileSync(file) {\n  let rootCacheDir = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n  let sourceMapPath = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n\n  let info = JSON.parse(_fs2.default.readFileSync(file, 'utf8'));\n\n  if ('env' in info) {\n    let ourEnv = process.env.ELECTRON_COMPILE_ENV || \"development\" || 'development';\n    info = info.env[ourEnv];\n  }\n\n  return createCompilerHostFromConfiguration({\n    appRoot: _path2.default.dirname(file),\n    options: info,\n    rootCacheDir,\n    sourceMapPath\n  });\n}\n\nfunction createCompilerHostFromProjectRootSync(rootDir) {\n  let rootCacheDir = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n  let sourceMapPath = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n\n  let compilerc = _path2.default.join(rootDir, '.compilerc');\n  if (statSyncNoException(compilerc)) {\n    d(`Found a .compilerc at ${compilerc}, using it`);\n    return createCompilerHostFromConfigFileSync(compilerc, rootCacheDir, sourceMapPath);\n  }\n\n  let babelrc = _path2.default.join(rootDir, '.babelrc');\n  if (statSyncNoException(babelrc)) {\n    d(`Found a .babelrc at ${babelrc}, using it`);\n    return createCompilerHostFromBabelRcSync(babelrc, rootCacheDir, sourceMapPath);\n  }\n\n  d(`Using package.json or default parameters at ${rootDir}`);\n  return createCompilerHostFromBabelRcSync(_path2.default.join(rootDir, 'package.json'), rootCacheDir, sourceMapPath);\n}\n\n/**\n * Returns what electron-compile would use as a default rootCacheDir. Usually only\n * used for debugging purposes\n *\n * @return {string}  A path that may or may not exist where electron-compile would\n *                   set up a development mode cache.\n */\nfunction calculateDefaultCompileCacheDirectory() {\n  let tmpDir = process.env.TEMP || process.env.TMPDIR || '/tmp';\n  let hash = __webpack_require__(/*! crypto */ \"crypto\").createHash('md5').update(process.execPath).digest('hex');\n\n  let cacheDir = _path2.default.join(tmpDir, `compileCache_${hash}`);\n  _mkdirp2.default.sync(cacheDir);\n\n  d(`Using default cache directory: ${cacheDir}`);\n  return cacheDir;\n}\n\nfunction createSourceMapDirectory(sourceMapPath) {\n  _mkdirp2.default.sync(sourceMapPath);\n  d(`Using separate sourcemap path at ${sourceMapPath}`);\n}\n\nfunction getElectronVersion(rootDir) {\n  if (process.versions.electron) {\n    return process.versions.electron;\n  }\n\n  let ourPkgJson = __webpack_require__(\"./node_modules/electron-compile/lib sync recursive\")(_path2.default.join(rootDir, 'package.json'));\n\n  let version = ['electron-prebuilt-compile', 'electron'].map(mod => {\n    if (ourPkgJson.devDependencies && ourPkgJson.devDependencies[mod]) {\n      // NB: lol this code\n      let verRange = ourPkgJson.devDependencies[mod];\n      let m = verRange.match(/(\\d+\\.\\d+\\.\\d+)/);\n      if (m && m[1]) return m[1];\n    }\n\n    try {\n      return process.mainModule.require(`${mod}/package.json`).version;\n    } catch (e) {\n      // NB: This usually doesn't work, but sometimes maybe?\n    }\n\n    try {\n      let p = _path2.default.join(rootDir, mod, 'package.json');\n      return __webpack_require__(\"./node_modules/electron-compile/lib sync recursive\")(p).version;\n    } catch (e) {\n      return null;\n    }\n  }).find(x => !!x);\n\n  if (!version) {\n    throw new Error(\"Can't automatically discover the version of Electron, you probably need a .compilerc file\");\n  }\n\n  return version;\n}\n\n/**\n * Returns the default .configrc if no configuration information can be found.\n *\n * @return {Object}  A list of default config settings for electron-compiler.\n */\nfunction getDefaultConfiguration(rootDir) {\n  return {\n    'application/javascript': {\n      \"presets\": [[\"env\", {\n        \"targets\": {\n          \"electron\": getElectronVersion(rootDir)\n        }\n      }], \"react\"],\n      \"sourceMaps\": \"inline\"\n    }\n  };\n}\n\n/**\n * Allows you to create new instances of all compilers that are supported by\n * electron-compile and use them directly. Currently supports Babel, CoffeeScript,\n * TypeScript, Less, and Jade.\n *\n * @return {Object}  An Object whose Keys are MIME types, and whose values\n * are instances of @{link CompilerBase}.\n */\nfunction createCompilers() {\n  if (!allCompilerClasses) {\n    // First we want to see if electron-compilers itself has been installed with\n    // devDependencies. If that's not the case, check to see if\n    // electron-compilers is installed as a peer dependency (probably as a\n    // devDependency of the root project).\n    const locations = ['electron-compilers', '../../electron-compilers'];\n\n    for (let location of locations) {\n      try {\n        allCompilerClasses = __webpack_require__(\"./node_modules/electron-compile/lib sync recursive\")(location);\n      } catch (e) {\n        // Yolo\n      }\n    }\n\n    if (!allCompilerClasses) {\n      throw new Error(\"Electron compilers not found but were requested to be loaded\");\n    }\n  }\n\n  // NB: Note that this code is carefully set up so that InlineHtmlCompiler\n  // (i.e. classes with `createFromCompilers`) initially get an empty object,\n  // but will have a reference to the final result of what we return, which\n  // resolves the circular dependency we'd otherwise have here.\n  let ret = {};\n  let instantiatedClasses = allCompilerClasses.map(Klass => {\n    if ('createFromCompilers' in Klass) {\n      return Klass.createFromCompilers(ret);\n    } else {\n      return new Klass();\n    }\n  });\n\n  instantiatedClasses.reduce((acc, x) => {\n    let Klass = Object.getPrototypeOf(x).constructor;\n\n    for (let type of Klass.getInputMimeTypes()) {\n      acc[type] = x;\n    }\n    return acc;\n  }, ret);\n\n  return ret;\n}\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9jb25maWctcGFyc2VyLmpzIl0sIm5hbWVzIjpbImZpbGUiLCJyb290Q2FjaGVEaXIiLCJzb3VyY2VNYXBQYXRoIiwiaW5mbyIsIkpTT04iLCJwYXJzZSIsInBmcyIsInJlYWRGaWxlIiwiYmFiZWwiLCJvdXJFbnYiLCJwcm9jZXNzIiwiZW52IiwiQkFCRUxfRU5WIiwiTk9ERV9FTlYiLCJhcHBSb290IiwicGF0aCIsImRpcm5hbWUiLCJjcmVhdGVDb21waWxlckhvc3RGcm9tQ29uZmlndXJhdGlvbiIsIm9wdGlvbnMiLCJnZXREZWZhdWx0Q29uZmlndXJhdGlvbiIsImNyZWF0ZUNvbXBpbGVySG9zdEZyb21CYWJlbFJjIiwiRUxFQ1RST05fQ09NUElMRV9FTlYiLCJjcmVhdGVDb21waWxlckhvc3RGcm9tQ29uZmlnRmlsZSIsInJvb3REaXIiLCJjb21waWxlcmMiLCJqb2luIiwic3RhdFN5bmNOb0V4Y2VwdGlvbiIsImQiLCJiYWJlbHJjIiwiY3JlYXRlQ29tcGlsZXJIb3N0RnJvbVByb2plY3RSb290IiwiaW5pdGlhbGl6ZUdsb2JhbEhvb2tzIiwiaW5pdCIsImNyZWF0ZUNvbXBpbGVySG9zdEZyb21CYWJlbFJjU3luYyIsImNyZWF0ZUNvbXBpbGVySG9zdEZyb21Db25maWdGaWxlU3luYyIsImNyZWF0ZUNvbXBpbGVySG9zdEZyb21Qcm9qZWN0Um9vdFN5bmMiLCJjYWxjdWxhdGVEZWZhdWx0Q29tcGlsZUNhY2hlRGlyZWN0b3J5IiwiY3JlYXRlQ29tcGlsZXJzIiwicmVxdWlyZSIsImFsbENvbXBpbGVyQ2xhc3NlcyIsImZzUGF0aCIsImZzIiwic3RhdFN5bmMiLCJlIiwiY29tcGlsZXJIb3N0IiwiaXNQcm9kdWN0aW9uIiwiZ2xvYmFsVmFyIiwiZ2xvYmFsIiwid2luZG93IiwiZ2xvYmFsQ29tcGlsZXJIb3N0IiwidHlwZSIsImFwcCIsImluaXRpYWxpemVQcm90b2NvbEhvb2siLCJwcm90b2lmeSIsImlzUmVhZHkiLCJvbiIsIm1haW5Nb2R1bGUiLCJwcm9kdWN0aW9uTW9kZSIsImNhY2hlRGlyIiwiQ29tcGlsZXJIb3N0IiwiY3JlYXRlUmVhZG9ubHlGcm9tQ29uZmlndXJhdGlvblN5bmMiLCJjYWNoZVBhdGgiLCJtYXBQYXRoIiwibWFpbiIsImNvbXBpbGVycyIsImNyZWF0ZVNvdXJjZU1hcERpcmVjdG9yeSIsInN0cmluZ2lmeSIsImZpbGVDaGFuZ2VDYWNoZSIsIkZpbGVDaGFuZ2VkQ2FjaGUiLCJjb21waWxlckluZm8iLCJqc29uIiwiZXhpc3RzU3luYyIsImJ1ZiIsInJlYWRGaWxlU3luYyIsInpsaWIiLCJndW56aXBTeW5jIiwibG9hZEZyb21EYXRhIiwiT2JqZWN0Iiwia2V5cyIsImZvckVhY2giLCJ4Iiwib3B0cyIsIkVycm9yIiwicGFzc3Rocm91Z2giLCJjb21waWxlck9wdGlvbnMiLCJyZXQiLCJtaW1lVHlwZXNUb1JlZ2lzdGVyIiwic2F2ZUNvbmZpZ3VyYXRpb25TeW5jIiwidG1wRGlyIiwiVEVNUCIsIlRNUERJUiIsImhhc2giLCJjcmVhdGVIYXNoIiwidXBkYXRlIiwiZXhlY1BhdGgiLCJkaWdlc3QiLCJta2RpcnAiLCJzeW5jIiwiZ2V0RWxlY3Ryb25WZXJzaW9uIiwidmVyc2lvbnMiLCJlbGVjdHJvbiIsIm91clBrZ0pzb24iLCJ2ZXJzaW9uIiwibWFwIiwibW9kIiwiZGV2RGVwZW5kZW5jaWVzIiwidmVyUmFuZ2UiLCJtIiwibWF0Y2giLCJwIiwiZmluZCIsImxvY2F0aW9ucyIsImxvY2F0aW9uIiwiaW5zdGFudGlhdGVkQ2xhc3NlcyIsIktsYXNzIiwiY3JlYXRlRnJvbUNvbXBpbGVycyIsInJlZHVjZSIsImFjYyIsImdldFByb3RvdHlwZU9mIiwiY29uc3RydWN0b3IiLCJnZXRJbnB1dE1pbWVUeXBlcyJdLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQTRKQTs7Ozs7Ozs7Ozs7K0JBVU8sV0FBNkNBLElBQTdDLEVBQTRGO0FBQUEsUUFBekNDLFlBQXlDLHVFQUE1QixJQUE0QjtBQUFBLFFBQXRCQyxhQUFzQix1RUFB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QUFDQTtBQUNBLE1BQUlHLE1BQU0sRUFBVjtBQUNBLE1BQUk0QixzQkFBc0IxRSxtQkFBbUJnRSxHQUFuQixDQUF3QlcsS0FBRCxJQUFXO0FBQzFELFFBQUkseUJBQXlCQSxLQUE3QixFQUFvQztBQUNsQyxhQUFPQSxNQUFNQyxtQkFBTixDQUEwQjlCLEdBQTFCLENBQVA7QUFDRCxLQUZELE1BRU87QUFDTCxhQUFPLElBQUk2QixLQUFKLEVBQVA7QUFDRDtBQUNGLEdBTnlCLENBQTFCOztBQVFBRCxzQkFBb0JHLE1BQXBCLENBQTJCLENBQUNDLEdBQUQsRUFBS3JDLENBQUwsS0FBVztBQUNwQyxRQUFJa0MsUUFBUXJDLE9BQU95QyxjQUFQLENBQXNCdEMsQ0FBdEIsRUFBeUJ1QyxXQUFyQzs7QUFFQSxTQUFLLElBQUlyRSxJQUFULElBQWlCZ0UsTUFBTU0saUJBQU4sRUFBakIsRUFBNEM7QUFBRUgsVUFBSW5FLElBQUosSUFBWThCLENBQVo7QUFBZ0I7QUFDOUQsV0FBT3FDLEdBQVA7QUFDRCxHQUxELEVBS0doQyxHQUxIOztBQU9BLFNBQU9BLEdBQVA7QUFDRCIsImZpbGUiOiJjb25maWctcGFyc2VyLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGZzIGZyb20gJ2ZzJztcbmltcG9ydCBwYXRoIGZyb20gJ3BhdGgnO1xuaW1wb3J0IHpsaWIgZnJvbSAnemxpYic7XG5pbXBvcnQgbWtkaXJwIGZyb20gJ21rZGlycCc7XG5pbXBvcnQge3Bmc30gZnJvbSAnLi9wcm9taXNlJztcblxuaW1wb3J0IEZpbGVDaGFuZ2VkQ2FjaGUgZnJvbSAnLi9maWxlLWNoYW5nZS1jYWNoZSc7XG5pbXBvcnQgQ29tcGlsZXJIb3N0IGZyb20gJy4vY29tcGlsZXItaG9zdCc7XG5pbXBvcnQgcmVnaXN0ZXJSZXF1aXJlRXh0ZW5zaW9uIGZyb20gJy4vcmVxdWlyZS1ob29rJztcblxuY29uc3QgZCA9IHJlcXVpcmUoJ2RlYnVnJykoJ2VsZWN0cm9uLWNvbXBpbGU6Y29uZmlnLXBhcnNlcicpO1xuXG4vLyBOQjogV2UgaW50ZW50aW9uYWxseSBkZWxheS1sb2FkIHRoaXMgc28gdGhhdCBpbiBwcm9kdWN0aW9uLCB5b3UgY2FuIGNyZWF0ZVxuLy8gY2FjaGUtb25seSB2ZXJzaW9ucyBvZiB0aGVzZSBjb21waWxlcnNcbmxldCBhbGxDb21waWxlckNsYXNzZXMgPSBudWxsO1xuXG5mdW5jdGlvbiBzdGF0U3luY05vRXhjZXB0aW9uKGZzUGF0aCkge1xuICBpZiAoJ3N0YXRTeW5jTm9FeGNlcHRpb24nIGluIGZzKSB7XG4gICAgcmV0dXJuIGZzLnN0YXRTeW5jTm9FeGNlcHRpb24oZnNQYXRoKTtcbiAgfVxuXG4gIHRyeSB7XG4gICAgcmV0dXJuIGZzLnN0YXRTeW5jKGZzUGF0aCk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuXG5cbi8qKlxuICogSW5pdGlhbGl6ZSB0aGUgZ2xvYmFsIGhvb2tzIChwcm90b2NvbCBob29rIGZvciBmaWxlOiwgbm9kZS5qcyBob29rKVxuICogaW5kZXBlbmRlbnQgb2YgaW5pdGlhbGl6aW5nIHRoZSBjb21waWxlci4gVGhpcyBtZXRob2QgaXMgdXN1YWxseSBjYWxsZWQgYnlcbiAqIGluaXQgaW5zdGVhZCBvZiBkaXJlY3RseVxuICpcbiAqIEBwYXJhbSB7Q29tcGlsZXJIb3N0fSBjb21waWxlckhvc3QgIFRoZSBjb21waWxlciBob3N0IHRvIHVzZS5cbiAqXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpbml0aWFsaXplR2xvYmFsSG9va3MoY29tcGlsZXJIb3N0LCBpc1Byb2R1Y3Rpb249ZmFsc2UpIHtcbiAgbGV0IGdsb2JhbFZhciA9IChnbG9iYWwgfHwgd2luZG93KTtcbiAgZ2xvYmFsVmFyLmdsb2JhbENvbXBpbGVySG9zdCA9IGNvbXBpbGVySG9zdDtcblxuICByZWdpc3RlclJlcXVpcmVFeHRlbnNpb24oY29tcGlsZXJIb3N0LCBpc1Byb2R1Y3Rpb24pO1xuXG4gIGlmICgndHlwZScgaW4gcHJvY2VzcyAmJiBwcm9jZXNzLnR5cGUgPT09ICdicm93c2VyJykge1xuICAgIGNvbnN0IHsgYXBwIH0gPSByZXF1aXJlKCdlbGVjdHJvbicpO1xuICAgIGNvbnN0IHsgaW5pdGlhbGl6ZVByb3RvY29sSG9vayB9ID0gcmVxdWlyZSgnLi9wcm90b2NvbC1ob29rJyk7XG5cbiAgICBsZXQgcHJvdG9pZnkgPSBmdW5jdGlvbigpIHsgaW5pdGlhbGl6ZVByb3RvY29sSG9vayhjb21waWxlckhvc3QpOyB9O1xuICAgIGlmIChhcHAuaXNSZWFkeSgpKSB7XG4gICAgICBwcm90b2lmeSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBhcHAub24oJ3JlYWR5JywgcHJvdG9pZnkpO1xuICAgIH1cbiAgfVxufVxuXG5cbi8qKlxuICogSW5pdGlhbGl6ZSBlbGVjdHJvbi1jb21waWxlIGFuZCBzZXQgaXQgdXAsIGVpdGhlciBmb3IgZGV2ZWxvcG1lbnQgb3JcbiAqIHByb2R1Y3Rpb24gdXNlLiBUaGlzIGlzIGFsbW9zdCBhbHdheXMgdGhlIG9ubHkgbWV0aG9kIHlvdSBuZWVkIHRvIHVzZSBpbiBvcmRlclxuICogdG8gdXNlIGVsZWN0cm9uLWNvbXBpbGUuXG4gKlxuICogQHBhcmFtICB7c3RyaW5nfSBhcHBSb290ICBUaGUgdG9wLWxldmVsIGRpcmVjdG9yeSBmb3IgeW91ciBhcHBsaWNhdGlvbiAoaS5lLlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICB0aGUgb25lIHdoaWNoIGhhcyB5b3VyIHBhY2thZ2UuanNvbikuXG4gKlxuICogQHBhcmFtICB7c3RyaW5nfSBtYWluTW9kdWxlICBUaGUgbW9kdWxlIHRvIHJlcXVpcmUgaW4sIHJlbGF0aXZlIHRvIHRoZSBtb2R1bGVcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGluZyBpbml0LCB0aGF0IHdpbGwgc3RhcnQgeW91ciBhcHAuIFdyaXRlIHRoaXNcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXMgaWYgeW91IHdlcmUgd3JpdGluZyBhIHJlcXVpcmUgY2FsbCBmcm9tIGhlcmUuXG4gKlxuICogQHBhcmFtICB7Ym9vbH0gcHJvZHVjdGlvbk1vZGUgICBJZiBleHBsaWNpdGx5IFRydWUvRmFsc2UsIHdpbGwgc2V0IHJlYWQtb25seVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtb2RlIHRvIGJlIGRpc2FibGVkL2VuYWJsZWQuIElmIG5vdCwgd2UnbGxcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ3Vlc3MgYmFzZWQgb24gdGhlIHByZXNlbmNlIG9mIGEgcHJvZHVjdGlvblxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWNoZS5cbiAqXG4gKiBAcGFyYW0gIHtzdHJpbmd9IGNhY2hlRGlyICBJZiBub3QgcGFzc2VkIGluLCByZWFkLW9ubHkgd2lsbCBsb29rIGluXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICBgYXBwUm9vdC8uY2FjaGVgIGFuZCBkZXYgbW9kZSB3aWxsIGNvbXBpbGUgdG8gYVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgdGVtcG9yYXJ5IGRpcmVjdG9yeS4gSWYgaXQgaXMgcGFzc2VkIGluLCBib3RoIG1vZGVzXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aWxsIGNhY2hlIHRvL2Zyb20gYGFwcFJvb3Qve2NhY2hlRGlyfWBcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gc291cmNlTWFwUGF0aCAob3B0aW9uYWwpIFRoZSBkaXJlY3RvcnkgdG8gc3RvcmUgc291cmNlbWFwIHNlcGFyYXRlbHlcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIGNvbXBpbGVyIG9wdGlvbiBlbmFibGVkIHRvIGVtaXQuXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBEZWZhdWx0IHRvIGNhY2hlUGF0aCBpZiBub3Qgc3BlY2lmaWVkLCB3aWxsIGJlIGlnbm9yZWQgZm9yIHJlYWQtb25seSBtb2RlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gaW5pdChhcHBSb290LCBtYWluTW9kdWxlLCBwcm9kdWN0aW9uTW9kZSA9IG51bGwsIGNhY2hlRGlyID0gbnVsbCwgc291cmNlTWFwUGF0aCA9IG51bGwpIHtcbiAgbGV0IGNvbXBpbGVySG9zdCA9IG51bGw7XG4gIGxldCByb290Q2FjaGVEaXIgPSBwYXRoLmpvaW4oYXBwUm9vdCwgY2FjaGVEaXIgfHwgJy5jYWNoZScpO1xuXG4gIGlmIChwcm9kdWN0aW9uTW9kZSA9PT0gbnVsbCkge1xuICAgIHByb2R1Y3Rpb25Nb2RlID0gISFzdGF0U3luY05vRXhjZXB0aW9uKHJvb3RDYWNoZURpcik7XG4gIH1cblxuICBpZiAocHJvZHVjdGlvbk1vZGUpIHtcbiAgICBjb21waWxlckhvc3QgPSBDb21waWxlckhvc3QuY3JlYXRlUmVhZG9ubHlGcm9tQ29uZmlndXJhdGlvblN5bmMocm9vdENhY2hlRGlyLCBhcHBSb290KTtcbiAgfSBlbHNlIHtcbiAgICAvLyBpZiBjYWNoZURpciB3YXMgcGFzc2VkIGluLCBwYXNzIGl0IGFsb25nLiBPdGhlcndpc2UsIGRlZmF1bHQgdG8gYSB0ZW1wZGlyLlxuICAgIGNvbnN0IGNhY2hlUGF0aCA9IGNhY2hlRGlyID8gcm9vdENhY2hlRGlyIDogbnVsbDtcbiAgICBjb25zdCBtYXBQYXRoID0gc291cmNlTWFwUGF0aCA/IHBhdGguam9pbihhcHBSb290LCBzb3VyY2VNYXBQYXRoKSA6IGNhY2hlUGF0aDtcbiAgICBjb21waWxlckhvc3QgPSBjcmVhdGVDb21waWxlckhvc3RGcm9tUHJvamVjdFJvb3RTeW5jKGFwcFJvb3QsIGNhY2hlUGF0aCwgbWFwUGF0aCk7XG4gIH1cblxuICBpbml0aWFsaXplR2xvYmFsSG9va3MoY29tcGlsZXJIb3N0LCBwcm9kdWN0aW9uTW9kZSk7XG4gIHJlcXVpcmUubWFpbi5yZXF1aXJlKG1haW5Nb2R1bGUpO1xufVxuXG5cbi8qKlxuICogQ3JlYXRlcyBhIHtAbGluayBDb21waWxlckhvc3R9IHdpdGggdGhlIGdpdmVuIGluZm9ybWF0aW9uLiBUaGlzIG1ldGhvZCBpc1xuICogdXN1YWxseSBjYWxsZWQgYnkge0BsaW5rIGNyZWF0ZUNvbXBpbGVySG9zdEZyb21Qcm9qZWN0Um9vdH0uXG4gKlxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUNvbXBpbGVySG9zdEZyb21Db25maWd1cmF0aW9uKGluZm8pIHtcbiAgbGV0IGNvbXBpbGVycyA9IGNyZWF0ZUNvbXBpbGVycygpO1xuICBsZXQgcm9vdENhY2hlRGlyID0gaW5mby5yb290Q2FjaGVEaXIgfHwgY2FsY3VsYXRlRGVmYXVsdENvbXBpbGVDYWNoZURpcmVjdG9yeSgpO1xuICBjb25zdCBzb3VyY2VNYXBQYXRoID0gaW5mby5zb3VyY2VNYXBQYXRoIHx8IGluZm8ucm9vdENhY2hlRGlyO1xuXG4gIGlmIChpbmZvLnNvdXJjZU1hcFBhdGgpIHtcbiAgICBjcmVhdGVTb3VyY2VNYXBEaXJlY3Rvcnkoc291cmNlTWFwUGF0aCk7XG4gIH1cblxuICBkKGBDcmVhdGluZyBDb21waWxlckhvc3Q6ICR7SlNPTi5zdHJpbmdpZnkoaW5mbyl9LCByb290Q2FjaGVEaXIgPSAke3Jvb3RDYWNoZURpcn0sIHNvdXJjZU1hcFBhdGggPSAke3NvdXJjZU1hcFBhdGh9YCk7XG4gIGxldCBmaWxlQ2hhbmdlQ2FjaGUgPSBuZXcgRmlsZUNoYW5nZWRDYWNoZShpbmZvLmFwcFJvb3QpO1xuXG4gIGxldCBjb21waWxlckluZm8gPSBwYXRoLmpvaW4ocm9vdENhY2hlRGlyLCAnY29tcGlsZXItaW5mby5qc29uLmd6Jyk7XG4gIGxldCBqc29uID0ge307XG4gIGlmIChmcy5leGlzdHNTeW5jKGNvbXBpbGVySW5mbykpIHtcbiAgICBsZXQgYnVmID0gZnMucmVhZEZpbGVTeW5jKGNvbXBpbGVySW5mbyk7XG4gICAganNvbiA9IEpTT04ucGFyc2UoemxpYi5ndW56aXBTeW5jKGJ1ZikpO1xuICAgIGZpbGVDaGFuZ2VDYWNoZSA9IEZpbGVDaGFuZ2VkQ2FjaGUubG9hZEZyb21EYXRhKGpzb24uZmlsZUNoYW5nZUNhY2hlLCBpbmZvLmFwcFJvb3QsIGZhbHNlKTtcbiAgfVxuXG4gIE9iamVjdC5rZXlzKGluZm8ub3B0aW9ucyB8fCB7fSkuZm9yRWFjaCgoeCkgPT4ge1xuICAgIGxldCBvcHRzID0gaW5mby5vcHRpb25zW3hdO1xuICAgIGlmICghKHggaW4gY29tcGlsZXJzKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBGb3VuZCBjb21waWxlciBzZXR0aW5ncyBmb3IgbWlzc2luZyBjb21waWxlcjogJHt4fWApO1xuICAgIH1cblxuICAgIC8vIE5COiBMZXQncyBob3BlIHRoaXMgaXNuJ3QgYSB2YWxpZCBjb21waWxlciBvcHRpb24uLi5cbiAgICBpZiAob3B0cy5wYXNzdGhyb3VnaCkge1xuICAgICAgY29tcGlsZXJzW3hdID0gY29tcGlsZXJzWyd0ZXh0L3BsYWluJ107XG4gICAgICBkZWxldGUgb3B0cy5wYXNzdGhyb3VnaDtcbiAgICB9XG5cbiAgICBkKGBTZXR0aW5nIG9wdGlvbnMgZm9yICR7eH06ICR7SlNPTi5zdHJpbmdpZnkob3B0cyl9YCk7XG4gICAgY29tcGlsZXJzW3hdLmNvbXBpbGVyT3B0aW9ucyA9IG9wdHM7XG4gIH0pO1xuXG4gIGxldCByZXQgPSBuZXcgQ29tcGlsZXJIb3N0KHJvb3RDYWNoZURpciwgY29tcGlsZXJzLCBmaWxlQ2hhbmdlQ2FjaGUsIGZhbHNlLCBjb21waWxlcnNbJ3RleHQvcGxhaW4nXSwgbnVsbCwganNvbi5taW1lVHlwZXNUb1JlZ2lzdGVyKTtcblxuICAvLyBOQjogSXQncyBzdXBlciBpbXBvcnRhbnQgdGhhdCB3ZSBndWFyYW50ZWUgdGhhdCB0aGUgY29uZmlndXJhdGlvbiBpcyBzYXZlZFxuICAvLyBvdXQsIGJlY2F1c2Ugd2UnbGwgbmVlZCB0byByZS1yZWFkIGl0IGluIHRoZSByZW5kZXJlciBwcm9jZXNzXG4gIGQoYENyZWF0ZWQgY29tcGlsZXIgaG9zdCB3aXRoIG9wdGlvbnM6ICR7SlNPTi5zdHJpbmdpZnkoaW5mbyl9YCk7XG4gIHJldC5zYXZlQ29uZmlndXJhdGlvblN5bmMoKTtcbiAgcmV0dXJuIHJldDtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgY29tcGlsZXIgaG9zdCBmcm9tIGEgLmJhYmVscmMgZmlsZS4gVGhpcyBtZXRob2QgaXMgdXN1YWxseSBjYWxsZWRcbiAqIGZyb20ge0BsaW5rIGNyZWF0ZUNvbXBpbGVySG9zdEZyb21Qcm9qZWN0Um9vdH0gaW5zdGVhZCBvZiB1c2VkIGRpcmVjdGx5LlxuICpcbiAqIEBwYXJhbSAge3N0cmluZ30gZmlsZSAgVGhlIHBhdGggdG8gYSAuYmFiZWxyYyBmaWxlXG4gKlxuICogQHBhcmFtICB7c3RyaW5nfSByb290Q2FjaGVEaXIgKG9wdGlvbmFsKSAgVGhlIGRpcmVjdG9yeSB0byB1c2UgYXMgYSBjYWNoZS5cbiAqXG4gKiBAcmV0dXJuIHtQcm9taXNlPENvbXBpbGVySG9zdD59ICBBIHNldC11cCBjb21waWxlciBob3N0XG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBjcmVhdGVDb21waWxlckhvc3RGcm9tQmFiZWxSYyhmaWxlLCByb290Q2FjaGVEaXI9bnVsbCwgc291cmNlTWFwUGF0aCA9IG51bGwpIHtcbiAgbGV0IGluZm8gPSBKU09OLnBhcnNlKGF3YWl0IHBmcy5yZWFkRmlsZShmaWxlLCAndXRmOCcpKTtcblxuICAvLyBwYWNrYWdlLmpzb25cbiAgaWYgKCdiYWJlbCcgaW4gaW5mbykge1xuICAgIGluZm8gPSBpbmZvLmJhYmVsO1xuICB9XG5cbiAgaWYgKCdlbnYnIGluIGluZm8pIHtcbiAgICBsZXQgb3VyRW52ID0gcHJvY2Vzcy5lbnYuQkFCRUxfRU5WIHx8IHByb2Nlc3MuZW52Lk5PREVfRU5WIHx8ICdkZXZlbG9wbWVudCc7XG4gICAgaW5mbyA9IGluZm8uZW52W291ckVudl07XG4gIH1cblxuICAvLyBBcmUgd2Ugc3RpbGwgcGFja2FnZS5qc29uIChpLmUuIGlzIHRoZXJlIG5vIGJhYmVsIGluZm8gd2hhdHNvZXZlcj8pXG4gIGlmICgnbmFtZScgaW4gaW5mbyAmJiAndmVyc2lvbicgaW4gaW5mbykge1xuICAgIGxldCBhcHBSb290ID0gcGF0aC5kaXJuYW1lKGZpbGUpO1xuICAgIHJldHVybiBjcmVhdGVDb21waWxlckhvc3RGcm9tQ29uZmlndXJhdGlvbih7XG4gICAgICBhcHBSb290OiBhcHBSb290LFxuICAgICAgb3B0aW9uczogZ2V0RGVmYXVsdENvbmZpZ3VyYXRpb24oYXBwUm9vdCksXG4gICAgICByb290Q2FjaGVEaXIsXG4gICAgICBzb3VyY2VNYXBQYXRoXG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gY3JlYXRlQ29tcGlsZXJIb3N0RnJvbUNvbmZpZ3VyYXRpb24oe1xuICAgIGFwcFJvb3Q6IHBhdGguZGlybmFtZShmaWxlKSxcbiAgICBvcHRpb25zOiB7XG4gICAgICAnYXBwbGljYXRpb24vamF2YXNjcmlwdCc6IGluZm9cbiAgICB9LFxuICAgIHJvb3RDYWNoZURpcixcbiAgICBzb3VyY2VNYXBQYXRoXG4gIH0pO1xufVxuXG5cbi8qKlxuICogQ3JlYXRlcyBhIGNvbXBpbGVyIGhvc3QgZnJvbSBhIC5jb21waWxlcmMgZmlsZS4gVGhpcyBtZXRob2QgaXMgdXN1YWxseSBjYWxsZWRcbiAqIGZyb20ge0BsaW5rIGNyZWF0ZUNvbXBpbGVySG9zdEZyb21Qcm9qZWN0Um9vdH0gaW5zdGVhZCBvZiB1c2VkIGRpcmVjdGx5LlxuICpcbiAqIEBwYXJhbSAge3N0cmluZ30gZmlsZSAgVGhlIHBhdGggdG8gYSAuY29tcGlsZXJjIGZpbGVcbiAqXG4gKiBAcGFyYW0gIHtzdHJpbmd9IHJvb3RDYWNoZURpciAob3B0aW9uYWwpICBUaGUgZGlyZWN0b3J5IHRvIHVzZSBhcyBhIGNhY2hlLlxuICpcbiAqIEByZXR1cm4ge1Byb21pc2U8Q29tcGlsZXJIb3N0Pn0gIEEgc2V0LXVwIGNvbXBpbGVyIGhvc3RcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGNyZWF0ZUNvbXBpbGVySG9zdEZyb21Db25maWdGaWxlKGZpbGUsIHJvb3RDYWNoZURpcj1udWxsLCBzb3VyY2VNYXBQYXRoID0gbnVsbCkge1xuICBsZXQgaW5mbyA9IEpTT04ucGFyc2UoYXdhaXQgcGZzLnJlYWRGaWxlKGZpbGUsICd1dGY4JykpO1xuXG4gIGlmICgnZW52JyBpbiBpbmZvKSB7XG4gICAgbGV0IG91ckVudiA9IHByb2Nlc3MuZW52LkVMRUNUUk9OX0NPTVBJTEVfRU5WIHx8IHByb2Nlc3MuZW52Lk5PREVfRU5WIHx8ICdkZXZlbG9wbWVudCc7XG4gICAgaW5mbyA9IGluZm8uZW52W291ckVudl07XG4gIH1cblxuICByZXR1cm4gY3JlYXRlQ29tcGlsZXJIb3N0RnJvbUNvbmZpZ3VyYXRpb24oe1xuICAgIGFwcFJvb3Q6IHBhdGguZGlybmFtZShmaWxlKSxcbiAgICBvcHRpb25zOiBpbmZvLFxuICAgIHJvb3RDYWNoZURpcixcbiAgICBzb3VyY2VNYXBQYXRoXG4gIH0pO1xufVxuXG5cbi8qKlxuICogQ3JlYXRlcyBhIGNvbmZpZ3VyZWQge0BsaW5rIENvbXBpbGVySG9zdH0gaW5zdGFuY2UgZnJvbSB0aGUgcHJvamVjdCByb290XG4gKiBkaXJlY3RvcnkuIFRoaXMgbWV0aG9kIGZpcnN0IHNlYXJjaGVzIGZvciBhIC5jb21waWxlcmMgKG9yIC5jb21waWxlcmMuanNvbiksIHRoZW4gZmFsbHMgYmFjayB0byB0aGVcbiAqIGRlZmF1bHQgbG9jYXRpb25zIGZvciBCYWJlbCBjb25maWd1cmF0aW9uIGluZm8uIElmIG5laXRoZXIgYXJlIGZvdW5kLCBkZWZhdWx0c1xuICogdG8gc3RhbmRhcmQgc2V0dGluZ3NcbiAqXG4gKiBAcGFyYW0gIHtzdHJpbmd9IHJvb3REaXIgIFRoZSByb290IGFwcGxpY2F0aW9uIGRpcmVjdG9yeSAoaS5lLiB0aGUgZGlyZWN0b3J5XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoYXQgaGFzIHRoZSBhcHAncyBwYWNrYWdlLmpzb24pXG4gKlxuICogQHBhcmFtICB7c3RyaW5nfSByb290Q2FjaGVEaXIgKG9wdGlvbmFsKSAgVGhlIGRpcmVjdG9yeSB0byB1c2UgYXMgYSBjYWNoZS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gc291cmNlTWFwUGF0aCAob3B0aW9uYWwpIFRoZSBkaXJlY3RvcnkgdG8gc3RvcmUgc291cmNlbWFwIHNlcGFyYXRlbHlcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIGNvbXBpbGVyIG9wdGlvbiBlbmFibGVkIHRvIGVtaXQuXG4gKlxuICogQHJldHVybiB7UHJvbWlzZTxDb21waWxlckhvc3Q+fSAgQSBzZXQtdXAgY29tcGlsZXIgaG9zdFxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gY3JlYXRlQ29tcGlsZXJIb3N0RnJvbVByb2plY3RSb290KHJvb3REaXIsIHJvb3RDYWNoZURpciA9IG51bGwsIHNvdXJjZU1hcFBhdGggPSBudWxsKSB7XG4gIGxldCBjb21waWxlcmMgPSBwYXRoLmpvaW4ocm9vdERpciwgJy5jb21waWxlcmMnKTtcbiAgaWYgKHN0YXRTeW5jTm9FeGNlcHRpb24oY29tcGlsZXJjKSkge1xuICAgIGQoYEZvdW5kIGEgLmNvbXBpbGVyYyBhdCAke2NvbXBpbGVyY30sIHVzaW5nIGl0YCk7XG4gICAgcmV0dXJuIGF3YWl0IGNyZWF0ZUNvbXBpbGVySG9zdEZyb21Db25maWdGaWxlKGNvbXBpbGVyYywgcm9vdENhY2hlRGlyLCBzb3VyY2VNYXBQYXRoKTtcbiAgfVxuICBjb21waWxlcmMgKz0gJy5qc29uJztcbiAgaWYgKHN0YXRTeW5jTm9FeGNlcHRpb24oY29tcGlsZXJjKSkge1xuICAgIGQoYEZvdW5kIGEgLmNvbXBpbGVyYyBhdCAke2NvbXBpbGVyY30sIHVzaW5nIGl0YCk7XG4gICAgcmV0dXJuIGF3YWl0IGNyZWF0ZUNvbXBpbGVySG9zdEZyb21Db25maWdGaWxlKGNvbXBpbGVyYywgcm9vdENhY2hlRGlyLCBzb3VyY2VNYXBQYXRoKTtcbiAgfVxuXG4gIGxldCBiYWJlbHJjID0gcGF0aC5qb2luKHJvb3REaXIsICcuYmFiZWxyYycpO1xuICBpZiAoc3RhdFN5bmNOb0V4Y2VwdGlvbihiYWJlbHJjKSkge1xuICAgIGQoYEZvdW5kIGEgLmJhYmVscmMgYXQgJHtiYWJlbHJjfSwgdXNpbmcgaXRgKTtcbiAgICByZXR1cm4gYXdhaXQgY3JlYXRlQ29tcGlsZXJIb3N0RnJvbUJhYmVsUmMoYmFiZWxyYywgcm9vdENhY2hlRGlyLCBzb3VyY2VNYXBQYXRoKTtcbiAgfVxuXG4gIGQoYFVzaW5nIHBhY2thZ2UuanNvbiBvciBkZWZhdWx0IHBhcmFtZXRlcnMgYXQgJHtyb290RGlyfWApO1xuICByZXR1cm4gYXdhaXQgY3JlYXRlQ29tcGlsZXJIb3N0RnJvbUJhYmVsUmMocGF0aC5qb2luKHJvb3REaXIsICdwYWNrYWdlLmpzb24nKSwgcm9vdENhY2hlRGlyLCBzb3VyY2VNYXBQYXRoKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUNvbXBpbGVySG9zdEZyb21CYWJlbFJjU3luYyhmaWxlLCByb290Q2FjaGVEaXI9bnVsbCwgc291cmNlTWFwUGF0aCA9IG51bGwpIHtcbiAgbGV0IGluZm8gPSBKU09OLnBhcnNlKGZzLnJlYWRGaWxlU3luYyhmaWxlLCAndXRmOCcpKTtcblxuICAvLyBwYWNrYWdlLmpzb25cbiAgaWYgKCdiYWJlbCcgaW4gaW5mbykge1xuICAgIGluZm8gPSBpbmZvLmJhYmVsO1xuICB9XG5cbiAgaWYgKCdlbnYnIGluIGluZm8pIHtcbiAgICBsZXQgb3VyRW52ID0gcHJvY2Vzcy5lbnYuQkFCRUxfRU5WIHx8IHByb2Nlc3MuZW52Lk5PREVfRU5WIHx8ICdkZXZlbG9wbWVudCc7XG4gICAgaW5mbyA9IGluZm8uZW52W291ckVudl07XG4gIH1cblxuICAvLyBBcmUgd2Ugc3RpbGwgcGFja2FnZS5qc29uIChpLmUuIGlzIHRoZXJlIG5vIGJhYmVsIGluZm8gd2hhdHNvZXZlcj8pXG4gIGlmICgnbmFtZScgaW4gaW5mbyAmJiAndmVyc2lvbicgaW4gaW5mbykge1xuICAgIGxldCBhcHBSb290ID0gcGF0aC5kaXJuYW1lKGZpbGUpXG4gICAgcmV0dXJuIGNyZWF0ZUNvbXBpbGVySG9zdEZyb21Db25maWd1cmF0aW9uKHtcbiAgICAgIGFwcFJvb3Q6IGFwcFJvb3QsXG4gICAgICBvcHRpb25zOiBnZXREZWZhdWx0Q29uZmlndXJhdGlvbihhcHBSb290KSxcbiAgICAgIHJvb3RDYWNoZURpcixcbiAgICAgIHNvdXJjZU1hcFBhdGhcbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiBjcmVhdGVDb21waWxlckhvc3RGcm9tQ29uZmlndXJhdGlvbih7XG4gICAgYXBwUm9vdDogcGF0aC5kaXJuYW1lKGZpbGUpLFxuICAgIG9wdGlvbnM6IHtcbiAgICAgICdhcHBsaWNhdGlvbi9qYXZhc2NyaXB0JzogaW5mb1xuICAgIH0sXG4gICAgcm9vdENhY2hlRGlyLFxuICAgIHNvdXJjZU1hcFBhdGhcbiAgfSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVDb21waWxlckhvc3RGcm9tQ29uZmlnRmlsZVN5bmMoZmlsZSwgcm9vdENhY2hlRGlyPW51bGwsIHNvdXJjZU1hcFBhdGggPSBudWxsKSB7XG4gIGxldCBpbmZvID0gSlNPTi5wYXJzZShmcy5yZWFkRmlsZVN5bmMoZmlsZSwgJ3V0ZjgnKSk7XG5cbiAgaWYgKCdlbnYnIGluIGluZm8pIHtcbiAgICBsZXQgb3VyRW52ID0gcHJvY2Vzcy5lbnYuRUxFQ1RST05fQ09NUElMRV9FTlYgfHwgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgfHwgJ2RldmVsb3BtZW50JztcbiAgICBpbmZvID0gaW5mby5lbnZbb3VyRW52XTtcbiAgfVxuXG4gIHJldHVybiBjcmVhdGVDb21waWxlckhvc3RGcm9tQ29uZmlndXJhdGlvbih7XG4gICAgYXBwUm9vdDogcGF0aC5kaXJuYW1lKGZpbGUpLFxuICAgIG9wdGlvbnM6IGluZm8sXG4gICAgcm9vdENhY2hlRGlyLFxuICAgIHNvdXJjZU1hcFBhdGhcbiAgfSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVDb21waWxlckhvc3RGcm9tUHJvamVjdFJvb3RTeW5jKHJvb3REaXIsIHJvb3RDYWNoZURpciA9IG51bGwsIHNvdXJjZU1hcFBhdGggPSBudWxsKSB7XG4gIGxldCBjb21waWxlcmMgPSBwYXRoLmpvaW4ocm9vdERpciwgJy5jb21waWxlcmMnKTtcbiAgaWYgKHN0YXRTeW5jTm9FeGNlcHRpb24oY29tcGlsZXJjKSkge1xuICAgIGQoYEZvdW5kIGEgLmNvbXBpbGVyYyBhdCAke2NvbXBpbGVyY30sIHVzaW5nIGl0YCk7XG4gICAgcmV0dXJuIGNyZWF0ZUNvbXBpbGVySG9zdEZyb21Db25maWdGaWxlU3luYyhjb21waWxlcmMsIHJvb3RDYWNoZURpciwgc291cmNlTWFwUGF0aCk7XG4gIH1cblxuICBsZXQgYmFiZWxyYyA9IHBhdGguam9pbihyb290RGlyLCAnLmJhYmVscmMnKTtcbiAgaWYgKHN0YXRTeW5jTm9FeGNlcHRpb24oYmFiZWxyYykpIHtcbiAgICBkKGBGb3VuZCBhIC5iYWJlbHJjIGF0ICR7YmFiZWxyY30sIHVzaW5nIGl0YCk7XG4gICAgcmV0dXJuIGNyZWF0ZUNvbXBpbGVySG9zdEZyb21CYWJlbFJjU3luYyhiYWJlbHJjLCByb290Q2FjaGVEaXIsIHNvdXJjZU1hcFBhdGgpO1xuICB9XG5cbiAgZChgVXNpbmcgcGFja2FnZS5qc29uIG9yIGRlZmF1bHQgcGFyYW1ldGVycyBhdCAke3Jvb3REaXJ9YCk7XG4gIHJldHVybiBjcmVhdGVDb21waWxlckhvc3RGcm9tQmFiZWxSY1N5bmMocGF0aC5qb2luKHJvb3REaXIsICdwYWNrYWdlLmpzb24nKSwgcm9vdENhY2hlRGlyLCBzb3VyY2VNYXBQYXRoKTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHdoYXQgZWxlY3Ryb24tY29tcGlsZSB3b3VsZCB1c2UgYXMgYSBkZWZhdWx0IHJvb3RDYWNoZURpci4gVXN1YWxseSBvbmx5XG4gKiB1c2VkIGZvciBkZWJ1Z2dpbmcgcHVycG9zZXNcbiAqXG4gKiBAcmV0dXJuIHtzdHJpbmd9ICBBIHBhdGggdGhhdCBtYXkgb3IgbWF5IG5vdCBleGlzdCB3aGVyZSBlbGVjdHJvbi1jb21waWxlIHdvdWxkXG4gKiAgICAgICAgICAgICAgICAgICBzZXQgdXAgYSBkZXZlbG9wbWVudCBtb2RlIGNhY2hlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY2FsY3VsYXRlRGVmYXVsdENvbXBpbGVDYWNoZURpcmVjdG9yeSgpIHtcbiAgbGV0IHRtcERpciA9IHByb2Nlc3MuZW52LlRFTVAgfHwgcHJvY2Vzcy5lbnYuVE1QRElSIHx8ICcvdG1wJztcbiAgbGV0IGhhc2ggPSByZXF1aXJlKCdjcnlwdG8nKS5jcmVhdGVIYXNoKCdtZDUnKS51cGRhdGUocHJvY2Vzcy5leGVjUGF0aCkuZGlnZXN0KCdoZXgnKTtcblxuICBsZXQgY2FjaGVEaXIgPSBwYXRoLmpvaW4odG1wRGlyLCBgY29tcGlsZUNhY2hlXyR7aGFzaH1gKTtcbiAgbWtkaXJwLnN5bmMoY2FjaGVEaXIpO1xuXG4gIGQoYFVzaW5nIGRlZmF1bHQgY2FjaGUgZGlyZWN0b3J5OiAke2NhY2hlRGlyfWApO1xuICByZXR1cm4gY2FjaGVEaXI7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVNvdXJjZU1hcERpcmVjdG9yeShzb3VyY2VNYXBQYXRoKSB7XG4gIG1rZGlycC5zeW5jKHNvdXJjZU1hcFBhdGgpO1xuICBkKGBVc2luZyBzZXBhcmF0ZSBzb3VyY2VtYXAgcGF0aCBhdCAke3NvdXJjZU1hcFBhdGh9YCk7XG59XG5cbmZ1bmN0aW9uIGdldEVsZWN0cm9uVmVyc2lvbihyb290RGlyKSB7XG4gIGlmIChwcm9jZXNzLnZlcnNpb25zLmVsZWN0cm9uKSB7XG4gICAgcmV0dXJuIHByb2Nlc3MudmVyc2lvbnMuZWxlY3Ryb247XG4gIH1cblxuICBsZXQgb3VyUGtnSnNvbiA9IHJlcXVpcmUocGF0aC5qb2luKHJvb3REaXIsICdwYWNrYWdlLmpzb24nKSk7XG5cbiAgbGV0IHZlcnNpb24gPSBbJ2VsZWN0cm9uLXByZWJ1aWx0LWNvbXBpbGUnLCAnZWxlY3Ryb24nXS5tYXAobW9kID0+IHtcbiAgICBpZiAob3VyUGtnSnNvbi5kZXZEZXBlbmRlbmNpZXMgJiYgb3VyUGtnSnNvbi5kZXZEZXBlbmRlbmNpZXNbbW9kXSkge1xuICAgICAgLy8gTkI6IGxvbCB0aGlzIGNvZGVcbiAgICAgIGxldCB2ZXJSYW5nZSA9IG91clBrZ0pzb24uZGV2RGVwZW5kZW5jaWVzW21vZF07XG4gICAgICBsZXQgbSA9IHZlclJhbmdlLm1hdGNoKC8oXFxkK1xcLlxcZCtcXC5cXGQrKS8pO1xuICAgICAgaWYgKG0gJiYgbVsxXSkgcmV0dXJuIG1bMV07XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBwcm9jZXNzLm1haW5Nb2R1bGUucmVxdWlyZShgJHttb2R9L3BhY2thZ2UuanNvbmApLnZlcnNpb247XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgLy8gTkI6IFRoaXMgdXN1YWxseSBkb2Vzbid0IHdvcmssIGJ1dCBzb21ldGltZXMgbWF5YmU/XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIGxldCBwID0gcGF0aC5qb2luKHJvb3REaXIsIG1vZCwgJ3BhY2thZ2UuanNvbicpO1xuICAgICAgcmV0dXJuIHJlcXVpcmUocCkudmVyc2lvbjtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH0pLmZpbmQoeCA9PiAhIXgpO1xuXG4gIGlmICghdmVyc2lvbikge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkNhbid0IGF1dG9tYXRpY2FsbHkgZGlzY292ZXIgdGhlIHZlcnNpb24gb2YgRWxlY3Ryb24sIHlvdSBwcm9iYWJseSBuZWVkIGEgLmNvbXBpbGVyYyBmaWxlXCIpO1xuICB9XG5cbiAgcmV0dXJuIHZlcnNpb247XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgZGVmYXVsdCAuY29uZmlncmMgaWYgbm8gY29uZmlndXJhdGlvbiBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQuXG4gKlxuICogQHJldHVybiB7T2JqZWN0fSAgQSBsaXN0IG9mIGRlZmF1bHQgY29uZmlnIHNldHRpbmdzIGZvciBlbGVjdHJvbi1jb21waWxlci5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldERlZmF1bHRDb25maWd1cmF0aW9uKHJvb3REaXIpIHtcbiAgcmV0dXJuIHtcbiAgICAnYXBwbGljYXRpb24vamF2YXNjcmlwdCc6IHtcbiAgICAgIFwicHJlc2V0c1wiOiBbXG4gICAgICAgIFtcImVudlwiLCB7XG4gICAgICAgICAgXCJ0YXJnZXRzXCI6IHtcbiAgICAgICAgICAgIFwiZWxlY3Ryb25cIjogZ2V0RWxlY3Ryb25WZXJzaW9uKHJvb3REaXIpXG4gICAgICAgICAgfVxuICAgICAgICB9XSxcbiAgICAgICAgXCJyZWFjdFwiXG4gICAgICBdLFxuICAgICAgXCJzb3VyY2VNYXBzXCI6IFwiaW5saW5lXCJcbiAgICB9XG4gIH07XG59XG5cbi8qKlxuICogQWxsb3dzIHlvdSB0byBjcmVhdGUgbmV3IGluc3RhbmNlcyBvZiBhbGwgY29tcGlsZXJzIHRoYXQgYXJlIHN1cHBvcnRlZCBieVxuICogZWxlY3Ryb24tY29tcGlsZSBhbmQgdXNlIHRoZW0gZGlyZWN0bHkuIEN1cnJlbnRseSBzdXBwb3J0cyBCYWJlbCwgQ29mZmVlU2NyaXB0LFxuICogVHlwZVNjcmlwdCwgTGVzcywgYW5kIEphZGUuXG4gKlxuICogQHJldHVybiB7T2JqZWN0fSAgQW4gT2JqZWN0IHdob3NlIEtleXMgYXJlIE1JTUUgdHlwZXMsIGFuZCB3aG9zZSB2YWx1ZXNcbiAqIGFyZSBpbnN0YW5jZXMgb2YgQHtsaW5rIENvbXBpbGVyQmFzZX0uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVDb21waWxlcnMoKSB7XG4gIGlmICghYWxsQ29tcGlsZXJDbGFzc2VzKSB7XG4gICAgLy8gRmlyc3Qgd2Ugd2FudCB0byBzZWUgaWYgZWxlY3Ryb24tY29tcGlsZXJzIGl0c2VsZiBoYXMgYmVlbiBpbnN0YWxsZWQgd2l0aFxuICAgIC8vIGRldkRlcGVuZGVuY2llcy4gSWYgdGhhdCdzIG5vdCB0aGUgY2FzZSwgY2hlY2sgdG8gc2VlIGlmXG4gICAgLy8gZWxlY3Ryb24tY29tcGlsZXJzIGlzIGluc3RhbGxlZCBhcyBhIHBlZXIgZGVwZW5kZW5jeSAocHJvYmFibHkgYXMgYVxuICAgIC8vIGRldkRlcGVuZGVuY3kgb2YgdGhlIHJvb3QgcHJvamVjdCkuXG4gICAgY29uc3QgbG9jYXRpb25zID0gWydlbGVjdHJvbi1jb21waWxlcnMnLCAnLi4vLi4vZWxlY3Ryb24tY29tcGlsZXJzJ107XG5cbiAgICBmb3IgKGxldCBsb2NhdGlvbiBvZiBsb2NhdGlvbnMpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGFsbENvbXBpbGVyQ2xhc3NlcyA9IHJlcXVpcmUobG9jYXRpb24pO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAvLyBZb2xvXG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCFhbGxDb21waWxlckNsYXNzZXMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkVsZWN0cm9uIGNvbXBpbGVycyBub3QgZm91bmQgYnV0IHdlcmUgcmVxdWVzdGVkIHRvIGJlIGxvYWRlZFwiKTtcbiAgICB9XG4gIH1cblxuICAvLyBOQjogTm90ZSB0aGF0IHRoaXMgY29kZSBpcyBjYXJlZnVsbHkgc2V0IHVwIHNvIHRoYXQgSW5saW5lSHRtbENvbXBpbGVyXG4gIC8vIChpLmUuIGNsYXNzZXMgd2l0aCBgY3JlYXRlRnJvbUNvbXBpbGVyc2ApIGluaXRpYWxseSBnZXQgYW4gZW1wdHkgb2JqZWN0LFxuICAvLyBidXQgd2lsbCBoYXZlIGEgcmVmZXJlbmNlIHRvIHRoZSBmaW5hbCByZXN1bHQgb2Ygd2hhdCB3ZSByZXR1cm4sIHdoaWNoXG4gIC8vIHJlc29sdmVzIHRoZSBjaXJjdWxhciBkZXBlbmRlbmN5IHdlJ2Qgb3RoZXJ3aXNlIGhhdmUgaGVyZS5cbiAgbGV0IHJldCA9IHt9O1xuICBsZXQgaW5zdGFudGlhdGVkQ2xhc3NlcyA9IGFsbENvbXBpbGVyQ2xhc3Nlcy5tYXAoKEtsYXNzKSA9PiB7XG4gICAgaWYgKCdjcmVhdGVGcm9tQ29tcGlsZXJzJyBpbiBLbGFzcykge1xuICAgICAgcmV0dXJuIEtsYXNzLmNyZWF0ZUZyb21Db21waWxlcnMocmV0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG5ldyBLbGFzcygpO1xuICAgIH1cbiAgfSk7XG5cbiAgaW5zdGFudGlhdGVkQ2xhc3Nlcy5yZWR1Y2UoKGFjYyx4KSA9PiB7XG4gICAgbGV0IEtsYXNzID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHgpLmNvbnN0cnVjdG9yO1xuXG4gICAgZm9yIChsZXQgdHlwZSBvZiBLbGFzcy5nZXRJbnB1dE1pbWVUeXBlcygpKSB7IGFjY1t0eXBlXSA9IHg7IH1cbiAgICByZXR1cm4gYWNjO1xuICB9LCByZXQpO1xuXG4gIHJldHVybiByZXQ7XG59XG4iXX0=\n\n//# sourceURL=webpack:///./node_modules/electron-compile/lib/config-parser.js?")},"./node_modules/electron-compile/lib/custom-operators.js":
/*!***************************************************************!*\
  !*** ./node_modules/electron-compile/lib/custom-operators.js ***!
  \***************************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){"use strict";eval('\n\nvar _Observable = __webpack_require__(/*! rxjs/Observable */ "./node_modules/electron-compile/node_modules/rxjs/Observable.js");\n\nvar _async = __webpack_require__(/*! rxjs/scheduler/async */ "./node_modules/electron-compile/node_modules/rxjs/scheduler/async.js");\n\n__webpack_require__(/*! rxjs/add/observable/range */ "./node_modules/electron-compile/node_modules/rxjs/add/observable/range.js");\n\n__webpack_require__(/*! rxjs/add/observable/throw */ "./node_modules/electron-compile/node_modules/rxjs/add/observable/throw.js");\n\n__webpack_require__(/*! rxjs/add/observable/timer */ "./node_modules/electron-compile/node_modules/rxjs/add/observable/timer.js");\n\n__webpack_require__(/*! rxjs/add/operator/mergeMap */ "./node_modules/electron-compile/node_modules/rxjs/add/operator/mergeMap.js");\n\n__webpack_require__(/*! rxjs/add/operator/map */ "./node_modules/electron-compile/node_modules/rxjs/add/operator/map.js");\n\n__webpack_require__(/*! rxjs/add/operator/retryWhen */ "./node_modules/electron-compile/node_modules/rxjs/add/operator/retryWhen.js");\n\n__webpack_require__(/*! rxjs/add/operator/switch */ "./node_modules/electron-compile/node_modules/rxjs/add/operator/switch.js");\n\n__webpack_require__(/*! rxjs/add/operator/zip */ "./node_modules/electron-compile/node_modules/rxjs/add/operator/zip.js");\n\nfunction retryWithDelayOrError(errors, maxRetries) {\n  return _Observable.Observable.range(1, maxRetries + 1).zip(errors, (i, e) => {\n    return { attempts: i, error: e };\n  }).mergeMap((_ref) => {\n    let attempts = _ref.attempts,\n        error = _ref.error;\n\n    return attempts <= maxRetries ? _Observable.Observable.timer(attempts * 1000) : _Observable.Observable.throw(error);\n  });\n}\n\nconst newCoolOperators = {\n  guaranteedThrottle: function (time) {\n    let scheduler = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _async.async;\n\n    return this.map(x => _Observable.Observable.timer(time, scheduler).map(() => x)).switch();\n  },\n\n  retryAtIntervals: function () {\n    let maxRetries = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 3;\n\n    return this.retryWhen(errors => retryWithDelayOrError(errors, maxRetries));\n  }\n};\n\nfor (const key of Object.keys(newCoolOperators)) {\n  _Observable.Observable.prototype[key] = newCoolOperators[key];\n}\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9jdXN0b20tb3BlcmF0b3JzLmpzIl0sIm5hbWVzIjpbInJldHJ5V2l0aERlbGF5T3JFcnJvciIsImVycm9ycyIsIm1heFJldHJpZXMiLCJPYnNlcnZhYmxlIiwicmFuZ2UiLCJ6aXAiLCJpIiwiZSIsImF0dGVtcHRzIiwiZXJyb3IiLCJtZXJnZU1hcCIsInRpbWVyIiwidGhyb3ciLCJuZXdDb29sT3BlcmF0b3JzIiwiZ3VhcmFudGVlZFRocm90dGxlIiwidGltZSIsInNjaGVkdWxlciIsImFzeW5jIiwibWFwIiwieCIsInN3aXRjaCIsInJldHJ5QXRJbnRlcnZhbHMiLCJyZXRyeVdoZW4iLCJrZXkiLCJPYmplY3QiLCJrZXlzIiwicHJvdG90eXBlIl0sIm1hcHBpbmdzIjoiOztBQUFBOztBQUNBOztBQUVBOztBQUNBOztBQUNBOztBQUVBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUVBLFNBQVNBLHFCQUFULENBQStCQyxNQUEvQixFQUF1Q0MsVUFBdkMsRUFBbUQ7QUFDakQsU0FBT0MsdUJBQVdDLEtBQVgsQ0FBaUIsQ0FBakIsRUFBb0JGLGFBQWEsQ0FBakMsRUFDSkcsR0FESSxDQUNBSixNQURBLEVBQ1EsQ0FBQ0ssQ0FBRCxFQUFJQyxDQUFKLEtBQVU7QUFDckIsV0FBTyxFQUFFQyxVQUFVRixDQUFaLEVBQWVHLE9BQU9GLENBQXRCLEVBQVA7QUFDRCxHQUhJLEVBSUpHLFFBSkksQ0FJSyxVQUF1QjtBQUFBLFFBQXJCRixRQUFxQixRQUFyQkEsUUFBcUI7QUFBQSxRQUFYQyxLQUFXLFFBQVhBLEtBQVc7O0FBQy9CLFdBQU9ELFlBQVlOLFVBQVosR0FDTEMsdUJBQVdRLEtBQVgsQ0FBaUJILFdBQVcsSUFBNUIsQ0FESyxHQUVMTCx1QkFBV1MsS0FBWCxDQUFpQkgsS0FBakIsQ0FGRjtBQUdELEdBUkksQ0FBUDtBQVNEOztBQUVELE1BQU1JLG1CQUFtQjtBQUN2QkMsc0JBQW9CLFVBQVNDLElBQVQsRUFBa0M7QUFBQSxRQUFuQkMsU0FBbUIsdUVBQVBDLFlBQU87O0FBQ3BELFdBQU8sS0FDSkMsR0FESSxDQUNDQyxDQUFELElBQU9oQix1QkFBV1EsS0FBWCxDQUFpQkksSUFBakIsRUFBdUJDLFNBQXZCLEVBQWtDRSxHQUFsQyxDQUFzQyxNQUFNQyxDQUE1QyxDQURQLEVBRUpDLE1BRkksRUFBUDtBQUdELEdBTHNCOztBQU92QkMsb0JBQWtCLFlBQXlCO0FBQUEsUUFBaEJuQixVQUFnQix1RUFBSCxDQUFHOztBQUN6QyxXQUFPLEtBQUtvQixTQUFMLENBQWdCckIsTUFBRCxJQUFZRCxzQkFBc0JDLE1BQXRCLEVBQThCQyxVQUE5QixDQUEzQixDQUFQO0FBQ0Q7QUFUc0IsQ0FBekI7O0FBYUEsS0FBSyxNQUFNcUIsR0FBWCxJQUFrQkMsT0FBT0MsSUFBUCxDQUFZWixnQkFBWixDQUFsQixFQUFpRDtBQUMvQ1YseUJBQVd1QixTQUFYLENBQXFCSCxHQUFyQixJQUE0QlYsaUJBQWlCVSxHQUFqQixDQUE1QjtBQUNEIiwiZmlsZSI6ImN1c3RvbS1vcGVyYXRvcnMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge09ic2VydmFibGV9IGZyb20gJ3J4anMvT2JzZXJ2YWJsZSc7XG5pbXBvcnQge2FzeW5jfSBmcm9tICdyeGpzL3NjaGVkdWxlci9hc3luYyc7XG5cbmltcG9ydCAncnhqcy9hZGQvb2JzZXJ2YWJsZS9yYW5nZSc7XG5pbXBvcnQgJ3J4anMvYWRkL29ic2VydmFibGUvdGhyb3cnO1xuaW1wb3J0ICdyeGpzL2FkZC9vYnNlcnZhYmxlL3RpbWVyJztcblxuaW1wb3J0ICdyeGpzL2FkZC9vcGVyYXRvci9tZXJnZU1hcCc7XG5pbXBvcnQgJ3J4anMvYWRkL29wZXJhdG9yL21hcCc7XG5pbXBvcnQgJ3J4anMvYWRkL29wZXJhdG9yL3JldHJ5V2hlbic7XG5pbXBvcnQgJ3J4anMvYWRkL29wZXJhdG9yL3N3aXRjaCc7XG5pbXBvcnQgJ3J4anMvYWRkL29wZXJhdG9yL3ppcCc7XG5cbmZ1bmN0aW9uIHJldHJ5V2l0aERlbGF5T3JFcnJvcihlcnJvcnMsIG1heFJldHJpZXMpIHtcbiAgcmV0dXJuIE9ic2VydmFibGUucmFuZ2UoMSwgbWF4UmV0cmllcyArIDEpXG4gICAgLnppcChlcnJvcnMsIChpLCBlKSA9PiB7XG4gICAgICByZXR1cm4geyBhdHRlbXB0czogaSwgZXJyb3I6IGUgfTtcbiAgICB9KVxuICAgIC5tZXJnZU1hcCgoe2F0dGVtcHRzLCBlcnJvcn0pID0+IHtcbiAgICAgIHJldHVybiBhdHRlbXB0cyA8PSBtYXhSZXRyaWVzID9cbiAgICAgICAgT2JzZXJ2YWJsZS50aW1lcihhdHRlbXB0cyAqIDEwMDApIDpcbiAgICAgICAgT2JzZXJ2YWJsZS50aHJvdyhlcnJvcik7XG4gICAgfSk7XG59XG5cbmNvbnN0IG5ld0Nvb2xPcGVyYXRvcnMgPSB7XG4gIGd1YXJhbnRlZWRUaHJvdHRsZTogZnVuY3Rpb24odGltZSwgc2NoZWR1bGVyID0gYXN5bmMpIHtcbiAgICByZXR1cm4gdGhpc1xuICAgICAgLm1hcCgoeCkgPT4gT2JzZXJ2YWJsZS50aW1lcih0aW1lLCBzY2hlZHVsZXIpLm1hcCgoKSA9PiB4KSlcbiAgICAgIC5zd2l0Y2goKTtcbiAgfSxcblxuICByZXRyeUF0SW50ZXJ2YWxzOiBmdW5jdGlvbihtYXhSZXRyaWVzID0gMykge1xuICAgIHJldHVybiB0aGlzLnJldHJ5V2hlbigoZXJyb3JzKSA9PiByZXRyeVdpdGhEZWxheU9yRXJyb3IoZXJyb3JzLCBtYXhSZXRyaWVzKSk7XG4gIH0sXG59O1xuXG5cbmZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKG5ld0Nvb2xPcGVyYXRvcnMpKSB7XG4gIE9ic2VydmFibGUucHJvdG90eXBlW2tleV0gPSBuZXdDb29sT3BlcmF0b3JzW2tleV07XG59XG4iXX0=\n\n//# sourceURL=webpack:///./node_modules/electron-compile/lib/custom-operators.js?')},"./node_modules/electron-compile/lib/digest-for-object.js":
/*!****************************************************************!*\
  !*** ./node_modules/electron-compile/lib/digest-for-object.js ***!
  \****************************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){"use strict";eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = createDigestForObject;\n\nvar _crypto = __webpack_require__(/*! crypto */ \"crypto\");\n\nvar _crypto2 = _interopRequireDefault(_crypto);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction updateDigestForJsonValue(shasum, value) {\n  // Implmentation is similar to that of pretty-printing a JSON object, except:\n  // * Strings are not escaped.\n  // * No effort is made to avoid trailing commas.\n  // These shortcuts should not affect the correctness of this function.\n  const type = typeof value;\n\n  if (type === 'string') {\n    shasum.update('\"', 'utf8');\n    shasum.update(value, 'utf8');\n    shasum.update('\"', 'utf8');\n    return;\n  }\n\n  if (type === 'boolean' || type === 'number') {\n    shasum.update(value.toString(), 'utf8');\n    return;\n  }\n\n  if (!value) {\n    shasum.update('null', 'utf8');\n    return;\n  }\n\n  if (Array.isArray(value)) {\n    shasum.update('[', 'utf8');\n    for (let i = 0; i < value.length; i++) {\n      updateDigestForJsonValue(shasum, value[i]);\n      shasum.update(',', 'utf8');\n    }\n    shasum.update(']', 'utf8');\n    return;\n  }\n\n  // value must be an object: be sure to sort the keys.\n  let keys = Object.keys(value);\n  keys.sort();\n\n  shasum.update('{', 'utf8');\n\n  for (let i = 0; i < keys.length; i++) {\n    updateDigestForJsonValue(shasum, keys[i]);\n    shasum.update(': ', 'utf8');\n    updateDigestForJsonValue(shasum, value[keys[i]]);\n    shasum.update(',', 'utf8');\n  }\n\n  shasum.update('}', 'utf8');\n}\n\n/**\n * Creates a hash from a JS object\n * \n * @private  \n */\nfunction createDigestForObject(obj) {\n  let sha1 = _crypto2.default.createHash('sha1');\n  updateDigestForJsonValue(sha1, obj);\n\n  return sha1.digest('hex');\n}\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9kaWdlc3QtZm9yLW9iamVjdC5qcyJdLCJuYW1lcyI6WyJjcmVhdGVEaWdlc3RGb3JPYmplY3QiLCJ1cGRhdGVEaWdlc3RGb3JKc29uVmFsdWUiLCJzaGFzdW0iLCJ2YWx1ZSIsInR5cGUiLCJ1cGRhdGUiLCJ0b1N0cmluZyIsIkFycmF5IiwiaXNBcnJheSIsImkiLCJsZW5ndGgiLCJrZXlzIiwiT2JqZWN0Iiwic29ydCIsIm9iaiIsInNoYTEiLCJjcnlwdG8iLCJjcmVhdGVIYXNoIiwiZGlnZXN0Il0sIm1hcHBpbmdzIjoiOzs7OztrQkEwRHdCQSxxQjs7QUExRHhCOzs7Ozs7QUFFQSxTQUFTQyx3QkFBVCxDQUFrQ0MsTUFBbEMsRUFBMENDLEtBQTFDLEVBQWlEO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTUMsT0FBTyxPQUFPRCxLQUFwQjs7QUFFQSxNQUFJQyxTQUFTLFFBQWIsRUFBdUI7QUFDckJGLFdBQU9HLE1BQVAsQ0FBYyxHQUFkLEVBQW1CLE1BQW5CO0FBQ0FILFdBQU9HLE1BQVAsQ0FBY0YsS0FBZCxFQUFxQixNQUFyQjtBQUNBRCxXQUFPRyxNQUFQLENBQWMsR0FBZCxFQUFtQixNQUFuQjtBQUNBO0FBQ0Q7O0FBRUQsTUFBSUQsU0FBUyxTQUFULElBQXNCQSxTQUFTLFFBQW5DLEVBQTZDO0FBQzNDRixXQUFPRyxNQUFQLENBQWNGLE1BQU1HLFFBQU4sRUFBZCxFQUFnQyxNQUFoQztBQUNBO0FBQ0Q7O0FBRUQsTUFBSSxDQUFDSCxLQUFMLEVBQVk7QUFDVkQsV0FBT0csTUFBUCxDQUFjLE1BQWQsRUFBc0IsTUFBdEI7QUFDQTtBQUNEOztBQUVELE1BQUlFLE1BQU1DLE9BQU4sQ0FBY0wsS0FBZCxDQUFKLEVBQTBCO0FBQ3hCRCxXQUFPRyxNQUFQLENBQWMsR0FBZCxFQUFtQixNQUFuQjtBQUNBLFNBQUssSUFBSUksSUFBRSxDQUFYLEVBQWNBLElBQUlOLE1BQU1PLE1BQXhCLEVBQWdDRCxHQUFoQyxFQUFxQztBQUNuQ1IsK0JBQXlCQyxNQUF6QixFQUFpQ0MsTUFBTU0sQ0FBTixDQUFqQztBQUNBUCxhQUFPRyxNQUFQLENBQWMsR0FBZCxFQUFtQixNQUFuQjtBQUNEO0FBQ0RILFdBQU9HLE1BQVAsQ0FBYyxHQUFkLEVBQW1CLE1BQW5CO0FBQ0E7QUFDRDs7QUFFRDtBQUNBLE1BQUlNLE9BQU9DLE9BQU9ELElBQVAsQ0FBWVIsS0FBWixDQUFYO0FBQ0FRLE9BQUtFLElBQUw7O0FBRUFYLFNBQU9HLE1BQVAsQ0FBYyxHQUFkLEVBQW1CLE1BQW5COztBQUVBLE9BQUssSUFBSUksSUFBRSxDQUFYLEVBQWNBLElBQUlFLEtBQUtELE1BQXZCLEVBQStCRCxHQUEvQixFQUFvQztBQUNsQ1IsNkJBQXlCQyxNQUF6QixFQUFpQ1MsS0FBS0YsQ0FBTCxDQUFqQztBQUNBUCxXQUFPRyxNQUFQLENBQWMsSUFBZCxFQUFvQixNQUFwQjtBQUNBSiw2QkFBeUJDLE1BQXpCLEVBQWlDQyxNQUFNUSxLQUFLRixDQUFMLENBQU4sQ0FBakM7QUFDQVAsV0FBT0csTUFBUCxDQUFjLEdBQWQsRUFBbUIsTUFBbkI7QUFDRDs7QUFFREgsU0FBT0csTUFBUCxDQUFjLEdBQWQsRUFBbUIsTUFBbkI7QUFDRDs7QUFHRDs7Ozs7QUFLZSxTQUFTTCxxQkFBVCxDQUErQmMsR0FBL0IsRUFBb0M7QUFDakQsTUFBSUMsT0FBT0MsaUJBQU9DLFVBQVAsQ0FBa0IsTUFBbEIsQ0FBWDtBQUNBaEIsMkJBQXlCYyxJQUF6QixFQUErQkQsR0FBL0I7O0FBRUEsU0FBT0MsS0FBS0csTUFBTCxDQUFZLEtBQVosQ0FBUDtBQUNEIiwiZmlsZSI6ImRpZ2VzdC1mb3Itb2JqZWN0LmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGNyeXB0byBmcm9tICdjcnlwdG8nO1xuXG5mdW5jdGlvbiB1cGRhdGVEaWdlc3RGb3JKc29uVmFsdWUoc2hhc3VtLCB2YWx1ZSkge1xuICAvLyBJbXBsbWVudGF0aW9uIGlzIHNpbWlsYXIgdG8gdGhhdCBvZiBwcmV0dHktcHJpbnRpbmcgYSBKU09OIG9iamVjdCwgZXhjZXB0OlxuICAvLyAqIFN0cmluZ3MgYXJlIG5vdCBlc2NhcGVkLlxuICAvLyAqIE5vIGVmZm9ydCBpcyBtYWRlIHRvIGF2b2lkIHRyYWlsaW5nIGNvbW1hcy5cbiAgLy8gVGhlc2Ugc2hvcnRjdXRzIHNob3VsZCBub3QgYWZmZWN0IHRoZSBjb3JyZWN0bmVzcyBvZiB0aGlzIGZ1bmN0aW9uLlxuICBjb25zdCB0eXBlID0gdHlwZW9mKHZhbHVlKTtcblxuICBpZiAodHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICBzaGFzdW0udXBkYXRlKCdcIicsICd1dGY4Jyk7XG4gICAgc2hhc3VtLnVwZGF0ZSh2YWx1ZSwgJ3V0ZjgnKTtcbiAgICBzaGFzdW0udXBkYXRlKCdcIicsICd1dGY4Jyk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKHR5cGUgPT09ICdib29sZWFuJyB8fCB0eXBlID09PSAnbnVtYmVyJykge1xuICAgIHNoYXN1bS51cGRhdGUodmFsdWUudG9TdHJpbmcoKSwgJ3V0ZjgnKTtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoIXZhbHVlKSB7XG4gICAgc2hhc3VtLnVwZGF0ZSgnbnVsbCcsICd1dGY4Jyk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgc2hhc3VtLnVwZGF0ZSgnWycsICd1dGY4Jyk7XG4gICAgZm9yIChsZXQgaT0wOyBpIDwgdmFsdWUubGVuZ3RoOyBpKyspIHtcbiAgICAgIHVwZGF0ZURpZ2VzdEZvckpzb25WYWx1ZShzaGFzdW0sIHZhbHVlW2ldKTtcbiAgICAgIHNoYXN1bS51cGRhdGUoJywnLCAndXRmOCcpO1xuICAgIH1cbiAgICBzaGFzdW0udXBkYXRlKCddJywgJ3V0ZjgnKTtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyB2YWx1ZSBtdXN0IGJlIGFuIG9iamVjdDogYmUgc3VyZSB0byBzb3J0IHRoZSBrZXlzLlxuICBsZXQga2V5cyA9IE9iamVjdC5rZXlzKHZhbHVlKTtcbiAga2V5cy5zb3J0KCk7XG5cbiAgc2hhc3VtLnVwZGF0ZSgneycsICd1dGY4Jyk7XG5cbiAgZm9yIChsZXQgaT0wOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgIHVwZGF0ZURpZ2VzdEZvckpzb25WYWx1ZShzaGFzdW0sIGtleXNbaV0pO1xuICAgIHNoYXN1bS51cGRhdGUoJzogJywgJ3V0ZjgnKTtcbiAgICB1cGRhdGVEaWdlc3RGb3JKc29uVmFsdWUoc2hhc3VtLCB2YWx1ZVtrZXlzW2ldXSk7XG4gICAgc2hhc3VtLnVwZGF0ZSgnLCcsICd1dGY4Jyk7XG4gIH1cblxuICBzaGFzdW0udXBkYXRlKCd9JywgJ3V0ZjgnKTtcbn1cblxuXG4vKipcbiAqIENyZWF0ZXMgYSBoYXNoIGZyb20gYSBKUyBvYmplY3RcbiAqIFxuICogQHByaXZhdGUgIFxuICovIFxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gY3JlYXRlRGlnZXN0Rm9yT2JqZWN0KG9iaikge1xuICBsZXQgc2hhMSA9IGNyeXB0by5jcmVhdGVIYXNoKCdzaGExJyk7XG4gIHVwZGF0ZURpZ2VzdEZvckpzb25WYWx1ZShzaGExLCBvYmopO1xuICBcbiAgcmV0dXJuIHNoYTEuZGlnZXN0KCdoZXgnKTtcbn1cbiJdfQ==\n\n//# sourceURL=webpack:///./node_modules/electron-compile/lib/digest-for-object.js?")},"./node_modules/electron-compile/lib/file-change-cache.js":
/*!****************************************************************!*\
  !*** ./node_modules/electron-compile/lib/file-change-cache.js ***!
  \****************************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){"use strict";eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _fs = __webpack_require__(/*! fs */ \"fs\");\n\nvar _fs2 = _interopRequireDefault(_fs);\n\nvar _zlib = __webpack_require__(/*! zlib */ \"zlib\");\n\nvar _zlib2 = _interopRequireDefault(_zlib);\n\nvar _crypto = __webpack_require__(/*! crypto */ \"crypto\");\n\nvar _crypto2 = _interopRequireDefault(_crypto);\n\nvar _promise = __webpack_require__(/*! ./promise */ \"./node_modules/electron-compile/lib/promise.js\");\n\nvar _sanitizePaths = __webpack_require__(/*! ./sanitize-paths */ \"./node_modules/electron-compile/lib/sanitize-paths.js\");\n\nvar _sanitizePaths2 = _interopRequireDefault(_sanitizePaths);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step(\"next\", value); }, function (err) { step(\"throw\", err); }); } } return step(\"next\"); }); }; }\n\nconst d = __webpack_require__(/*! debug */ \"./node_modules/debug/src/index.js\")('electron-compile:file-change-cache');\n\n/**\n * This class caches information about files and determines whether they have\n * changed contents or not. Most importantly, this class caches the hash of seen\n * files so that at development time, we don't have to recalculate them constantly.\n *\n * This class is also the core of how electron-compile runs quickly in production\n * mode - after precompilation, the cache is serialized along with the rest of the\n * data in {@link CompilerHost}, so that when we load the app in production mode,\n * we don't end up calculating hashes of file content at all, only using the contents\n * of this cache.\n */\nclass FileChangedCache {\n  constructor(appRoot) {\n    let failOnCacheMiss = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n    this.appRoot = (0, _sanitizePaths2.default)(appRoot);\n\n    this.failOnCacheMiss = failOnCacheMiss;\n    this.changeCache = {};\n  }\n\n  static removePrefix(needle, haystack) {\n    let idx = haystack.toLowerCase().indexOf(needle.toLowerCase());\n    if (idx < 0) return haystack;\n\n    return haystack.substring(idx + needle.length);\n  }\n\n  /**\n   * Allows you to create a FileChangedCache from serialized data saved from\n   * {@link getSavedData}.\n   *\n   * @param  {Object} data  Saved data from getSavedData.\n   *\n   * @param  {string} appRoot  The top-level directory for your application (i.e.\n   *                           the one which has your package.json).\n   *\n   * @param  {boolean} failOnCacheMiss (optional)  If True, cache misses will throw.\n   *\n   * @return {FileChangedCache}\n   */\n  static loadFromData(data, appRoot) {\n    let failOnCacheMiss = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n\n    let ret = new FileChangedCache(appRoot, failOnCacheMiss);\n    ret.changeCache = data.changeCache;\n    ret.originalAppRoot = data.appRoot;\n\n    return ret;\n  }\n\n  /**\n   * Allows you to create a FileChangedCache from serialized data saved from\n   * {@link save}.\n   *\n   * @param  {string} file  Saved data from save.\n   *\n   * @param  {string} appRoot  The top-level directory for your application (i.e.\n   *                           the one which has your package.json).\n   *\n   * @param  {boolean} failOnCacheMiss (optional)  If True, cache misses will throw.\n   *\n   * @return {Promise<FileChangedCache>}\n   */\n  static loadFromFile(file, appRoot) {\n    let failOnCacheMiss = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n    return _asyncToGenerator(function* () {\n      d(`Loading canned FileChangedCache from ${file}`);\n\n      let buf = yield _promise.pfs.readFile(file);\n      return FileChangedCache.loadFromData(JSON.parse((yield _promise.pzlib.gunzip(buf))), appRoot, failOnCacheMiss);\n    })();\n  }\n\n  /**\n   * Returns information about a given file, including its hash. This method is\n   * the main method for this cache.\n   *\n   * @param  {string} absoluteFilePath  The path to a file to retrieve info on.\n   *\n   * @return {Promise<Object>}\n   *\n   * @property {string} hash  The SHA1 hash of the file\n   * @property {boolean} isMinified  True if the file is minified\n   * @property {boolean} isInNodeModules  True if the file is in a library directory\n   * @property {boolean} hasSourceMap  True if the file has a source map\n   * @property {boolean} isFileBinary  True if the file is not a text file\n   * @property {Buffer} binaryData (optional)  The buffer that was read if the file\n   *                                           was binary and there was a cache miss.\n   * @property {string} code (optional)  The string that was read if the file\n   *                                     was text and there was a cache miss\n   */\n  getHashForPath(absoluteFilePath) {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      var _getCacheEntryForPath = _this.getCacheEntryForPath(absoluteFilePath);\n\n      let cacheEntry = _getCacheEntryForPath.cacheEntry,\n          cacheKey = _getCacheEntryForPath.cacheKey;\n\n\n      if (_this.failOnCacheMiss) {\n        return cacheEntry.info;\n      }\n\n      var _ref = yield _this.getInfoForCacheEntry(absoluteFilePath);\n\n      let ctime = _ref.ctime,\n          size = _ref.size;\n\n\n      if (cacheEntry) {\n        let fileHasChanged = yield _this.hasFileChanged(absoluteFilePath, cacheEntry, { ctime, size });\n\n        if (!fileHasChanged) {\n          return cacheEntry.info;\n        }\n\n        d(`Invalidating cache entry: ${cacheEntry.ctime} === ${ctime} && ${cacheEntry.size} === ${size}`);\n        delete _this.changeCache.cacheEntry;\n      }\n\n      var _ref2 = yield _this.calculateHashForFile(absoluteFilePath);\n\n      let digest = _ref2.digest,\n          sourceCode = _ref2.sourceCode,\n          binaryData = _ref2.binaryData;\n\n\n      let info = {\n        hash: digest,\n        isMinified: FileChangedCache.contentsAreMinified(sourceCode || ''),\n        isInNodeModules: FileChangedCache.isInNodeModules(absoluteFilePath),\n        hasSourceMap: FileChangedCache.hasSourceMap(sourceCode || ''),\n        isFileBinary: !!binaryData\n      };\n\n      _this.changeCache[cacheKey] = { ctime, size, info };\n      d(`Cache entry for ${cacheKey}: ${JSON.stringify(_this.changeCache[cacheKey])}`);\n\n      if (binaryData) {\n        return Object.assign({ binaryData }, info);\n      } else {\n        return Object.assign({ sourceCode }, info);\n      }\n    })();\n  }\n\n  getInfoForCacheEntry(absoluteFilePath) {\n    return _asyncToGenerator(function* () {\n      let stat = yield _promise.pfs.stat(absoluteFilePath);\n      if (!stat || !stat.isFile()) throw new Error(`Can't stat ${absoluteFilePath}`);\n\n      return {\n        stat,\n        ctime: stat.ctime.getTime(),\n        size: stat.size\n      };\n    })();\n  }\n\n  /**\n   * Gets the cached data for a file path, if it exists.\n   *\n   * @param  {string} absoluteFilePath  The path to a file to retrieve info on.\n   *\n   * @return {Object}\n   */\n  getCacheEntryForPath(absoluteFilePath) {\n    let cacheKey = (0, _sanitizePaths2.default)(absoluteFilePath);\n    if (this.appRoot) {\n      cacheKey = cacheKey.replace(this.appRoot, '');\n    }\n\n    // NB: We do this because x-require will include an absolute path from the\n    // original built app and we need to still grok it\n    if (this.originalAppRoot) {\n      cacheKey = cacheKey.replace(this.originalAppRoot, '');\n    }\n\n    let cacheEntry = this.changeCache[cacheKey];\n\n    if (this.failOnCacheMiss) {\n      if (!cacheEntry) {\n        d(`Tried to read file cache entry for ${absoluteFilePath}`);\n        d(`cacheKey: ${cacheKey}, appRoot: ${this.appRoot}, originalAppRoot: ${this.originalAppRoot}`);\n        throw new Error(`Asked for ${absoluteFilePath} but it was not precompiled!`);\n      }\n    }\n\n    return { cacheEntry, cacheKey };\n  }\n\n  /**\n   * Checks the file cache to see if a file has changed.\n   *\n   * @param  {string} absoluteFilePath  The path to a file to retrieve info on.\n   * @param  {Object} cacheEntry  Cache data from {@link getCacheEntryForPath}\n   *\n   * @return {boolean}\n   */\n  hasFileChanged(absoluteFilePath) {\n    var _this2 = this;\n\n    let cacheEntry = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    let fileHashInfo = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n    return _asyncToGenerator(function* () {\n      cacheEntry = cacheEntry || _this2.getCacheEntryForPath(absoluteFilePath).cacheEntry;\n      fileHashInfo = fileHashInfo || (yield _this2.getInfoForCacheEntry(absoluteFilePath));\n\n      if (cacheEntry) {\n        return !(cacheEntry.ctime >= fileHashInfo.ctime && cacheEntry.size === fileHashInfo.size);\n      }\n\n      return false;\n    })();\n  }\n\n  /**\n   * Returns data that can passed to {@link loadFromData} to rehydrate this cache.\n   *\n   * @return {Object}\n   */\n  getSavedData() {\n    return { changeCache: this.changeCache, appRoot: this.appRoot };\n  }\n\n  /**\n   * Serializes this object's data to a file.\n   *\n   * @param {string} filePath  The path to save data to.\n   *\n   * @return {Promise} Completion.\n   */\n  save(filePath) {\n    var _this3 = this;\n\n    return _asyncToGenerator(function* () {\n      let toSave = _this3.getSavedData();\n\n      let buf = yield _promise.pzlib.gzip(new Buffer(JSON.stringify(toSave)));\n      yield _promise.pfs.writeFile(filePath, buf);\n    })();\n  }\n\n  calculateHashForFile(absoluteFilePath) {\n    return _asyncToGenerator(function* () {\n      let buf = yield _promise.pfs.readFile(absoluteFilePath);\n      let encoding = FileChangedCache.detectFileEncoding(buf);\n\n      if (!encoding) {\n        let digest = _crypto2.default.createHash('sha1').update(buf).digest('hex');\n        return { sourceCode: null, digest, binaryData: buf };\n      }\n\n      let sourceCode = yield _promise.pfs.readFile(absoluteFilePath, encoding);\n      let digest = _crypto2.default.createHash('sha1').update(sourceCode, 'utf8').digest('hex');\n\n      return { sourceCode, digest, binaryData: null };\n    })();\n  }\n\n  getHashForPathSync(absoluteFilePath) {\n    let cacheKey = (0, _sanitizePaths2.default)(absoluteFilePath);\n\n    if (this.appRoot) {\n      cacheKey = FileChangedCache.removePrefix(this.appRoot, cacheKey);\n    }\n\n    // NB: We do this because x-require will include an absolute path from the\n    // original built app and we need to still grok it\n    if (this.originalAppRoot) {\n      cacheKey = FileChangedCache.removePrefix(this.originalAppRoot, cacheKey);\n    }\n\n    let cacheEntry = this.changeCache[cacheKey];\n\n    if (this.failOnCacheMiss) {\n      if (!cacheEntry) {\n        d(`Tried to read file cache entry for ${absoluteFilePath}`);\n        d(`cacheKey: ${cacheKey}, appRoot: ${this.appRoot}, originalAppRoot: ${this.originalAppRoot}`);\n        throw new Error(`Asked for ${absoluteFilePath} but it was not precompiled!`);\n      }\n\n      return cacheEntry.info;\n    }\n\n    let stat = _fs2.default.statSync(absoluteFilePath);\n    let ctime = stat.ctime.getTime();\n    let size = stat.size;\n    if (!stat || !stat.isFile()) throw new Error(`Can't stat ${absoluteFilePath}`);\n\n    if (cacheEntry) {\n      if (cacheEntry.ctime >= ctime && cacheEntry.size === size) {\n        return cacheEntry.info;\n      }\n\n      d(`Invalidating cache entry: ${cacheEntry.ctime} === ${ctime} && ${cacheEntry.size} === ${size}`);\n      delete this.changeCache.cacheEntry;\n    }\n\n    var _calculateHashForFile = this.calculateHashForFileSync(absoluteFilePath);\n\n    let digest = _calculateHashForFile.digest,\n        sourceCode = _calculateHashForFile.sourceCode,\n        binaryData = _calculateHashForFile.binaryData;\n\n\n    let info = {\n      hash: digest,\n      isMinified: FileChangedCache.contentsAreMinified(sourceCode || ''),\n      isInNodeModules: FileChangedCache.isInNodeModules(absoluteFilePath),\n      hasSourceMap: FileChangedCache.hasSourceMap(sourceCode || ''),\n      isFileBinary: !!binaryData\n    };\n\n    this.changeCache[cacheKey] = { ctime, size, info };\n    d(`Cache entry for ${cacheKey}: ${JSON.stringify(this.changeCache[cacheKey])}`);\n\n    if (binaryData) {\n      return Object.assign({ binaryData }, info);\n    } else {\n      return Object.assign({ sourceCode }, info);\n    }\n  }\n\n  saveSync(filePath) {\n    let toSave = this.getSavedData();\n\n    let buf = _zlib2.default.gzipSync(new Buffer(JSON.stringify(toSave)));\n    _fs2.default.writeFileSync(filePath, buf);\n  }\n\n  calculateHashForFileSync(absoluteFilePath) {\n    let buf = _fs2.default.readFileSync(absoluteFilePath);\n    let encoding = FileChangedCache.detectFileEncoding(buf);\n\n    if (!encoding) {\n      let digest = _crypto2.default.createHash('sha1').update(buf).digest('hex');\n      return { sourceCode: null, digest, binaryData: buf };\n    }\n\n    let sourceCode = _fs2.default.readFileSync(absoluteFilePath, encoding);\n    let digest = _crypto2.default.createHash('sha1').update(sourceCode, 'utf8').digest('hex');\n\n    return { sourceCode, digest, binaryData: null };\n  }\n\n  /**\n   * Determines via some statistics whether a file is likely to be minified.\n   *\n   * @private\n   */\n  static contentsAreMinified(source) {\n    let length = source.length;\n    if (length > 1024) length = 1024;\n\n    let newlineCount = 0;\n\n    // Roll through the characters and determine the average line length\n    for (let i = 0; i < source.length; i++) {\n      if (source[i] === '\\n') newlineCount++;\n    }\n\n    // No Newlines? Any file other than a super small one is minified\n    if (newlineCount === 0) {\n      return length > 80;\n    }\n\n    let avgLineLength = length / newlineCount;\n    return avgLineLength > 80;\n  }\n\n  /**\n   * Determines whether a path is in node_modules or the Electron init code\n   *\n   * @private\n   */\n  static isInNodeModules(filePath) {\n    return !!(filePath.match(/(node_modules|bower_components)[\\\\\\/]/i) || filePath.match(/(atom|electron)\\.asar/));\n  }\n\n  /**\n   * Returns whether a file has an inline source map\n   *\n   * @private\n   */\n  static hasSourceMap(sourceCode) {\n    const trimmed = sourceCode.trim();\n    return trimmed.lastIndexOf('//# sourceMap') > trimmed.lastIndexOf('\\n');\n  }\n\n  /**\n   * Determines the encoding of a file from the two most common encodings by trying\n   * to decode it then looking for encoding errors\n   *\n   * @private\n   */\n  static detectFileEncoding(buffer) {\n    if (buffer.length < 1) return false;\n    let buf = buffer.length < 4096 ? buffer : buffer.slice(0, 4096);\n\n    const encodings = ['utf8', 'utf16le'];\n\n    let encoding;\n    if (buffer.length <= 128) {\n      encoding = encodings.find(x => Buffer.compare(new Buffer(buffer.toString(), x), buffer) === 0);\n    } else {\n      encoding = encodings.find(x => !FileChangedCache.containsControlCharacters(buf.toString(x)));\n    }\n\n    return encoding;\n  }\n\n  /**\n   * Determines whether a string is likely to be poorly encoded by looking for\n   * control characters above a certain threshold\n   *\n   * @private\n   */\n  static containsControlCharacters(str) {\n    let controlCount = 0;\n    let spaceCount = 0;\n    let threshold = 2;\n    if (str.length > 64) threshold = 4;\n    if (str.length > 512) threshold = 8;\n\n    for (let i = 0; i < str.length; i++) {\n      let c = str.charCodeAt(i);\n      if (c === 65536 || c < 8) controlCount++;\n      if (c > 14 && c < 32) controlCount++;\n      if (c === 32) spaceCount++;\n\n      if (controlCount > threshold) return true;\n    }\n\n    if (spaceCount < threshold) return true;\n\n    if (controlCount === 0) return false;\n    return controlCount / str.length < 0.02;\n  }\n}\nexports.default = FileChangedCache;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9maWxlLWNoYW5nZS1jYWNoZS5qcyJdLCJuYW1lcyI6WyJkIiwicmVxdWlyZSIsIkZpbGVDaGFuZ2VkQ2FjaGUiLCJjb25zdHJ1Y3RvciIsImFwcFJvb3QiLCJmYWlsT25DYWNoZU1pc3MiLCJjaGFuZ2VDYWNoZSIsInJlbW92ZVByZWZpeCIsIm5lZWRsZSIsImhheXN0YWNrIiwiaWR4IiwidG9Mb3dlckNhc2UiLCJpbmRleE9mIiwic3Vic3RyaW5nIiwibGVuZ3RoIiwibG9hZEZyb21EYXRhIiwiZGF0YSIsInJldCIsIm9yaWdpbmFsQXBwUm9vdCIsImxvYWRGcm9tRmlsZSIsImZpbGUiLCJidWYiLCJwZnMiLCJyZWFkRmlsZSIsIkpTT04iLCJwYXJzZSIsInB6bGliIiwiZ3VuemlwIiwiZ2V0SGFzaEZvclBhdGgiLCJhYnNvbHV0ZUZpbGVQYXRoIiwiZ2V0Q2FjaGVFbnRyeUZvclBhdGgiLCJjYWNoZUVudHJ5IiwiY2FjaGVLZXkiLCJpbmZvIiwiZ2V0SW5mb0ZvckNhY2hlRW50cnkiLCJjdGltZSIsInNpemUiLCJmaWxlSGFzQ2hhbmdlZCIsImhhc0ZpbGVDaGFuZ2VkIiwiY2FsY3VsYXRlSGFzaEZvckZpbGUiLCJkaWdlc3QiLCJzb3VyY2VDb2RlIiwiYmluYXJ5RGF0YSIsImhhc2giLCJpc01pbmlmaWVkIiwiY29udGVudHNBcmVNaW5pZmllZCIsImlzSW5Ob2RlTW9kdWxlcyIsImhhc1NvdXJjZU1hcCIsImlzRmlsZUJpbmFyeSIsInN0cmluZ2lmeSIsIk9iamVjdCIsImFzc2lnbiIsInN0YXQiLCJpc0ZpbGUiLCJFcnJvciIsImdldFRpbWUiLCJyZXBsYWNlIiwiZmlsZUhhc2hJbmZvIiwiZ2V0U2F2ZWREYXRhIiwic2F2ZSIsImZpbGVQYXRoIiwidG9TYXZlIiwiZ3ppcCIsIkJ1ZmZlciIsIndyaXRlRmlsZSIsImVuY29kaW5nIiwiZGV0ZWN0RmlsZUVuY29kaW5nIiwiY3J5cHRvIiwiY3JlYXRlSGFzaCIsInVwZGF0ZSIsImdldEhhc2hGb3JQYXRoU3luYyIsImZzIiwic3RhdFN5bmMiLCJjYWxjdWxhdGVIYXNoRm9yRmlsZVN5bmMiLCJzYXZlU3luYyIsInpsaWIiLCJnemlwU3luYyIsIndyaXRlRmlsZVN5bmMiLCJyZWFkRmlsZVN5bmMiLCJzb3VyY2UiLCJuZXdsaW5lQ291bnQiLCJpIiwiYXZnTGluZUxlbmd0aCIsIm1hdGNoIiwidHJpbW1lZCIsInRyaW0iLCJsYXN0SW5kZXhPZiIsImJ1ZmZlciIsInNsaWNlIiwiZW5jb2RpbmdzIiwiZmluZCIsIngiLCJjb21wYXJlIiwidG9TdHJpbmciLCJjb250YWluc0NvbnRyb2xDaGFyYWN0ZXJzIiwic3RyIiwiY29udHJvbENvdW50Iiwic3BhY2VDb3VudCIsInRocmVzaG9sZCIsImMiLCJjaGFyQ29kZUF0Il0sIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7QUFDQTs7Ozs7Ozs7QUFFQSxNQUFNQSxJQUFJQyxRQUFRLE9BQVIsRUFBaUIsb0NBQWpCLENBQVY7O0FBRUE7Ozs7Ozs7Ozs7O0FBV2UsTUFBTUMsZ0JBQU4sQ0FBdUI7QUFDcENDLGNBQVlDLE9BQVosRUFBNEM7QUFBQSxRQUF2QkMsZUFBdUIsdUVBQVAsS0FBTzs7QUFDMUMsU0FBS0QsT0FBTCxHQUFlLDZCQUFpQkEsT0FBakIsQ0FBZjs7QUFFQSxTQUFLQyxlQUFMLEdBQXVCQSxlQUF2QjtBQUNBLFNBQUtDLFdBQUwsR0FBbUIsRUFBbkI7QUFDRDs7QUFFRCxTQUFPQyxZQUFQLENBQW9CQyxNQUFwQixFQUE0QkMsUUFBNUIsRUFBc0M7QUFDcEMsUUFBSUMsTUFBTUQsU0FBU0UsV0FBVCxHQUF1QkMsT0FBdkIsQ0FBK0JKLE9BQU9HLFdBQVAsRUFBL0IsQ0FBVjtBQUNBLFFBQUlELE1BQU0sQ0FBVixFQUFhLE9BQU9ELFFBQVA7O0FBRWIsV0FBT0EsU0FBU0ksU0FBVCxDQUFtQkgsTUFBTUYsT0FBT00sTUFBaEMsQ0FBUDtBQUNEOztBQUVEOzs7Ozs7Ozs7Ozs7O0FBYUEsU0FBT0Ms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QWEsRUFBakIsRUFBcUJvRixZQUFZLENBQVo7QUFDckIsUUFBSUgsSUFBSWpGLE1BQUosR0FBYSxHQUFqQixFQUFzQm9GLFlBQVksQ0FBWjs7QUFFdEIsU0FBSyxJQUFJakIsSUFBRSxDQUFYLEVBQWNBLElBQUljLElBQUlqRixNQUF0QixFQUE4Qm1FLEdBQTlCLEVBQW1DO0FBQ2pDLFVBQUlrQixJQUFJSixJQUFJSyxVQUFKLENBQWVuQixDQUFmLENBQVI7QUFDQSxVQUFJa0IsTUFBTSxLQUFOLElBQWVBLElBQUksQ0FBdkIsRUFBMEJIO0FBQzFCLFVBQUlHLElBQUksRUFBSixJQUFVQSxJQUFJLEVBQWxCLEVBQXNCSDtBQUN0QixVQUFJRyxNQUFNLEVBQVYsRUFBY0Y7O0FBRWQsVUFBSUQsZUFBZUUsU0FBbkIsRUFBOEIsT0FBTyxJQUFQO0FBQy9COztBQUVELFFBQUlELGFBQWFDLFNBQWpCLEVBQTRCLE9BQU8sSUFBUDs7QUFFNUIsUUFBSUYsaUJBQWlCLENBQXJCLEVBQXdCLE9BQU8sS0FBUDtBQUN4QixXQUFRQSxlQUFlRCxJQUFJakYsTUFBcEIsR0FBOEIsSUFBckM7QUFDRDtBQTFZbUM7a0JBQWpCWixnQiIsImZpbGUiOiJmaWxlLWNoYW5nZS1jYWNoZS5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBmcyBmcm9tICdmcyc7XG5pbXBvcnQgemxpYiBmcm9tICd6bGliJztcbmltcG9ydCBjcnlwdG8gZnJvbSAnY3J5cHRvJztcbmltcG9ydCB7cGZzLCBwemxpYn0gZnJvbSAnLi9wcm9taXNlJztcbmltcG9ydCBzYW5pdGl6ZUZpbGVQYXRoIGZyb20gJy4vc2FuaXRpemUtcGF0aHMnO1xuXG5jb25zdCBkID0gcmVxdWlyZSgnZGVidWcnKSgnZWxlY3Ryb24tY29tcGlsZTpmaWxlLWNoYW5nZS1jYWNoZScpO1xuXG4vKipcbiAqIFRoaXMgY2xhc3MgY2FjaGVzIGluZm9ybWF0aW9uIGFib3V0IGZpbGVzIGFuZCBkZXRlcm1pbmVzIHdoZXRoZXIgdGhleSBoYXZlXG4gKiBjaGFuZ2VkIGNvbnRlbnRzIG9yIG5vdC4gTW9zdCBpbXBvcnRhbnRseSwgdGhpcyBjbGFzcyBjYWNoZXMgdGhlIGhhc2ggb2Ygc2VlblxuICogZmlsZXMgc28gdGhhdCBhdCBkZXZlbG9wbWVudCB0aW1lLCB3ZSBkb24ndCBoYXZlIHRvIHJlY2FsY3VsYXRlIHRoZW0gY29uc3RhbnRseS5cbiAqXG4gKiBUaGlzIGNsYXNzIGlzIGFsc28gdGhlIGNvcmUgb2YgaG93IGVsZWN0cm9uLWNvbXBpbGUgcnVucyBxdWlja2x5IGluIHByb2R1Y3Rpb25cbiAqIG1vZGUgLSBhZnRlciBwcmVjb21waWxhdGlvbiwgdGhlIGNhY2hlIGlzIHNlcmlhbGl6ZWQgYWxvbmcgd2l0aCB0aGUgcmVzdCBvZiB0aGVcbiAqIGRhdGEgaW4ge0BsaW5rIENvbXBpbGVySG9zdH0sIHNvIHRoYXQgd2hlbiB3ZSBsb2FkIHRoZSBhcHAgaW4gcHJvZHVjdGlvbiBtb2RlLFxuICogd2UgZG9uJ3QgZW5kIHVwIGNhbGN1bGF0aW5nIGhhc2hlcyBvZiBmaWxlIGNvbnRlbnQgYXQgYWxsLCBvbmx5IHVzaW5nIHRoZSBjb250ZW50c1xuICogb2YgdGhpcyBjYWNoZS5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRmlsZUNoYW5nZWRDYWNoZSB7XG4gIGNvbnN0cnVjdG9yKGFwcFJvb3QsIGZhaWxPbkNhY2hlTWlzcz1mYWxzZSkge1xuICAgIHRoaXMuYXBwUm9vdCA9IHNhbml0aXplRmlsZVBhdGgoYXBwUm9vdCk7XG5cbiAgICB0aGlzLmZhaWxPbkNhY2hlTWlzcyA9IGZhaWxPbkNhY2hlTWlzcztcbiAgICB0aGlzLmNoYW5nZUNhY2hlID0ge307XG4gIH1cblxuICBzdGF0aWMgcmVtb3ZlUHJlZml4KG5lZWRsZSwgaGF5c3RhY2spIHtcbiAgICBsZXQgaWR4ID0gaGF5c3RhY2sudG9Mb3dlckNhc2UoKS5pbmRleE9mKG5lZWRsZS50b0xvd2VyQ2FzZSgpKTtcbiAgICBpZiAoaWR4IDwgMCkgcmV0dXJuIGhheXN0YWNrO1xuXG4gICAgcmV0dXJuIGhheXN0YWNrLnN1YnN0cmluZyhpZHggKyBuZWVkbGUubGVuZ3RoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBbGxvd3MgeW91IHRvIGNyZWF0ZSBhIEZpbGVDaGFuZ2VkQ2FjaGUgZnJvbSBzZXJpYWxpemVkIGRhdGEgc2F2ZWQgZnJvbVxuICAgKiB7QGxpbmsgZ2V0U2F2ZWREYXRhfS5cbiAgICpcbiAgICogQHBhcmFtICB7T2JqZWN0fSBkYXRhICBTYXZlZCBkYXRhIGZyb20gZ2V0U2F2ZWREYXRhLlxuICAgKlxuICAgKiBAcGFyYW0gIHtzdHJpbmd9IGFwcFJvb3QgIFRoZSB0b3AtbGV2ZWwgZGlyZWN0b3J5IGZvciB5b3VyIGFwcGxpY2F0aW9uIChpLmUuXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhlIG9uZSB3aGljaCBoYXMgeW91ciBwYWNrYWdlLmpzb24pLlxuICAgKlxuICAgKiBAcGFyYW0gIHtib29sZWFufSBmYWlsT25DYWNoZU1pc3MgKG9wdGlvbmFsKSAgSWYgVHJ1ZSwgY2FjaGUgbWlzc2VzIHdpbGwgdGhyb3cuXG4gICAqXG4gICAqIEByZXR1cm4ge0ZpbGVDaGFuZ2VkQ2FjaGV9XG4gICAqL1xuICBzdGF0aWMgbG9hZEZyb21EYXRhKGRhdGEsIGFwcFJvb3QsIGZhaWxPbkNhY2hlTWlzcz10cnVlKSB7XG4gICAgbGV0IHJldCA9IG5ldyBGaWxlQ2hhbmdlZENhY2hlKGFwcFJvb3QsIGZhaWxPbkNhY2hlTWlzcyk7XG4gICAgcmV0LmNoYW5nZUNhY2hlID0gZGF0YS5jaGFuZ2VDYWNoZTtcbiAgICByZXQub3JpZ2luYWxBcHBSb290ID0gZGF0YS5hcHBSb290O1xuXG4gICAgcmV0dXJuIHJldDtcbiAgfVxuXG5cbiAgLyoqXG4gICAqIEFsbG93cyB5b3UgdG8gY3JlYXRlIGEgRmlsZUNoYW5nZWRDYWNoZSBmcm9tIHNlcmlhbGl6ZWQgZGF0YSBzYXZlZCBmcm9tXG4gICAqIHtAbGluayBzYXZlfS5cbiAgICpcbiAgICogQHBhcmFtICB7c3RyaW5nfSBmaWxlICBTYXZlZCBkYXRhIGZyb20gc2F2ZS5cbiAgICpcbiAgICogQHBhcmFtICB7c3RyaW5nfSBhcHBSb290ICBUaGUgdG9wLWxldmVsIGRpcmVjdG9yeSBmb3IgeW91ciBhcHBsaWNhdGlvbiAoaS5lLlxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoZSBvbmUgd2hpY2ggaGFzIHlvdXIgcGFja2FnZS5qc29uKS5cbiAgICpcbiAgICogQHBhcmFtICB7Ym9vbGVhbn0gZmFpbE9uQ2FjaGVNaXNzIChvcHRpb25hbCkgIElmIFRydWUsIGNhY2hlIG1pc3NlcyB3aWxsIHRocm93LlxuICAgKlxuICAgKiBAcmV0dXJuIHtQcm9taXNlPEZpbGVDaGFuZ2VkQ2FjaGU+fVxuICAgKi9cbiAgc3RhdGljIGFzeW5jIGxvYWRGcm9tRmlsZShmaWxlLCBhcHBSb290LCBmYWlsT25DYWNoZU1pc3M9dHJ1ZSkge1xuICAgIGQoYExvYWRpbmcgY2FubmVkIEZpbGVDaGFuZ2VkQ2FjaGUgZnJvbSAke2ZpbGV9YCk7XG5cbiAgICBsZXQgYnVmID0gYXdhaXQgcGZzLnJlYWRGaWxlKGZpbGUpO1xuICAgIHJldHVybiBGaWxlQ2hhbmdlZENhY2hlLmxvYWRGcm9tRGF0YShKU09OLnBhcnNlKGF3YWl0IHB6bGliLmd1bnppcChidWYpKSwgYXBwUm9vdCwgZmFpbE9uQ2FjaGVNaXNzKTtcbiAgfVxuXG5cbiAgLyoqXG4gICAqIFJldHVybnMgaW5mb3JtYXRpb24gYWJvdXQgYSBnaXZlbiBmaWxlLCBpbmNsdWRpbmcgaXRzIGhhc2guIFRoaXMgbWV0aG9kIGlzXG4gICAqIHRoZSBtYWluIG1ldGhvZCBmb3IgdGhpcyBjYWNoZS5cbiAgICpcbiAgICogQHBhcmFtICB7c3RyaW5nfSBhYnNvbHV0ZUZpbGVQYXRoICBUaGUgcGF0aCB0byBhIGZpbGUgdG8gcmV0cmlldmUgaW5mbyBvbi5cbiAgICpcbiAgICogQHJldHVybiB7UHJvbWlzZTxPYmplY3Q+fVxuICAgKlxuICAgKiBAcHJvcGVydHkge3N0cmluZ30gaGFzaCAgVGhlIFNIQTEgaGFzaCBvZiB0aGUgZmlsZVxuICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IGlzTWluaWZpZWQgIFRydWUgaWYgdGhlIGZpbGUgaXMgbWluaWZpZWRcbiAgICogQHByb3BlcnR5IHtib29sZWFufSBpc0luTm9kZU1vZHVsZXMgIFRydWUgaWYgdGhlIGZpbGUgaXMgaW4gYSBsaWJyYXJ5IGRpcmVjdG9yeVxuICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IGhhc1NvdXJjZU1hcCAgVHJ1ZSBpZiB0aGUgZmlsZSBoYXMgYSBzb3VyY2UgbWFwXG4gICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gaXNGaWxlQmluYXJ5ICBUcnVlIGlmIHRoZSBmaWxlIGlzIG5vdCBhIHRleHQgZmlsZVxuICAgKiBAcHJvcGVydHkge0J1ZmZlcn0gYmluYXJ5RGF0YSAob3B0aW9uYWwpICBUaGUgYnVmZmVyIHRoYXQgd2FzIHJlYWQgaWYgdGhlIGZpbGVcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2FzIGJpbmFyeSBhbmQgdGhlcmUgd2FzIGEgY2FjaGUgbWlzcy5cbiAgICogQHByb3BlcnR5IHtzdHJpbmd9IGNvZGUgKG9wdGlvbmFsKSAgVGhlIHN0cmluZyB0aGF0IHdhcyByZWFkIGlmIHRoZSBmaWxlXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdhcyB0ZXh0IGFuZCB0aGVyZSB3YXMgYSBjYWNoZSBtaXNzXG4gICAqL1xuICBhc3luYyBnZXRIYXNoRm9yUGF0aChhYnNvbHV0ZUZpbGVQYXRoKSB7XG4gICAgbGV0IHtjYWNoZUVudHJ5LCBjYWNoZUtleX0gPSB0aGlzLmdldENhY2hlRW50cnlGb3JQYXRoKGFic29sdXRlRmlsZVBhdGgpO1xuXG4gICAgaWYgKHRoaXMuZmFpbE9uQ2FjaGVNaXNzKSB7XG4gICAgICByZXR1cm4gY2FjaGVFbnRyeS5pbmZvO1xuICAgIH1cblxuICAgIGxldCB7Y3RpbWUsIHNpemV9ID0gYXdhaXQgdGhpcy5nZXRJbmZvRm9yQ2FjaGVFbnRyeShhYnNvbHV0ZUZpbGVQYXRoKTtcblxuICAgIGlmIChjYWNoZUVudHJ5KSB7XG4gICAgICBsZXQgZmlsZUhhc0NoYW5nZWQgPSBhd2FpdCB0aGlzLmhhc0ZpbGVDaGFuZ2VkKGFic29sdXRlRmlsZVBhdGgsIGNhY2hlRW50cnksIHtjdGltZSwgc2l6ZX0pO1xuXG4gICAgICBpZiAoIWZpbGVIYXNDaGFuZ2VkKSB7XG4gICAgICAgIHJldHVybiBjYWNoZUVudHJ5LmluZm87XG4gICAgICB9XG5cbiAgICAgIGQoYEludmFsaWRhdGluZyBjYWNoZSBlbnRyeTogJHtjYWNoZUVudHJ5LmN0aW1lfSA9PT0gJHtjdGltZX0gJiYgJHtjYWNoZUVudHJ5LnNpemV9ID09PSAke3NpemV9YCk7XG4gICAgICBkZWxldGUgdGhpcy5jaGFuZ2VDYWNoZS5jYWNoZUVudHJ5O1xuICAgIH1cblxuICAgIGxldCB7ZGlnZXN0LCBzb3VyY2VDb2RlLCBiaW5hcnlEYXRhfSA9IGF3YWl0IHRoaXMuY2FsY3VsYXRlSGFzaEZvckZpbGUoYWJzb2x1dGVGaWxlUGF0aCk7XG5cbiAgICBsZXQgaW5mbyA9IHtcbiAgICAgIGhhc2g6IGRpZ2VzdCxcbiAgICAgIGlzTWluaWZpZWQ6IEZpbGVDaGFuZ2VkQ2FjaGUuY29udGVudHNBcmVNaW5pZmllZChzb3VyY2VDb2RlIHx8ICcnKSxcbiAgICAgIGlzSW5Ob2RlTW9kdWxlczogRmlsZUNoYW5nZWRDYWNoZS5pc0luTm9kZU1vZHVsZXMoYWJzb2x1dGVGaWxlUGF0aCksXG4gICAgICBoYXNTb3VyY2VNYXA6IEZpbGVDaGFuZ2VkQ2FjaGUuaGFzU291cmNlTWFwKHNvdXJjZUNvZGUgfHwgJycpLFxuICAgICAgaXNGaWxlQmluYXJ5OiAhIWJpbmFyeURhdGFcbiAgICB9O1xuXG4gICAgdGhpcy5jaGFuZ2VDYWNoZVtjYWNoZUtleV0gPSB7IGN0aW1lLCBzaXplLCBpbmZvIH07XG4gICAgZChgQ2FjaGUgZW50cnkgZm9yICR7Y2FjaGVLZXl9OiAke0pTT04uc3RyaW5naWZ5KHRoaXMuY2hhbmdlQ2FjaGVbY2FjaGVLZXldKX1gKTtcblxuICAgIGlmIChiaW5hcnlEYXRhKSB7XG4gICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7YmluYXJ5RGF0YX0sIGluZm8pO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7c291cmNlQ29kZX0sIGluZm8pO1xuICAgIH1cbiAgfVxuXG4gIGFzeW5jIGdldEluZm9Gb3JDYWNoZUVudHJ5KGFic29sdXRlRmlsZVBhdGgpIHtcbiAgICBsZXQgc3RhdCA9IGF3YWl0IHBmcy5zdGF0KGFic29sdXRlRmlsZVBhdGgpO1xuICAgIGlmICghc3RhdCB8fCAhc3RhdC5pc0ZpbGUoKSkgdGhyb3cgbmV3IEVycm9yKGBDYW4ndCBzdGF0ICR7YWJzb2x1dGVGaWxlUGF0aH1gKTtcblxuICAgIHJldHVybiB7XG4gICAgICBzdGF0LFxuICAgICAgY3RpbWU6IHN0YXQuY3RpbWUuZ2V0VGltZSgpLFxuICAgICAgc2l6ZTogc3RhdC5zaXplXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBjYWNoZWQgZGF0YSBmb3IgYSBmaWxlIHBhdGgsIGlmIGl0IGV4aXN0cy5cbiAgICpcbiAgICogQHBhcmFtICB7c3RyaW5nfSBhYnNvbHV0ZUZpbGVQYXRoICBUaGUgcGF0aCB0byBhIGZpbGUgdG8gcmV0cmlldmUgaW5mbyBvbi5cbiAgICpcbiAgICogQHJldHVybiB7T2JqZWN0fVxuICAgKi9cbiAgZ2V0Q2FjaGVFbnRyeUZvclBhdGgoYWJzb2x1dGVGaWxlUGF0aCkge1xuICAgIGxldCBjYWNoZUtleSA9IHNhbml0aXplRmlsZVBhdGgoYWJzb2x1dGVGaWxlUGF0aCk7XG4gICAgaWYgKHRoaXMuYXBwUm9vdCkge1xuICAgICAgY2FjaGVLZXkgPSBjYWNoZUtleS5yZXBsYWNlKHRoaXMuYXBwUm9vdCwgJycpO1xuICAgIH1cblxuICAgIC8vIE5COiBXZSBkbyB0aGlzIGJlY2F1c2UgeC1yZXF1aXJlIHdpbGwgaW5jbHVkZSBhbiBhYnNvbHV0ZSBwYXRoIGZyb20gdGhlXG4gICAgLy8gb3JpZ2luYWwgYnVpbHQgYXBwIGFuZCB3ZSBuZWVkIHRvIHN0aWxsIGdyb2sgaXRcbiAgICBpZiAodGhpcy5vcmlnaW5hbEFwcFJvb3QpIHtcbiAgICAgIGNhY2hlS2V5ID0gY2FjaGVLZXkucmVwbGFjZSh0aGlzLm9yaWdpbmFsQXBwUm9vdCwgJycpO1xuICAgIH1cblxuICAgIGxldCBjYWNoZUVudHJ5ID0gdGhpcy5jaGFuZ2VDYWNoZVtjYWNoZUtleV07XG5cbiAgICBpZiAodGhpcy5mYWlsT25DYWNoZU1pc3MpIHtcbiAgICAgIGlmICghY2FjaGVFbnRyeSkge1xuICAgICAgICBkKGBUcmllZCB0byByZWFkIGZpbGUgY2FjaGUgZW50cnkgZm9yICR7YWJzb2x1dGVGaWxlUGF0aH1gKTtcbiAgICAgICAgZChgY2FjaGVLZXk6ICR7Y2FjaGVLZXl9LCBhcHBSb290OiAke3RoaXMuYXBwUm9vdH0sIG9yaWdpbmFsQXBwUm9vdDogJHt0aGlzLm9yaWdpbmFsQXBwUm9vdH1gKTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBBc2tlZCBmb3IgJHthYnNvbHV0ZUZpbGVQYXRofSBidXQgaXQgd2FzIG5vdCBwcmVjb21waWxlZCFgKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4ge2NhY2hlRW50cnksIGNhY2hlS2V5fTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVja3MgdGhlIGZpbGUgY2FjaGUgdG8gc2VlIGlmIGEgZmlsZSBoYXMgY2hhbmdlZC5cbiAgICpcbiAgICogQHBhcmFtICB7c3RyaW5nfSBhYnNvbHV0ZUZpbGVQYXRoICBUaGUgcGF0aCB0byBhIGZpbGUgdG8gcmV0cmlldmUgaW5mbyBvbi5cbiAgICogQHBhcmFtICB7T2JqZWN0fSBjYWNoZUVudHJ5ICBDYWNoZSBkYXRhIGZyb20ge0BsaW5rIGdldENhY2hlRW50cnlGb3JQYXRofVxuICAgKlxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgYXN5bmMgaGFzRmlsZUNoYW5nZWQoYWJzb2x1dGVGaWxlUGF0aCwgY2FjaGVFbnRyeT1udWxsLCBmaWxlSGFzaEluZm89bnVsbCkge1xuICAgIGNhY2hlRW50cnkgPSBjYWNoZUVudHJ5IHx8IHRoaXMuZ2V0Q2FjaGVFbnRyeUZvclBhdGgoYWJzb2x1dGVGaWxlUGF0aCkuY2FjaGVFbnRyeTtcbiAgICBmaWxlSGFzaEluZm8gPSBmaWxlSGFzaEluZm8gfHwgYXdhaXQgdGhpcy5nZXRJbmZvRm9yQ2FjaGVFbnRyeShhYnNvbHV0ZUZpbGVQYXRoKTtcblxuICAgIGlmIChjYWNoZUVudHJ5KSB7XG4gICAgICByZXR1cm4gIShjYWNoZUVudHJ5LmN0aW1lID49IGZpbGVIYXNoSW5mby5jdGltZSAmJiBjYWNoZUVudHJ5LnNpemUgPT09IGZpbGVIYXNoSW5mby5zaXplKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBkYXRhIHRoYXQgY2FuIHBhc3NlZCB0byB7QGxpbmsgbG9hZEZyb21EYXRhfSB0byByZWh5ZHJhdGUgdGhpcyBjYWNoZS5cbiAgICpcbiAgICogQHJldHVybiB7T2JqZWN0fVxuICAgKi9cbiAgZ2V0U2F2ZWREYXRhKCkge1xuICAgIHJldHVybiB7IGNoYW5nZUNhY2hlOiB0aGlzLmNoYW5nZUNhY2hlLCBhcHBSb290OiB0aGlzLmFwcFJvb3QgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXJpYWxpemVzIHRoaXMgb2JqZWN0J3MgZGF0YSB0byBhIGZpbGUuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBmaWxlUGF0aCAgVGhlIHBhdGggdG8gc2F2ZSBkYXRhIHRvLlxuICAgKlxuICAgKiBAcmV0dXJuIHtQcm9taXNlfSBDb21wbGV0aW9uLlxuICAgKi9cbiAgYXN5bmMgc2F2ZShmaWxlUGF0aCkge1xuICAgIGxldCB0b1NhdmUgPSB0aGlzLmdldFNhdmVkRGF0YSgpO1xuXG4gICAgbGV0IGJ1ZiA9IGF3YWl0IHB6bGliLmd6aXAobmV3IEJ1ZmZlcihKU09OLnN0cmluZ2lmeSh0b1NhdmUpKSk7XG4gICAgYXdhaXQgcGZzLndyaXRlRmlsZShmaWxlUGF0aCwgYnVmKTtcbiAgfVxuXG4gIGFzeW5jIGNhbGN1bGF0ZUhhc2hGb3JGaWxlKGFic29sdXRlRmlsZVBhdGgpIHtcbiAgICBsZXQgYnVmID0gYXdhaXQgcGZzLnJlYWRGaWxlKGFic29sdXRlRmlsZVBhdGgpO1xuICAgIGxldCBlbmNvZGluZyA9IEZpbGVDaGFuZ2VkQ2FjaGUuZGV0ZWN0RmlsZUVuY29kaW5nKGJ1Zik7XG5cbiAgICBpZiAoIWVuY29kaW5nKSB7XG4gICAgICBsZXQgZGlnZXN0ID0gY3J5cHRvLmNyZWF0ZUhhc2goJ3NoYTEnKS51cGRhdGUoYnVmKS5kaWdlc3QoJ2hleCcpO1xuICAgICAgcmV0dXJuIHsgc291cmNlQ29kZTogbnVsbCwgZGlnZXN0LCBiaW5hcnlEYXRhOiBidWYgfTtcbiAgICB9XG5cbiAgICBsZXQgc291cmNlQ29kZSA9IGF3YWl0IHBmcy5yZWFkRmlsZShhYnNvbHV0ZUZpbGVQYXRoLCBlbmNvZGluZyk7XG4gICAgbGV0IGRpZ2VzdCA9IGNyeXB0by5jcmVhdGVIYXNoKCdzaGExJykudXBkYXRlKHNvdXJjZUNvZGUsICd1dGY4JykuZGlnZXN0KCdoZXgnKTtcblxuICAgIHJldHVybiB7c291cmNlQ29kZSwgZGlnZXN0LCBiaW5hcnlEYXRhOiBudWxsIH07XG4gIH1cblxuICBnZXRIYXNoRm9yUGF0aFN5bmMoYWJzb2x1dGVGaWxlUGF0aCkge1xuICAgIGxldCBjYWNoZUtleSA9IHNhbml0aXplRmlsZVBhdGgoYWJzb2x1dGVGaWxlUGF0aCk7XG5cbiAgICBpZiAodGhpcy5hcHBSb290KSB7XG4gICAgICBjYWNoZUtleSA9IEZpbGVDaGFuZ2VkQ2FjaGUucmVtb3ZlUHJlZml4KHRoaXMuYXBwUm9vdCwgY2FjaGVLZXkpO1xuICAgIH1cblxuICAgIC8vIE5COiBXZSBkbyB0aGlzIGJlY2F1c2UgeC1yZXF1aXJlIHdpbGwgaW5jbHVkZSBhbiBhYnNvbHV0ZSBwYXRoIGZyb20gdGhlXG4gICAgLy8gb3JpZ2luYWwgYnVpbHQgYXBwIGFuZCB3ZSBuZWVkIHRvIHN0aWxsIGdyb2sgaXRcbiAgICBpZiAodGhpcy5vcmlnaW5hbEFwcFJvb3QpIHtcbiAgICAgIGNhY2hlS2V5ID0gRmlsZUNoYW5nZWRDYWNoZS5yZW1vdmVQcmVmaXgodGhpcy5vcmlnaW5hbEFwcFJvb3QsIGNhY2hlS2V5KTtcbiAgICB9XG5cbiAgICBsZXQgY2FjaGVFbnRyeSA9IHRoaXMuY2hhbmdlQ2FjaGVbY2FjaGVLZXldO1xuXG4gICAgaWYgKHRoaXMuZmFpbE9uQ2FjaGVNaXNzKSB7XG4gICAgICBpZiAoIWNhY2hlRW50cnkpIHtcbiAgICAgICAgZChgVHJpZWQgdG8gcmVhZCBmaWxlIGNhY2hlIGVudHJ5IGZvciAke2Fic29sdXRlRmlsZVBhdGh9YCk7XG4gICAgICAgIGQoYGNhY2hlS2V5OiAke2NhY2hlS2V5fSwgYXBwUm9vdDogJHt0aGlzLmFwcFJvb3R9LCBvcmlnaW5hbEFwcFJvb3Q6ICR7dGhpcy5vcmlnaW5hbEFwcFJvb3R9YCk7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgQXNrZWQgZm9yICR7YWJzb2x1dGVGaWxlUGF0aH0gYnV0IGl0IHdhcyBub3QgcHJlY29tcGlsZWQhYCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjYWNoZUVudHJ5LmluZm87XG4gICAgfVxuXG4gICAgbGV0IHN0YXQgPSBmcy5zdGF0U3luYyhhYnNvbHV0ZUZpbGVQYXRoKTtcbiAgICBsZXQgY3RpbWUgPSBzdGF0LmN0aW1lLmdldFRpbWUoKTtcbiAgICBsZXQgc2l6ZSA9IHN0YXQuc2l6ZTtcbiAgICBpZiAoIXN0YXQgfHwgIXN0YXQuaXNGaWxlKCkpIHRocm93IG5ldyBFcnJvcihgQ2FuJ3Qgc3RhdCAke2Fic29sdXRlRmlsZVBhdGh9YCk7XG5cbiAgICBpZiAoY2FjaGVFbnRyeSkge1xuICAgICAgaWYgKGNhY2hlRW50cnkuY3RpbWUgPj0gY3RpbWUgJiYgY2FjaGVFbnRyeS5zaXplID09PSBzaXplKSB7XG4gICAgICAgIHJldHVybiBjYWNoZUVudHJ5LmluZm87XG4gICAgICB9XG5cbiAgICAgIGQoYEludmFsaWRhdGluZyBjYWNoZSBlbnRyeTogJHtjYWNoZUVudHJ5LmN0aW1lfSA9PT0gJHtjdGltZX0gJiYgJHtjYWNoZUVudHJ5LnNpemV9ID09PSAke3NpemV9YCk7XG4gICAgICBkZWxldGUgdGhpcy5jaGFuZ2VDYWNoZS5jYWNoZUVudHJ5O1xuICAgIH1cblxuICAgIGxldCB7ZGlnZXN0LCBzb3VyY2VDb2RlLCBiaW5hcnlEYXRhfSA9IHRoaXMuY2FsY3VsYXRlSGFzaEZvckZpbGVTeW5jKGFic29sdXRlRmlsZVBhdGgpO1xuXG4gICAgbGV0IGluZm8gPSB7XG4gICAgICBoYXNoOiBkaWdlc3QsXG4gICAgICBpc01pbmlmaWVkOiBGaWxlQ2hhbmdlZENhY2hlLmNvbnRlbnRzQXJlTWluaWZpZWQoc291cmNlQ29kZSB8fCAnJyksXG4gICAgICBpc0luTm9kZU1vZHVsZXM6IEZpbGVDaGFuZ2VkQ2FjaGUuaXNJbk5vZGVNb2R1bGVzKGFic29sdXRlRmlsZVBhdGgpLFxuICAgICAgaGFzU291cmNlTWFwOiBGaWxlQ2hhbmdlZENhY2hlLmhhc1NvdXJjZU1hcChzb3VyY2VDb2RlIHx8ICcnKSxcbiAgICAgIGlzRmlsZUJpbmFyeTogISFiaW5hcnlEYXRhXG4gICAgfTtcblxuICAgIHRoaXMuY2hhbmdlQ2FjaGVbY2FjaGVLZXldID0geyBjdGltZSwgc2l6ZSwgaW5mbyB9O1xuICAgIGQoYENhY2hlIGVudHJ5IGZvciAke2NhY2hlS2V5fTogJHtKU09OLnN0cmluZ2lmeSh0aGlzLmNoYW5nZUNhY2hlW2NhY2hlS2V5XSl9YCk7XG5cbiAgICBpZiAoYmluYXJ5RGF0YSkge1xuICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe2JpbmFyeURhdGF9LCBpbmZvKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe3NvdXJjZUNvZGV9LCBpbmZvKTtcbiAgICB9XG4gIH1cblxuICBzYXZlU3luYyhmaWxlUGF0aCkge1xuICAgIGxldCB0b1NhdmUgPSB0aGlzLmdldFNhdmVkRGF0YSgpO1xuXG4gICAgbGV0IGJ1ZiA9IHpsaWIuZ3ppcFN5bmMobmV3IEJ1ZmZlcihKU09OLnN0cmluZ2lmeSh0b1NhdmUpKSk7XG4gICAgZnMud3JpdGVGaWxlU3luYyhmaWxlUGF0aCwgYnVmKTtcbiAgfVxuXG4gIGNhbGN1bGF0ZUhhc2hGb3JGaWxlU3luYyhhYnNvbHV0ZUZpbGVQYXRoKSB7XG4gICAgbGV0IGJ1ZiA9IGZzLnJlYWRGaWxlU3luYyhhYnNvbHV0ZUZpbGVQYXRoKTtcbiAgICBsZXQgZW5jb2RpbmcgPSBGaWxlQ2hhbmdlZENhY2hlLmRldGVjdEZpbGVFbmNvZGluZyhidWYpO1xuXG4gICAgaWYgKCFlbmNvZGluZykge1xuICAgICAgbGV0IGRpZ2VzdCA9IGNyeXB0by5jcmVhdGVIYXNoKCdzaGExJykudXBkYXRlKGJ1ZikuZGlnZXN0KCdoZXgnKTtcbiAgICAgIHJldHVybiB7IHNvdXJjZUNvZGU6IG51bGwsIGRpZ2VzdCwgYmluYXJ5RGF0YTogYnVmfTtcbiAgICB9XG5cbiAgICBsZXQgc291cmNlQ29kZSA9IGZzLnJlYWRGaWxlU3luYyhhYnNvbHV0ZUZpbGVQYXRoLCBlbmNvZGluZyk7XG4gICAgbGV0IGRpZ2VzdCA9IGNyeXB0by5jcmVhdGVIYXNoKCdzaGExJykudXBkYXRlKHNvdXJjZUNvZGUsICd1dGY4JykuZGlnZXN0KCdoZXgnKTtcblxuICAgIHJldHVybiB7c291cmNlQ29kZSwgZGlnZXN0LCBiaW5hcnlEYXRhOiBudWxsfTtcbiAgfVxuXG5cbiAgLyoqXG4gICAqIERldGVybWluZXMgdmlhIHNvbWUgc3RhdGlzdGljcyB3aGV0aGVyIGEgZmlsZSBpcyBsaWtlbHkgdG8gYmUgbWluaWZpZWQuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBzdGF0aWMgY29udGVudHNBcmVNaW5pZmllZChzb3VyY2UpIHtcbiAgICBsZXQgbGVuZ3RoID0gc291cmNlLmxlbmd0aDtcbiAgICBpZiAobGVuZ3RoID4gMTAyNCkgbGVuZ3RoID0gMTAyNDtcblxuICAgIGxldCBuZXdsaW5lQ291bnQgPSAwO1xuXG4gICAgLy8gUm9sbCB0aHJvdWdoIHRoZSBjaGFyYWN0ZXJzIGFuZCBkZXRlcm1pbmUgdGhlIGF2ZXJhZ2UgbGluZSBsZW5ndGhcbiAgICBmb3IobGV0IGk9MDsgaSA8IHNvdXJjZS5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHNvdXJjZVtpXSA9PT0gJ1xcbicpIG5ld2xpbmVDb3VudCsrO1xuICAgIH1cblxuICAgIC8vIE5vIE5ld2xpbmVzPyBBbnkgZmlsZSBvdGhlciB0aGFuIGEgc3VwZXIgc21hbGwgb25lIGlzIG1pbmlmaWVkXG4gICAgaWYgKG5ld2xpbmVDb3VudCA9PT0gMCkge1xuICAgICAgcmV0dXJuIChsZW5ndGggPiA4MCk7XG4gICAgfVxuXG4gICAgbGV0IGF2Z0xpbmVMZW5ndGggPSBsZW5ndGggLyBuZXdsaW5lQ291bnQ7XG4gICAgcmV0dXJuIChhdmdMaW5lTGVuZ3RoID4gODApO1xuICB9XG5cblxuICAvKipcbiAgICogRGV0ZXJtaW5lcyB3aGV0aGVyIGEgcGF0aCBpcyBpbiBub2RlX21vZHVsZXMgb3IgdGhlIEVsZWN0cm9uIGluaXQgY29kZVxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgc3RhdGljIGlzSW5Ob2RlTW9kdWxlcyhmaWxlUGF0aCkge1xuICAgIHJldHVybiAhIShmaWxlUGF0aC5tYXRjaCgvKG5vZGVfbW9kdWxlc3xib3dlcl9jb21wb25lbnRzKVtcXFxcXFwvXS9pKSB8fCBmaWxlUGF0aC5tYXRjaCgvKGF0b218ZWxlY3Ryb24pXFwuYXNhci8pKTtcbiAgfVxuXG5cbiAgLyoqXG4gICAqIFJldHVybnMgd2hldGhlciBhIGZpbGUgaGFzIGFuIGlubGluZSBzb3VyY2UgbWFwXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBzdGF0aWMgaGFzU291cmNlTWFwKHNvdXJjZUNvZGUpIHtcbiAgICBjb25zdCB0cmltbWVkID0gc291cmNlQ29kZS50cmltKCk7XG4gICAgcmV0dXJuIHRyaW1tZWQubGFzdEluZGV4T2YoJy8vIyBzb3VyY2VNYXAnKSA+IHRyaW1tZWQubGFzdEluZGV4T2YoJ1xcbicpO1xuICB9XG5cbiAgLyoqXG4gICAqIERldGVybWluZXMgdGhlIGVuY29kaW5nIG9mIGEgZmlsZSBmcm9tIHRoZSB0d28gbW9zdCBjb21tb24gZW5jb2RpbmdzIGJ5IHRyeWluZ1xuICAgKiB0byBkZWNvZGUgaXQgdGhlbiBsb29raW5nIGZvciBlbmNvZGluZyBlcnJvcnNcbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG4gIHN0YXRpYyBkZXRlY3RGaWxlRW5jb2RpbmcoYnVmZmVyKSB7XG4gICAgaWYgKGJ1ZmZlci5sZW5ndGggPCAxKSByZXR1cm4gZmFsc2U7XG4gICAgbGV0IGJ1ZiA9IChidWZmZXIubGVuZ3RoIDwgNDA5NiA/IGJ1ZmZlciA6IGJ1ZmZlci5zbGljZSgwLCA0MDk2KSk7XG5cbiAgICBjb25zdCBlbmNvZGluZ3MgPSBbJ3V0ZjgnLCAndXRmMTZsZSddO1xuXG4gICAgbGV0IGVuY29kaW5nO1xuICAgIGlmIChidWZmZXIubGVuZ3RoIDw9IDEyOCkge1xuICAgICAgZW5jb2RpbmcgPSBlbmNvZGluZ3MuZmluZCh4ID0+XG4gICAgICAgIEJ1ZmZlci5jb21wYXJlKG5ldyBCdWZmZXIoYnVmZmVyLnRvU3RyaW5nKCksIHgpLCBidWZmZXIpID09PSAwXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbmNvZGluZyA9IGVuY29kaW5ncy5maW5kKHggPT4gIUZpbGVDaGFuZ2VkQ2FjaGUuY29udGFpbnNDb250cm9sQ2hhcmFjdGVycyhidWYudG9TdHJpbmcoeCkpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZW5jb2Rpbmc7XG4gIH1cblxuICAvKipcbiAgICogRGV0ZXJtaW5lcyB3aGV0aGVyIGEgc3RyaW5nIGlzIGxpa2VseSB0byBiZSBwb29ybHkgZW5jb2RlZCBieSBsb29raW5nIGZvclxuICAgKiBjb250cm9sIGNoYXJhY3RlcnMgYWJvdmUgYSBjZXJ0YWluIHRocmVzaG9sZFxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgc3RhdGljIGNvbnRhaW5zQ29udHJvbENoYXJhY3RlcnMoc3RyKSB7XG4gICAgbGV0IGNvbnRyb2xDb3VudCA9IDA7XG4gICAgbGV0IHNwYWNlQ291bnQgPSAwO1xuICAgIGxldCB0aHJlc2hvbGQgPSAyO1xuICAgIGlmIChzdHIubGVuZ3RoID4gNjQpIHRocmVzaG9sZCA9IDQ7XG4gICAgaWYgKHN0ci5sZW5ndGggPiA1MTIpIHRocmVzaG9sZCA9IDg7XG5cbiAgICBmb3IgKGxldCBpPTA7IGkgPCBzdHIubGVuZ3RoOyBpKyspIHtcbiAgICAgIGxldCBjID0gc3RyLmNoYXJDb2RlQXQoaSk7XG4gICAgICBpZiAoYyA9PT0gNjU1MzYgfHwgYyA8IDgpIGNvbnRyb2xDb3VudCsrO1xuICAgICAgaWYgKGMgPiAxNCAmJiBjIDwgMzIpIGNvbnRyb2xDb3VudCsrO1xuICAgICAgaWYgKGMgPT09IDMyKSBzcGFjZUNvdW50Kys7XG5cbiAgICAgIGlmIChjb250cm9sQ291bnQgPiB0aHJlc2hvbGQpIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGlmIChzcGFjZUNvdW50IDwgdGhyZXNob2xkKSByZXR1cm4gdHJ1ZTtcblxuICAgIGlmIChjb250cm9sQ291bnQgPT09IDApIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gKGNvbnRyb2xDb3VudCAvIHN0ci5sZW5ndGgpIDwgMC4wMjtcbiAgfVxufVxuIl19\n\n//# sourceURL=webpack:///./node_modules/electron-compile/lib/file-change-cache.js?")},"./node_modules/electron-compile/lib/for-all-files.js":
/*!************************************************************!*\
  !*** ./node_modules/electron-compile/lib/for-all-files.js ***!
  \************************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", {\n  value: true\n});\nexports.forAllFiles = forAllFiles;\nexports.forAllFilesSync = forAllFilesSync;\n\nvar _fs = __webpack_require__(/*! fs */ "fs");\n\nvar _fs2 = _interopRequireDefault(_fs);\n\nvar _path = __webpack_require__(/*! path */ "path");\n\nvar _path2 = _interopRequireDefault(_path);\n\nvar _promise = __webpack_require__(/*! ./promise */ "./node_modules/electron-compile/lib/promise.js");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }\n\n/**\n * Invokes a method on all files in a directory recursively.\n * \n * @private\n */\nfunction forAllFiles(rootDirectory, func) {\n  for (var _len = arguments.length, args = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n    args[_key - 2] = arguments[_key];\n  }\n\n  let rec = (() => {\n    var _ref = _asyncToGenerator(function* (dir) {\n      let entries = yield _promise.pfs.readdir(dir);\n\n      for (let name of entries) {\n        let fullName = _path2.default.join(dir, name);\n        let stats = yield _promise.pfs.stat(fullName);\n\n        if (stats.isDirectory()) {\n          yield rec(fullName);\n        }\n\n        if (stats.isFile()) {\n          yield func(fullName, ...args);\n        }\n      }\n    });\n\n    return function rec(_x) {\n      return _ref.apply(this, arguments);\n    };\n  })();\n\n  return rec(rootDirectory);\n}\n\nfunction forAllFilesSync(rootDirectory, func) {\n  for (var _len2 = arguments.length, args = Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {\n    args[_key2 - 2] = arguments[_key2];\n  }\n\n  let rec = dir => {\n    _fs2.default.readdirSync(dir).forEach(name => {\n      let fullName = _path2.default.join(dir, name);\n      let stats = _fs2.default.statSync(fullName);\n\n      if (stats.isDirectory()) {\n        rec(fullName);\n        return;\n      }\n\n      if (stats.isFile()) {\n        func(fullName, ...args);\n        return;\n      }\n    });\n  };\n\n  rec(rootDirectory);\n}\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9mb3ItYWxsLWZpbGVzLmpzIl0sIm5hbWVzIjpbImZvckFsbEZpbGVzIiwiZm9yQWxsRmlsZXNTeW5jIiwicm9vdERpcmVjdG9yeSIsImZ1bmMiLCJhcmdzIiwicmVjIiwiZGlyIiwiZW50cmllcyIsInBmcyIsInJlYWRkaXIiLCJuYW1lIiwiZnVsbE5hbWUiLCJwYXRoIiwiam9pbiIsInN0YXRzIiwic3RhdCIsImlzRGlyZWN0b3J5IiwiaXNGaWxlIiwiZnMiLCJyZWFkZGlyU3luYyIsImZvckVhY2giLCJzdGF0U3luYyJdLCJtYXBwaW5ncyI6Ijs7Ozs7UUFVZ0JBLFcsR0FBQUEsVztRQXFCQUMsZSxHQUFBQSxlOztBQS9CaEI7Ozs7QUFDQTs7OztBQUNBOzs7Ozs7QUFHQTs7Ozs7QUFLTyxTQUFTRCxXQUFULENBQXFCRSxhQUFyQixFQUFvQ0MsSUFBcEMsRUFBbUQ7QUFBQSxvQ0FBTkMsSUFBTTtBQUFOQSxRQUFNO0FBQUE7O0FBQ3hELE1BQUlDO0FBQUEsaUNBQU0sV0FBT0MsR0FBUCxFQUFlO0FBQ3ZCLFVBQUlDLFVBQVUsTUFBTUMsYUFBSUMsT0FBSixDQUFZSCxHQUFaLENBQXBCOztBQUVBLFdBQUssSUFBSUksSUFBVCxJQUFpQkgsT0FBakIsRUFBMEI7QUFDeEIsWUFBSUksV0FBV0MsZUFBS0MsSUFBTCxDQUFVUCxHQUFWLEVBQWVJLElBQWYsQ0FBZjtBQUNBLFlBQUlJLFFBQVEsTUFBTU4sYUFBSU8sSUFBSixDQUFTSixRQUFULENBQWxCOztBQUVBLFlBQUlHLE1BQU1FLFdBQU4sRUFBSixFQUF5QjtBQUN2QixnQkFBTVgsSUFBSU0sUUFBSixDQUFOO0FBQ0Q7O0FBRUQsWUFBSUcsTUFBTUcsTUFBTixFQUFKLEVBQW9CO0FBQ2xCLGdCQUFNZCxLQUFLUSxRQUFMLEVBQWUsR0FBR1AsSUFBbEIsQ0FBTjtBQUNEO0FBQ0Y7QUFDRixLQWZHOztBQUFBO0FBQUE7QUFBQTtBQUFBLE1BQUo7O0FBaUJBLFNBQU9DLElBQUlILGFBQUosQ0FBUDtBQUNEOztBQUVNLFNBQVNELGVBQVQsQ0FBeUJDLGFBQXpCLEVBQXdDQyxJQUF4QyxFQUF1RDtBQUFBLHFDQUFOQyxJQUFNO0FBQU5BLFFBQU07QUFBQTs7QUFDNUQsTUFBSUMsTUFBT0MsR0FBRCxJQUFTO0FBQ2pCWSxpQkFBR0MsV0FBSCxDQUFlYixHQUFmLEVBQW9CYyxPQUFwQixDQUE2QlYsSUFBRCxJQUFVO0FBQ3BDLFVBQUlDLFdBQVdDLGVBQUtDLElBQUwsQ0FBVVAsR0FBVixFQUFlSSxJQUFmLENBQWY7QUFDQSxVQUFJSSxRQUFRSSxhQUFHRyxRQUFILENBQVlWLFFBQVosQ0FBWjs7QUFFQSxVQUFJRyxNQUFNRSxXQUFOLEVBQUosRUFBeUI7QUFDdkJYLFlBQUlNLFFBQUo7QUFDQTtBQUNEOztBQUVELFVBQUlHLE1BQU1HLE1BQU4sRUFBSixFQUFvQjtBQUNsQmQsYUFBS1EsUUFBTCxFQUFlLEdBQUdQLElBQWxCO0FBQ0E7QUFDRDtBQUNGLEtBYkQ7QUFjRCxHQWZEOztBQWlCQUMsTUFBSUgsYUFBSjtBQUNEIiwiZmlsZSI6ImZvci1hbGwtZmlsZXMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgZnMgZnJvbSAnZnMnO1xuaW1wb3J0IHBhdGggZnJvbSAncGF0aCc7XG5pbXBvcnQge3Bmc30gZnJvbSAnLi9wcm9taXNlJztcblxuXG4vKipcbiAqIEludm9rZXMgYSBtZXRob2Qgb24gYWxsIGZpbGVzIGluIGEgZGlyZWN0b3J5IHJlY3Vyc2l2ZWx5LlxuICogXG4gKiBAcHJpdmF0ZVxuICovIFxuZXhwb3J0IGZ1bmN0aW9uIGZvckFsbEZpbGVzKHJvb3REaXJlY3RvcnksIGZ1bmMsIC4uLmFyZ3MpIHtcbiAgbGV0IHJlYyA9IGFzeW5jIChkaXIpID0+IHtcbiAgICBsZXQgZW50cmllcyA9IGF3YWl0IHBmcy5yZWFkZGlyKGRpcik7XG4gICAgXG4gICAgZm9yIChsZXQgbmFtZSBvZiBlbnRyaWVzKSB7XG4gICAgICBsZXQgZnVsbE5hbWUgPSBwYXRoLmpvaW4oZGlyLCBuYW1lKTtcbiAgICAgIGxldCBzdGF0cyA9IGF3YWl0IHBmcy5zdGF0KGZ1bGxOYW1lKTtcblxuICAgICAgaWYgKHN0YXRzLmlzRGlyZWN0b3J5KCkpIHtcbiAgICAgICAgYXdhaXQgcmVjKGZ1bGxOYW1lKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHN0YXRzLmlzRmlsZSgpKSB7XG4gICAgICAgIGF3YWl0IGZ1bmMoZnVsbE5hbWUsIC4uLmFyZ3MpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICByZXR1cm4gcmVjKHJvb3REaXJlY3RvcnkpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZm9yQWxsRmlsZXNTeW5jKHJvb3REaXJlY3RvcnksIGZ1bmMsIC4uLmFyZ3MpIHtcbiAgbGV0IHJlYyA9IChkaXIpID0+IHtcbiAgICBmcy5yZWFkZGlyU3luYyhkaXIpLmZvckVhY2goKG5hbWUpID0+IHtcbiAgICAgIGxldCBmdWxsTmFtZSA9IHBhdGguam9pbihkaXIsIG5hbWUpO1xuICAgICAgbGV0IHN0YXRzID0gZnMuc3RhdFN5bmMoZnVsbE5hbWUpO1xuICAgICAgXG4gICAgICBpZiAoc3RhdHMuaXNEaXJlY3RvcnkoKSkge1xuICAgICAgICByZWMoZnVsbE5hbWUpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBcbiAgICAgIGlmIChzdGF0cy5pc0ZpbGUoKSkge1xuICAgICAgICBmdW5jKGZ1bGxOYW1lLCAuLi5hcmdzKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH0pO1xuICB9O1xuICBcbiAgcmVjKHJvb3REaXJlY3RvcnkpO1xufVxuIl19\n\n//# sourceURL=webpack:///./node_modules/electron-compile/lib/for-all-files.js?')},"./node_modules/electron-compile/lib/index.js":
/*!****************************************************!*\
  !*** ./node_modules/electron-compile/lib/index.js ***!
  \****************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){"use strict";eval('\n\nvar _compileCache = __webpack_require__(/*! ./compile-cache */ "./node_modules/electron-compile/lib/compile-cache.js");\n\nvar _compileCache2 = _interopRequireDefault(_compileCache);\n\nvar _compilerHost = __webpack_require__(/*! ./compiler-host */ "./node_modules/electron-compile/lib/compiler-host.js");\n\nvar _compilerHost2 = _interopRequireDefault(_compilerHost);\n\nvar _configParser = __webpack_require__(/*! ./config-parser */ "./node_modules/electron-compile/lib/config-parser.js");\n\nvar configParser = _interopRequireWildcard(_configParser);\n\nvar _fileChangeCache = __webpack_require__(/*! ./file-change-cache */ "./node_modules/electron-compile/lib/file-change-cache.js");\n\nvar _fileChangeCache2 = _interopRequireDefault(_fileChangeCache);\n\nvar _protocolHook = __webpack_require__(/*! ./protocol-hook */ "./node_modules/electron-compile/lib/protocol-hook.js");\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n// NB: Patch a bug in Electron that affects electron-prebuilt-compile that\n// we can\'t fix any other way. Yes it _does_ feelbadman.jpg\nconst fs = __webpack_require__(/*! fs */ "fs");\nfs.statSyncNoException = fs.statSyncNoException || function () {\n  try {\n    return fs.statSync(...arguments);\n  } catch (e) {\n    return null;\n  }\n};\n\nlet enableLiveReload = null;\nlet watchPath = null;\n\nmodule.exports = Object.assign({\n  // NB: delay-load live-reload so we don\'t load RxJS in production\n  enableLiveReload: function () {\n    enableLiveReload = enableLiveReload || __webpack_require__(/*! ./live-reload */ "./node_modules/electron-compile/lib/live-reload.js").enableLiveReload;\n    return enableLiveReload(...arguments);\n  },\n  watchPath: function () {\n    watchPath = watchPath || __webpack_require__(/*! ./pathwatcher-rx */ "./node_modules/electron-compile/lib/pathwatcher-rx.js").watchPath;\n    return watchPath(...arguments);\n  }\n}, configParser, { CompilerHost: _compilerHost2.default, FileChangedCache: _fileChangeCache2.default, CompileCache: _compileCache2.default, addBypassChecker: _protocolHook.addBypassChecker });\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9pbmRleC5qcyJdLCJuYW1lcyI6WyJjb25maWdQYXJzZXIiLCJmcyIsInJlcXVpcmUiLCJzdGF0U3luY05vRXhjZXB0aW9uIiwic3RhdFN5bmMiLCJlIiwiZW5hYmxlTGl2ZVJlbG9hZCIsIndhdGNoUGF0aCIsIm1vZHVsZSIsImV4cG9ydHMiLCJPYmplY3QiLCJhc3NpZ24iLCJDb21waWxlckhvc3QiLCJGaWxlQ2hhbmdlZENhY2hlIiwiQ29tcGlsZUNhY2hlIiwiYWRkQnlwYXNzQ2hlY2tlciJdLCJtYXBwaW5ncyI6Ijs7QUFBQTs7OztBQUNBOzs7O0FBQ0E7O0lBQVlBLFk7O0FBQ1o7Ozs7QUFDQTs7Ozs7O0FBRUE7QUFDQTtBQUNBLE1BQU1DLEtBQUtDLFFBQVEsSUFBUixDQUFYO0FBQ0FELEdBQUdFLG1CQUFILEdBQXlCRixHQUFHRSxtQkFBSCxJQUEyQixZQUFhO0FBQy9ELE1BQUk7QUFDRixXQUFPRixHQUFHRyxRQUFILENBQVksWUFBWixDQUFQO0FBQ0QsR0FGRCxDQUVFLE9BQU9DLENBQVAsRUFBVTtBQUNWLFdBQU8sSUFBUDtBQUNEO0FBQ0YsQ0FORDs7QUFRQSxJQUFJQyxtQkFBbUIsSUFBdkI7QUFDQSxJQUFJQyxZQUFZLElBQWhCOztBQUVBQyxPQUFPQyxPQUFQLEdBQWlCQyxPQUFPQyxNQUFQLENBQWM7QUFDN0I7QUFDQUwsb0JBQWtCLFlBQWtCO0FBQ2xDQSx1QkFBbUJBLG9CQUFvQkosUUFBUSxlQUFSLEVBQXlCSSxnQkFBaEU7QUFDQSxXQUFPQSxpQkFBaUIsWUFBakIsQ0FBUDtBQUNELEdBTDRCO0FBTTdCQyxhQUFXLFlBQWtCO0FBQzNCQSxnQkFBWUEsYUFBYUwsUUFBUSxrQkFBUixFQUE0QkssU0FBckQ7QUFDQSxXQUFPQSxVQUFVLFlBQVYsQ0FBUDtBQUNEO0FBVDRCLENBQWQsRUFXZlAsWUFYZSxFQVlmLEVBQUVZLG9DQUFGLEVBQWdCQywyQ0FBaEIsRUFBa0NDLG9DQUFsQyxFQUFnREMsZ0RBQWhELEVBWmUsQ0FBakIiLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgQ29tcGlsZUNhY2hlIGZyb20gJy4vY29tcGlsZS1jYWNoZSc7XG5pbXBvcnQgQ29tcGlsZXJIb3N0IGZyb20gJy4vY29tcGlsZXItaG9zdCc7XG5pbXBvcnQgKiBhcyBjb25maWdQYXJzZXIgZnJvbSAnLi9jb25maWctcGFyc2VyJztcbmltcG9ydCBGaWxlQ2hhbmdlZENhY2hlIGZyb20gJy4vZmlsZS1jaGFuZ2UtY2FjaGUnO1xuaW1wb3J0IHthZGRCeXBhc3NDaGVja2VyfSBmcm9tICcuL3Byb3RvY29sLWhvb2snO1xuXG4vLyBOQjogUGF0Y2ggYSBidWcgaW4gRWxlY3Ryb24gdGhhdCBhZmZlY3RzIGVsZWN0cm9uLXByZWJ1aWx0LWNvbXBpbGUgdGhhdFxuLy8gd2UgY2FuJ3QgZml4IGFueSBvdGhlciB3YXkuIFllcyBpdCBfZG9lc18gZmVlbGJhZG1hbi5qcGdcbmNvbnN0IGZzID0gcmVxdWlyZSgnZnMnKTtcbmZzLnN0YXRTeW5jTm9FeGNlcHRpb24gPSBmcy5zdGF0U3luY05vRXhjZXB0aW9uIHx8ICgoLi4uYXJncykgPT4ge1xuICB0cnkge1xuICAgIHJldHVybiBmcy5zdGF0U3luYyguLi5hcmdzKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG59KTtcblxubGV0IGVuYWJsZUxpdmVSZWxvYWQgPSBudWxsO1xubGV0IHdhdGNoUGF0aCA9IG51bGw7XG5cbm1vZHVsZS5leHBvcnRzID0gT2JqZWN0LmFzc2lnbih7XG4gIC8vIE5COiBkZWxheS1sb2FkIGxpdmUtcmVsb2FkIHNvIHdlIGRvbid0IGxvYWQgUnhKUyBpbiBwcm9kdWN0aW9uXG4gIGVuYWJsZUxpdmVSZWxvYWQ6IGZ1bmN0aW9uKC4uLmFyZ3MpIHtcbiAgICBlbmFibGVMaXZlUmVsb2FkID0gZW5hYmxlTGl2ZVJlbG9hZCB8fCByZXF1aXJlKCcuL2xpdmUtcmVsb2FkJykuZW5hYmxlTGl2ZVJlbG9hZDtcbiAgICByZXR1cm4gZW5hYmxlTGl2ZVJlbG9hZCguLi5hcmdzKTtcbiAgfSxcbiAgd2F0Y2hQYXRoOiBmdW5jdGlvbiguLi5hcmdzKSB7XG4gICAgd2F0Y2hQYXRoID0gd2F0Y2hQYXRoIHx8IHJlcXVpcmUoJy4vcGF0aHdhdGNoZXItcngnKS53YXRjaFBhdGg7XG4gICAgcmV0dXJuIHdhdGNoUGF0aCguLi5hcmdzKTtcbiAgfSxcbn0sXG4gIGNvbmZpZ1BhcnNlcixcbiAgeyBDb21waWxlckhvc3QsIEZpbGVDaGFuZ2VkQ2FjaGUsIENvbXBpbGVDYWNoZSwgYWRkQnlwYXNzQ2hlY2tlciB9XG4pO1xuIl19\n\n//# sourceURL=webpack:///./node_modules/electron-compile/lib/index.js?')},"./node_modules/electron-compile/lib/live-reload.js":
/*!**********************************************************!*\
  !*** ./node_modules/electron-compile/lib/live-reload.js ***!
  \**********************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", {\n  value: true\n});\nexports.enableLiveReload = enableLiveReload;\n\nvar _fileChangeCache = __webpack_require__(/*! ./file-change-cache */ "./node_modules/electron-compile/lib/file-change-cache.js");\n\nvar _fileChangeCache2 = _interopRequireDefault(_fileChangeCache);\n\nvar _pathwatcherRx = __webpack_require__(/*! ./pathwatcher-rx */ "./node_modules/electron-compile/lib/pathwatcher-rx.js");\n\nvar _Observable = __webpack_require__(/*! rxjs/Observable */ "./node_modules/electron-compile/node_modules/rxjs/Observable.js");\n\n__webpack_require__(/*! ./custom-operators */ "./node_modules/electron-compile/lib/custom-operators.js");\n\n__webpack_require__(/*! rxjs/add/observable/defer */ "./node_modules/electron-compile/node_modules/rxjs/add/observable/defer.js");\n\n__webpack_require__(/*! rxjs/add/observable/empty */ "./node_modules/electron-compile/node_modules/rxjs/add/observable/empty.js");\n\n__webpack_require__(/*! rxjs/add/observable/fromPromise */ "./node_modules/electron-compile/node_modules/rxjs/add/observable/fromPromise.js");\n\n__webpack_require__(/*! rxjs/add/operator/catch */ "./node_modules/electron-compile/node_modules/rxjs/add/operator/catch.js");\n\n__webpack_require__(/*! rxjs/add/operator/filter */ "./node_modules/electron-compile/node_modules/rxjs/add/operator/filter.js");\n\n__webpack_require__(/*! rxjs/add/operator/mergeMap */ "./node_modules/electron-compile/node_modules/rxjs/add/operator/mergeMap.js");\n\n__webpack_require__(/*! rxjs/add/operator/switchMap */ "./node_modules/electron-compile/node_modules/rxjs/add/operator/switchMap.js");\n\n__webpack_require__(/*! rxjs/add/operator/timeout */ "./node_modules/electron-compile/node_modules/rxjs/add/operator/timeout.js");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction enableLiveReload() {\n  let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  let strategy = options.strategy;\n\n\n  if (process.type !== \'browser\' || !global.globalCompilerHost) throw new Error("Call this from the browser process, right after initializing electron-compile");\n\n  switch (strategy) {\n    case \'react-hmr\':\n      enableReactHMR();\n      break;\n    case \'naive\':\n    default:\n      enableLiveReloadNaive();\n  }\n}\n\nlet BrowserWindow;\nif (process.type === \'browser\') {\n  BrowserWindow = __webpack_require__(/*! electron */ "electron").BrowserWindow;\n}\n\nfunction reloadAllWindows() {\n  let ret = BrowserWindow.getAllWindows().map(wnd => {\n    if (!wnd.isVisible()) return Promise.resolve(true);\n\n    return new Promise(res => {\n      wnd.webContents.reloadIgnoringCache();\n      wnd.once(\'ready-to-show\', () => res(true));\n    });\n  });\n\n  return Promise.all(ret);\n}\n\nfunction enableLiveReloadNaive() {\n  let filesWeCareAbout = global.globalCompilerHost.listenToCompileEvents().filter(x => !_fileChangeCache2.default.isInNodeModules(x.filePath));\n\n  let weShouldReload = filesWeCareAbout.mergeMap(x => (0, _pathwatcherRx.watchPath)(x.filePath).map(() => x)).guaranteedThrottle(1 * 1000);\n\n  return weShouldReload.switchMap(() => _Observable.Observable.defer(() => _Observable.Observable.fromPromise(reloadAllWindows()).timeout(5 * 1000).catch(() => _Observable.Observable.empty()))).subscribe(() => console.log("Reloaded all windows!"));\n}\n\nfunction triggerHMRInRenderers() {\n  BrowserWindow.getAllWindows().forEach(window => {\n    window.webContents.send(\'__electron-compile__HMR\');\n  });\n\n  return Promise.resolve(true);\n}\n\nfunction enableReactHMR() {\n  global.__electron_compile_hmr_enabled__ = true;\n\n  let filesWeCareAbout = global.globalCompilerHost.listenToCompileEvents().filter(x => !_fileChangeCache2.default.isInNodeModules(x.filePath));\n\n  let weShouldReload = filesWeCareAbout.mergeMap(x => (0, _pathwatcherRx.watchPath)(x.filePath).map(() => x)).guaranteedThrottle(1 * 1000);\n\n  return weShouldReload.switchMap(() => _Observable.Observable.defer(() => _Observable.Observable.fromPromise(triggerHMRInRenderers()).catch(() => _Observable.Observable.empty()))).subscribe(() => console.log("HMR sent to all windows!"));\n}\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9saXZlLXJlbG9hZC5qcyJdLCJuYW1lcyI6WyJlbmFibGVMaXZlUmVsb2FkIiwib3B0aW9ucyIsInN0cmF0ZWd5IiwicHJvY2VzcyIsInR5cGUiLCJnbG9iYWwiLCJnbG9iYWxDb21waWxlckhvc3QiLCJFcnJvciIsImVuYWJsZVJlYWN0SE1SIiwiZW5hYmxlTGl2ZVJlbG9hZE5haXZlIiwiQnJvd3NlcldpbmRvdyIsInJlcXVpcmUiLCJyZWxvYWRBbGxXaW5kb3dzIiwicmV0IiwiZ2V0QWxsV2luZG93cyIsIm1hcCIsInduZCIsImlzVmlzaWJsZSIsIlByb21pc2UiLCJyZXNvbHZlIiwicmVzIiwid2ViQ29udGVudHMiLCJyZWxvYWRJZ25vcmluZ0NhY2hlIiwib25jZSIsImFsbCIsImZpbGVzV2VDYXJlQWJvdXQiLCJsaXN0ZW5Ub0NvbXBpbGVFdmVudHMiLCJmaWx0ZXIiLCJ4IiwiRmlsZUNoYW5nZWRDYWNoZSIsImlzSW5Ob2RlTW9kdWxlcyIsImZpbGVQYXRoIiwid2VTaG91bGRSZWxvYWQiLCJtZXJnZU1hcCIsImd1YXJhbnRlZWRUaHJvdHRsZSIsInN3aXRjaE1hcCIsIk9ic2VydmFibGUiLCJkZWZlciIsImZyb21Qcm9taXNlIiwidGltZW91dCIsImNhdGNoIiwiZW1wdHkiLCJzdWJzY3JpYmUiLCJjb25zb2xlIiwibG9nIiwidHJpZ2dlckhNUkluUmVuZGVyZXJzIiwiZm9yRWFjaCIsIndpbmRvdyIsInNlbmQiLCJfX2VsZWN0cm9uX2NvbXBpbGVfaG1yX2VuYWJsZWRfXyJdLCJtYXBwaW5ncyI6Ijs7Ozs7UUFnQmdCQSxnQixHQUFBQSxnQjs7QUFoQmhCOzs7O0FBQ0E7O0FBQ0E7O0FBRUE7O0FBRUE7O0FBQ0E7O0FBQ0E7O0FBRUE7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7Ozs7QUFFTyxTQUFTQSxnQkFBVCxHQUFzQztBQUFBLE1BQVpDLE9BQVksdUVBQUosRUFBSTtBQUFBLE1BQ3JDQyxRQURxQyxHQUN4QkQsT0FEd0IsQ0FDckNDLFFBRHFDOzs7QUFHM0MsTUFBSUMsUUFBUUMsSUFBUixLQUFpQixTQUFqQixJQUE4QixDQUFDQyxPQUFPQyxrQkFBMUMsRUFBOEQsTUFBTSxJQUFJQyxLQUFKLENBQVUsK0VBQVYsQ0FBTjs7QUFFOUQsVUFBT0wsUUFBUDtBQUNBLFNBQUssV0FBTDtBQUNFTTtBQUNBO0FBQ0YsU0FBSyxPQUFMO0FBQ0E7QUFDRUM7QUFORjtBQVFEOztBQUVELElBQUlDLGFBQUo7QUFDQSxJQUFJUCxRQUFRQyxJQUFSLEtBQWlCLFNBQXJCLEVBQWdDO0FBQzlCTSxrQkFBZ0JDLFFBQVEsVUFBUixFQUFvQkQsYUFBcEM7QUFDRDs7QUFFRCxTQUFTRSxnQkFBVCxHQUE0QjtBQUMxQixNQUFJQyxNQUFNSCxjQUFjSSxhQUFkLEdBQThCQyxHQUE5QixDQUFrQ0MsT0FBTztBQUNqRCxRQUFJLENBQUNBLElBQUlDLFNBQUosRUFBTCxFQUFzQixPQUFPQyxRQUFRQyxPQUFSLENBQWdCLElBQWhCLENBQVA7O0FBRXRCLFdBQU8sSUFBSUQsT0FBSixDQUFhRSxHQUFELElBQVM7QUFDMUJKLFVBQUlLLFdBQUosQ0FBZ0JDLG1CQUFoQjtBQUNBTixVQUFJTyxJQUFKLENBQVMsZUFBVCxFQUEwQixNQUFNSCxJQUFJLElBQUosQ0FBaEM7QUFDRCxLQUhNLENBQVA7QUFJRCxHQVBTLENBQVY7O0FBU0EsU0FBT0YsUUFBUU0sR0FBUixDQUFZWCxHQUFaLENBQVA7QUFDRDs7QUFFRCxTQUFTSixxQkFBVCxHQUFpQztBQUMvQixNQUFJZ0IsbUJBQW1CcEIsT0FBT0Msa0JBQVAsQ0FBMEJvQixxQkFBMUIsR0FDcEJDLE1BRG9CLENBQ2JDLEtBQUssQ0FBQ0MsMEJBQWlCQyxlQUFqQixDQUFpQ0YsRUFBRUcsUUFBbkMsQ0FETyxDQUF2Qjs7QUFHQSxNQUFJQyxpQkFBaUJQLGlCQUNsQlEsUUFEa0IsQ0FDVEwsS0FBSyw4QkFBVUEsRUFBRUcsUUFBWixFQUFzQmhCLEdBQXRCLENBQTBCLE1BQU1hLENBQWhDLENBREksRUFFbEJNLGtCQUZrQixDQUVDLElBQUUsSUFGSCxDQUFyQjs7QUFJQSxTQUFPRixlQUNKRyxTQURJLENBQ00sTUFBTUMsdUJBQVdDLEtBQVgsQ0FBaUIsTUFBTUQsdUJBQVdFLFdBQVgsQ0FBdUIxQixrQkFBdkIsRUFBMkMyQixPQUEzQyxDQUFtRCxJQUFFLElBQXJELEVBQTJEQyxLQUEzRCxDQUFpRSxNQUFNSix1QkFBV0ssS0FBWCxFQUF2RSxDQUF2QixDQURaLEVBRUpDLFNBRkksQ0FFTSxNQUFNQyxRQUFRQyxHQUFSLENBQVksdUJBQVosQ0FGWixDQUFQO0FBR0Q7O0FBRUQsU0FBU0MscUJBQVQsR0FBaUM7QUFDL0JuQyxnQkFBY0ksYUFBZCxHQUE4QmdDLE9BQTlCLENBQXVDQyxNQUFELElBQVk7QUFDaERBLFdBQU8xQixXQUFQLENBQW1CMkIsSUFBbkIsQ0FBd0IseUJBQXhCO0FBQ0QsR0FGRDs7QUFJQSxTQUFPOUIsUUFBUUMsT0FBUixDQUFnQixJQUFoQixDQUFQO0FBQ0Q7O0FBRUQsU0FBU1gsY0FBVCxHQUEwQjtBQUN4QkgsU0FBTzRDLGdDQUFQLEdBQTBDLElBQTFDOztBQUVBLE1BQUl4QixtQkFBbUJwQixPQUFPQyxrQkFBUCxDQUEwQm9CLHFCQUExQixHQUNwQkMsTUFEb0IsQ0FDYkMsS0FBSyxDQUFDQywwQkFBaUJDLGVBQWpCLENBQWlDRixFQUFFRyxRQUFuQyxDQURPLENBQXZCOztBQUdBLE1BQUlDLGlCQUFpQlAsaUJBQ2xCUSxRQURrQixDQUNUTCxLQUFLLDhCQUFVQSxFQUFFRyxRQUFaLEVBQXNCaEIsR0FBdEIsQ0FBMEIsTUFBTWEsQ0FBaEMsQ0FESSxFQUVsQk0sa0JBRmtCLENBRUMsSUFBRSxJQUZILENBQXJCOztBQUlBLFNBQU9GLGVBQ0pHLFNBREksQ0FDTSxNQUFNQyx1QkFBV0MsS0FBWCxDQUFpQixNQUFNRCx1QkFBV0UsV0FBWCxDQUF1Qk8sdUJBQXZCLEVBQWdETCxLQUFoRCxDQUFzRCxNQUFNSix1QkFBV0ssS0FBWCxFQUE1RCxDQUF2QixDQURaLEVBRUpDLFNBRkksQ0FFTSxNQUFNQyxRQUFRQyxHQUFSLENBQVksMEJBQVosQ0FGWixDQUFQO0FBR0QiLCJmaWxlIjoibGl2ZS1yZWxvYWQuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgRmlsZUNoYW5nZWRDYWNoZSBmcm9tICcuL2ZpbGUtY2hhbmdlLWNhY2hlJztcbmltcG9ydCB7d2F0Y2hQYXRofSBmcm9tICcuL3BhdGh3YXRjaGVyLXJ4JztcbmltcG9ydCB7T2JzZXJ2YWJsZX0gZnJvbSAncnhqcy9PYnNlcnZhYmxlJztcblxuaW1wb3J0ICcuL2N1c3RvbS1vcGVyYXRvcnMnO1xuXG5pbXBvcnQgJ3J4anMvYWRkL29ic2VydmFibGUvZGVmZXInO1xuaW1wb3J0ICdyeGpzL2FkZC9vYnNlcnZhYmxlL2VtcHR5JztcbmltcG9ydCAncnhqcy9hZGQvb2JzZXJ2YWJsZS9mcm9tUHJvbWlzZSc7XG5cbmltcG9ydCAncnhqcy9hZGQvb3BlcmF0b3IvY2F0Y2gnO1xuaW1wb3J0ICdyeGpzL2FkZC9vcGVyYXRvci9maWx0ZXInO1xuaW1wb3J0ICdyeGpzL2FkZC9vcGVyYXRvci9tZXJnZU1hcCc7XG5pbXBvcnQgJ3J4anMvYWRkL29wZXJhdG9yL3N3aXRjaE1hcCc7XG5pbXBvcnQgJ3J4anMvYWRkL29wZXJhdG9yL3RpbWVvdXQnO1xuXG5leHBvcnQgZnVuY3Rpb24gZW5hYmxlTGl2ZVJlbG9hZChvcHRpb25zPXt9KSB7XG4gIGxldCB7IHN0cmF0ZWd5IH0gPSBvcHRpb25zO1xuXG4gIGlmIChwcm9jZXNzLnR5cGUgIT09ICdicm93c2VyJyB8fCAhZ2xvYmFsLmdsb2JhbENvbXBpbGVySG9zdCkgdGhyb3cgbmV3IEVycm9yKFwiQ2FsbCB0aGlzIGZyb20gdGhlIGJyb3dzZXIgcHJvY2VzcywgcmlnaHQgYWZ0ZXIgaW5pdGlhbGl6aW5nIGVsZWN0cm9uLWNvbXBpbGVcIik7XG5cbiAgc3dpdGNoKHN0cmF0ZWd5KSB7XG4gIGNhc2UgJ3JlYWN0LWhtcic6XG4gICAgZW5hYmxlUmVhY3RITVIoKTtcbiAgICBicmVhaztcbiAgY2FzZSAnbmFpdmUnOlxuICBkZWZhdWx0OlxuICAgIGVuYWJsZUxpdmVSZWxvYWROYWl2ZSgpO1xuICB9XG59XG5cbmxldCBCcm93c2VyV2luZG93O1xuaWYgKHByb2Nlc3MudHlwZSA9PT0gJ2Jyb3dzZXInKSB7XG4gIEJyb3dzZXJXaW5kb3cgPSByZXF1aXJlKCdlbGVjdHJvbicpLkJyb3dzZXJXaW5kb3c7XG59XG5cbmZ1bmN0aW9uIHJlbG9hZEFsbFdpbmRvd3MoKSB7XG4gIGxldCByZXQgPSBCcm93c2VyV2luZG93LmdldEFsbFdpbmRvd3MoKS5tYXAod25kID0+IHtcbiAgICBpZiAoIXduZC5pc1Zpc2libGUoKSkgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0cnVlKTtcblxuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzKSA9PiB7XG4gICAgICB3bmQud2ViQ29udGVudHMucmVsb2FkSWdub3JpbmdDYWNoZSgpO1xuICAgICAgd25kLm9uY2UoJ3JlYWR5LXRvLXNob3cnLCAoKSA9PiByZXModHJ1ZSkpO1xuICAgIH0pO1xuICB9KTtcblxuICByZXR1cm4gUHJvbWlzZS5hbGwocmV0KTtcbn1cblxuZnVuY3Rpb24gZW5hYmxlTGl2ZVJlbG9hZE5haXZlKCkge1xuICBsZXQgZmlsZXNXZUNhcmVBYm91dCA9IGdsb2JhbC5nbG9iYWxDb21waWxlckhvc3QubGlzdGVuVG9Db21waWxlRXZlbnRzKClcbiAgICAuZmlsdGVyKHggPT4gIUZpbGVDaGFuZ2VkQ2FjaGUuaXNJbk5vZGVNb2R1bGVzKHguZmlsZVBhdGgpKTtcblxuICBsZXQgd2VTaG91bGRSZWxvYWQgPSBmaWxlc1dlQ2FyZUFib3V0XG4gICAgLm1lcmdlTWFwKHggPT4gd2F0Y2hQYXRoKHguZmlsZVBhdGgpLm1hcCgoKSA9PiB4KSlcbiAgICAuZ3VhcmFudGVlZFRocm90dGxlKDEqMTAwMCk7XG5cbiAgcmV0dXJuIHdlU2hvdWxkUmVsb2FkXG4gICAgLnN3aXRjaE1hcCgoKSA9PiBPYnNlcnZhYmxlLmRlZmVyKCgpID0+IE9ic2VydmFibGUuZnJvbVByb21pc2UocmVsb2FkQWxsV2luZG93cygpKS50aW1lb3V0KDUqMTAwMCkuY2F0Y2goKCkgPT4gT2JzZXJ2YWJsZS5lbXB0eSgpKSkpXG4gICAgLnN1YnNjcmliZSgoKSA9PiBjb25zb2xlLmxvZyhcIlJlbG9hZGVkIGFsbCB3aW5kb3dzIVwiKSk7XG59XG5cbmZ1bmN0aW9uIHRyaWdnZXJITVJJblJlbmRlcmVycygpIHtcbiAgQnJvd3NlcldpbmRvdy5nZXRBbGxXaW5kb3dzKCkuZm9yRWFjaCgod2luZG93KSA9PiB7XG4gICAgd2luZG93LndlYkNvbnRlbnRzLnNlbmQoJ19fZWxlY3Ryb24tY29tcGlsZV9fSE1SJyk7XG4gIH0pO1xuXG4gIHJldHVybiBQcm9taXNlLnJlc29sdmUodHJ1ZSk7XG59XG5cbmZ1bmN0aW9uIGVuYWJsZVJlYWN0SE1SKCkge1xuICBnbG9iYWwuX19lbGVjdHJvbl9jb21waWxlX2htcl9lbmFibGVkX18gPSB0cnVlO1xuXG4gIGxldCBmaWxlc1dlQ2FyZUFib3V0ID0gZ2xvYmFsLmdsb2JhbENvbXBpbGVySG9zdC5saXN0ZW5Ub0NvbXBpbGVFdmVudHMoKVxuICAgIC5maWx0ZXIoeCA9PiAhRmlsZUNoYW5nZWRDYWNoZS5pc0luTm9kZU1vZHVsZXMoeC5maWxlUGF0aCkpO1xuXG4gIGxldCB3ZVNob3VsZFJlbG9hZCA9IGZpbGVzV2VDYXJlQWJvdXRcbiAgICAubWVyZ2VNYXAoeCA9PiB3YXRjaFBhdGgoeC5maWxlUGF0aCkubWFwKCgpID0+IHgpKVxuICAgIC5ndWFyYW50ZWVkVGhyb3R0bGUoMSoxMDAwKTtcblxuICByZXR1cm4gd2VTaG91bGRSZWxvYWRcbiAgICAuc3dpdGNoTWFwKCgpID0+IE9ic2VydmFibGUuZGVmZXIoKCkgPT4gT2JzZXJ2YWJsZS5mcm9tUHJvbWlzZSh0cmlnZ2VySE1SSW5SZW5kZXJlcnMoKSkuY2F0Y2goKCkgPT4gT2JzZXJ2YWJsZS5lbXB0eSgpKSkpXG4gICAgLnN1YnNjcmliZSgoKSA9PiBjb25zb2xlLmxvZyhcIkhNUiBzZW50IHRvIGFsbCB3aW5kb3dzIVwiKSk7XG59XG4iXX0=\n\n//# sourceURL=webpack:///./node_modules/electron-compile/lib/live-reload.js?')},"./node_modules/electron-compile/lib/pathwatcher-rx.js":
/*!*************************************************************!*\
  !*** ./node_modules/electron-compile/lib/pathwatcher-rx.js ***!
  \*************************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", {\n  value: true\n});\nexports.watchPathDirect = watchPathDirect;\nexports.watchPath = watchPath;\n\nvar _fs = __webpack_require__(/*! fs */ "fs");\n\nvar _fs2 = _interopRequireDefault(_fs);\n\nvar _Observable = __webpack_require__(/*! rxjs/Observable */ "./node_modules/electron-compile/node_modules/rxjs/Observable.js");\n\nvar _Subscription = __webpack_require__(/*! rxjs/Subscription */ "./node_modules/electron-compile/node_modules/rxjs/Subscription.js");\n\nvar _lruCache = __webpack_require__(/*! lru-cache */ "./node_modules/lru-cache/index.js");\n\nvar _lruCache2 = _interopRequireDefault(_lruCache);\n\n__webpack_require__(/*! rxjs/add/operator/publish */ "./node_modules/electron-compile/node_modules/rxjs/add/operator/publish.js");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction watchPathDirect(directory) {\n  return _Observable.Observable.create(subj => {\n    let dead = false;\n\n    const watcher = _fs2.default.watch(directory, {}, (eventType, fileName) => {\n      if (dead) return;\n      subj.next({ eventType, fileName });\n    });\n\n    watcher.on(\'error\', e => {\n      dead = true;\n      subj.error(e);\n    });\n\n    return new _Subscription.Subscription(() => {\n      if (!dead) {\n        watcher.close();\n      }\n    });\n  });\n}\n\nconst pathCache = new _lruCache2.default({ length: 256 });\nfunction watchPath(directory) {\n  let ret = pathCache.get(directory);\n  if (ret) return ret;\n\n  ret = watchPathDirect(directory).publish().refCount();\n  pathCache.set(directory, ret);\n  return ret;\n}\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9wYXRod2F0Y2hlci1yeC5qcyJdLCJuYW1lcyI6WyJ3YXRjaFBhdGhEaXJlY3QiLCJ3YXRjaFBhdGgiLCJkaXJlY3RvcnkiLCJPYnNlcnZhYmxlIiwiY3JlYXRlIiwic3ViaiIsImRlYWQiLCJ3YXRjaGVyIiwiZnMiLCJ3YXRjaCIsImV2ZW50VHlwZSIsImZpbGVOYW1lIiwibmV4dCIsIm9uIiwiZSIsImVycm9yIiwiU3Vic2NyaXB0aW9uIiwiY2xvc2UiLCJwYXRoQ2FjaGUiLCJMUlUiLCJsZW5ndGgiLCJyZXQiLCJnZXQiLCJwdWJsaXNoIiwicmVmQ291bnQiLCJzZXQiXSwibWFwcGluZ3MiOiI7Ozs7O1FBT2dCQSxlLEdBQUFBLGU7UUFtQkFDLFMsR0FBQUEsUzs7QUExQmhCOzs7O0FBQ0E7O0FBQ0E7O0FBQ0E7Ozs7QUFFQTs7OztBQUVPLFNBQVNELGVBQVQsQ0FBeUJFLFNBQXpCLEVBQW9DO0FBQ3pDLFNBQU9DLHVCQUFXQyxNQUFYLENBQW1CQyxJQUFELElBQVU7QUFDakMsUUFBSUMsT0FBTyxLQUFYOztBQUVBLFVBQU1DLFVBQVVDLGFBQUdDLEtBQUgsQ0FBU1AsU0FBVCxFQUFvQixFQUFwQixFQUF3QixDQUFDUSxTQUFELEVBQVlDLFFBQVosS0FBeUI7QUFDL0QsVUFBSUwsSUFBSixFQUFVO0FBQ1ZELFdBQUtPLElBQUwsQ0FBVSxFQUFDRixTQUFELEVBQVlDLFFBQVosRUFBVjtBQUNELEtBSGUsQ0FBaEI7O0FBS0FKLFlBQVFNLEVBQVIsQ0FBVyxPQUFYLEVBQXFCQyxDQUFELElBQU87QUFDekJSLGFBQU8sSUFBUDtBQUNBRCxXQUFLVSxLQUFMLENBQVdELENBQVg7QUFDRCxLQUhEOztBQUtBLFdBQU8sSUFBSUUsMEJBQUosQ0FBaUIsTUFBTTtBQUFFLFVBQUksQ0FBQ1YsSUFBTCxFQUFXO0FBQUVDLGdCQUFRVSxLQUFSO0FBQWtCO0FBQUUsS0FBMUQsQ0FBUDtBQUNELEdBZE0sQ0FBUDtBQWVEOztBQUVELE1BQU1DLFlBQVksSUFBSUMsa0JBQUosQ0FBUSxFQUFFQyxRQUFRLEdBQVYsRUFBUixDQUFsQjtBQUNPLFNBQVNuQixTQUFULENBQW1CQyxTQUFuQixFQUE4QjtBQUNuQyxNQUFJbUIsTUFBTUgsVUFBVUksR0FBVixDQUFjcEIsU0FBZCxDQUFWO0FBQ0EsTUFBSW1CLEdBQUosRUFBUyxPQUFPQSxHQUFQOztBQUVUQSxRQUFNckIsZ0JBQWdCRSxTQUFoQixFQUEyQnFCLE9BQTNCLEdBQXFDQyxRQUFyQyxFQUFOO0FBQ0FOLFlBQVVPLEdBQVYsQ0FBY3ZCLFNBQWQsRUFBeUJtQixHQUF6QjtBQUNBLFNBQU9BLEdBQVA7QUFDRCIsImZpbGUiOiJwYXRod2F0Y2hlci1yeC5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBmcyBmcm9tICdmcyc7XG5pbXBvcnQge09ic2VydmFibGV9IGZyb20gJ3J4anMvT2JzZXJ2YWJsZSc7XG5pbXBvcnQge1N1YnNjcmlwdGlvbn0gZnJvbSAncnhqcy9TdWJzY3JpcHRpb24nO1xuaW1wb3J0IExSVSBmcm9tICdscnUtY2FjaGUnO1xuXG5pbXBvcnQgJ3J4anMvYWRkL29wZXJhdG9yL3B1Ymxpc2gnO1xuXG5leHBvcnQgZnVuY3Rpb24gd2F0Y2hQYXRoRGlyZWN0KGRpcmVjdG9yeSkge1xuICByZXR1cm4gT2JzZXJ2YWJsZS5jcmVhdGUoKHN1YmopID0+IHtcbiAgICBsZXQgZGVhZCA9IGZhbHNlO1xuXG4gICAgY29uc3Qgd2F0Y2hlciA9IGZzLndhdGNoKGRpcmVjdG9yeSwge30sIChldmVudFR5cGUsIGZpbGVOYW1lKSA9PiB7XG4gICAgICBpZiAoZGVhZCkgcmV0dXJuO1xuICAgICAgc3Viai5uZXh0KHtldmVudFR5cGUsIGZpbGVOYW1lfSk7XG4gICAgfSk7XG5cbiAgICB3YXRjaGVyLm9uKCdlcnJvcicsIChlKSA9PiB7XG4gICAgICBkZWFkID0gdHJ1ZTtcbiAgICAgIHN1YmouZXJyb3IoZSk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gbmV3IFN1YnNjcmlwdGlvbigoKSA9PiB7IGlmICghZGVhZCkgeyB3YXRjaGVyLmNsb3NlKCk7IH0gfSk7XG4gIH0pO1xufVxuXG5jb25zdCBwYXRoQ2FjaGUgPSBuZXcgTFJVKHsgbGVuZ3RoOiAyNTYgfSk7XG5leHBvcnQgZnVuY3Rpb24gd2F0Y2hQYXRoKGRpcmVjdG9yeSkge1xuICBsZXQgcmV0ID0gcGF0aENhY2hlLmdldChkaXJlY3RvcnkpO1xuICBpZiAocmV0KSByZXR1cm4gcmV0O1xuXG4gIHJldCA9IHdhdGNoUGF0aERpcmVjdChkaXJlY3RvcnkpLnB1Ymxpc2goKS5yZWZDb3VudCgpO1xuICBwYXRoQ2FjaGUuc2V0KGRpcmVjdG9yeSwgcmV0KTtcbiAgcmV0dXJuIHJldDtcbn1cbiJdfQ==\n\n//# sourceURL=webpack:///./node_modules/electron-compile/lib/pathwatcher-rx.js?')},"./node_modules/electron-compile/lib/promise.js":
/*!******************************************************!*\
  !*** ./node_modules/electron-compile/lib/promise.js ***!
  \******************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", {\n  value: true\n});\nexports.pzlib = exports.pfs = undefined;\n\nvar _pify = __webpack_require__(/*! pify */ "./node_modules/pify/index.js");\n\nvar _pify2 = _interopRequireDefault(_pify);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n// NB: We do this so that every module doesn\'t have to run pify\n// on fs and zlib\n\n\n/**\n * @private\n */\nconst pfs = exports.pfs = (0, _pify2.default)(__webpack_require__(/*! fs */ "fs"));\n\n/**\n * @private\n */\nconst pzlib = exports.pzlib = (0, _pify2.default)(__webpack_require__(/*! zlib */ "zlib"));\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9wcm9taXNlLmpzIl0sIm5hbWVzIjpbInBmcyIsInJlcXVpcmUiLCJwemxpYiJdLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBOzs7Ozs7QUFFQTtBQUNBOzs7QUFHQTs7O0FBR08sTUFBTUEsb0JBQU0sb0JBQUtDLFFBQVEsSUFBUixDQUFMLENBQVo7O0FBRVA7OztBQUdPLE1BQU1DLHdCQUFRLG9CQUFLRCxRQUFRLE1BQVIsQ0FBTCxDQUFkIiwiZmlsZSI6InByb21pc2UuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgcGlmeSBmcm9tICdwaWZ5JztcblxuLy8gTkI6IFdlIGRvIHRoaXMgc28gdGhhdCBldmVyeSBtb2R1bGUgZG9lc24ndCBoYXZlIHRvIHJ1biBwaWZ5XG4vLyBvbiBmcyBhbmQgemxpYlxuXG5cbi8qKlxuICogQHByaXZhdGVcbiAqLyBcbmV4cG9ydCBjb25zdCBwZnMgPSBwaWZ5KHJlcXVpcmUoJ2ZzJykpO1xuXG4vKipcbiAqIEBwcml2YXRlXG4gKi8gXG5leHBvcnQgY29uc3QgcHpsaWIgPSBwaWZ5KHJlcXVpcmUoJ3psaWInKSk7XG4iXX0=\n\n//# sourceURL=webpack:///./node_modules/electron-compile/lib/promise.js?')},"./node_modules/electron-compile/lib/protocol-hook.js":
/*!************************************************************!*\
  !*** ./node_modules/electron-compile/lib/protocol-hook.js ***!
  \************************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){"use strict";eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.rigHtmlDocumentToInitializeElectronCompile = rigHtmlDocumentToInitializeElectronCompile;\nexports.addBypassChecker = addBypassChecker;\nexports.initializeProtocolHook = initializeProtocolHook;\n\nvar _url = __webpack_require__(/*! url */ \"url\");\n\nvar _url2 = _interopRequireDefault(_url);\n\nvar _fs = __webpack_require__(/*! fs */ \"fs\");\n\nvar _fs2 = _interopRequireDefault(_fs);\n\nvar _mimeTypes = __webpack_require__(/*! @paulcbetts/mime-types */ \"./node_modules/@paulcbetts/mime-types/index.js\");\n\nvar _mimeTypes2 = _interopRequireDefault(_mimeTypes);\n\nvar _lruCache = __webpack_require__(/*! lru-cache */ \"./node_modules/lru-cache/index.js\");\n\nvar _lruCache2 = _interopRequireDefault(_lruCache);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step(\"next\", value); }, function (err) { step(\"throw\", err); }); } } return step(\"next\"); }); }; }\n\nconst magicWords = \"__magic__file__to__help__electron__compile.js\";\n\n// NB: These are duped in initialize-renderer so we can save startup time, make\n// sure to run both!\nconst magicGlobalForRootCacheDir = '__electron_compile_root_cache_dir';\nconst magicGlobalForAppRootDir = '__electron_compile_app_root_dir';\n\nconst d = __webpack_require__(/*! debug */ \"./node_modules/debug/src/index.js\")('electron-compile:protocol-hook');\n\nlet protocol = null;\n\nconst mapStatCache = new _lruCache2.default({ length: 512 });\nfunction doesMapFileExist(filePath) {\n  let ret = mapStatCache.get(filePath);\n  if (ret !== undefined) return Promise.resolve(ret);\n\n  return new Promise(res => {\n    _fs2.default.lstat(filePath, (err, s) => {\n      let failed = err || !s;\n\n      mapStatCache.set(filePath, !failed);\n      res(!failed);\n    });\n  });\n}\n\n/**\n * Adds our script header to the top of all HTML files\n *\n * @private\n */\nfunction rigHtmlDocumentToInitializeElectronCompile(doc) {\n  let lines = doc.split(\"\\n\");\n  let replacement = `<head><script src=\"${magicWords}\"><\/script>`;\n  let replacedHead = false;\n\n  for (let i = 0; i < lines.length; i++) {\n    if (!lines[i].match(/<head>/i)) continue;\n\n    lines[i] = lines[i].replace(/<head>/i, replacement);\n    replacedHead = true;\n    break;\n  }\n\n  if (!replacedHead) {\n    replacement = `<html$1><head><script src=\"${magicWords}\"><\/script></head>`;\n    for (let i = 0; i < lines.length; i++) {\n      if (!lines[i].match(/<html/i)) continue;\n\n      lines[i] = lines[i].replace(/<html([^>]+)>/i, replacement);\n      break;\n    }\n  }\n\n  return lines.join(\"\\n\");\n}\n\nfunction requestFileJob(filePath, finish) {\n  _fs2.default.readFile(filePath, (err, buf) => {\n    if (err) {\n      if (err.errno === 34) {\n        finish(-6); // net::ERR_FILE_NOT_FOUND\n        return;\n      } else {\n        finish(-2); // net::FAILED\n        return;\n      }\n    }\n\n    finish({\n      data: buf,\n      mimeType: _mimeTypes2.default.lookup(filePath) || 'text/plain'\n    });\n  });\n}\n\nconst bypassCheckers = [];\n\n/**\n * Adds a function that will be called on electron-compile's protocol hook\n * used to intercept file requests.  Use this to bypass electron-compile\n * entirely for certain URI's.\n * \n * @param {Function} bypassChecker Function that will be called with the file path to determine whether to bypass or not\n */\nfunction addBypassChecker(bypassChecker) {\n  bypassCheckers.push(bypassChecker);\n}\n\n/**\n * Initializes the protocol hook on file: that allows us to intercept files\n * loaded by Chromium and rewrite them. This method along with\n * {@link registerRequireExtension} are the top-level methods that electron-compile\n * actually uses to intercept code that Electron loads.\n *\n * @param  {CompilerHost} compilerHost  The compiler host to use for compilation.\n */\nfunction initializeProtocolHook(compilerHost) {\n  protocol = protocol || __webpack_require__(/*! electron */ \"electron\").protocol;\n\n  global[magicGlobalForRootCacheDir] = compilerHost.rootCacheDir;\n  global[magicGlobalForAppRootDir] = compilerHost.appRoot;\n\n  const electronCompileSetupCode = `if (window.require) require('electron-compile/lib/initialize-renderer').initializeRendererProcess(${compilerHost.readOnlyMode});`;\n\n  protocol.interceptBufferProtocol('file', (() => {\n    var _ref = _asyncToGenerator(function* (request, finish) {\n      let uri = _url2.default.parse(request.url);\n\n      d(`Intercepting url ${request.url}`);\n      if (request.url.indexOf(magicWords) > -1) {\n        finish({\n          mimeType: 'application/javascript',\n          data: new Buffer(electronCompileSetupCode, 'utf8')\n        });\n\n        return;\n      }\n\n      // This is a protocol-relative URL that has gone pear-shaped in Electron,\n      // let's rewrite it\n      if (uri.host && uri.host.length > 1) {\n        //let newUri = request.url.replace(/^file:/, \"https:\");\n        // TODO: Jump off this bridge later\n        d(`TODO: Found bogus protocol-relative URL, can't fix it up!!`);\n        finish(-2);\n        return;\n      }\n\n      let filePath = decodeURIComponent(uri.pathname);\n\n      // NB: pathname has a leading '/' on Win32 for some reason\n      if (process.platform === 'win32') {\n        filePath = filePath.slice(1);\n      }\n\n      // NB: Special-case files coming from atom.asar or node_modules\n      if (filePath.match(/[\\/\\\\](atom|electron).asar/) || filePath.match(/[\\/\\\\](node_modules|bower_components)/)) {\n        // NBs on NBs: If we're loading an HTML file from node_modules, we still have\n        // to do the HTML document rigging\n        if (filePath.match(/\\.html?$/i)) {\n          let riggedContents = null;\n          _fs2.default.readFile(filePath, 'utf8', function (err, contents) {\n            if (err) {\n              if (err.errno === 34) {\n                finish(-6); // net::ERR_FILE_NOT_FOUND\n                return;\n              } else {\n                finish(-2); // net::FAILED\n                return;\n              }\n            }\n\n            riggedContents = rigHtmlDocumentToInitializeElectronCompile(contents);\n            finish({ data: new Buffer(riggedContents), mimeType: 'text/html' });\n            return;\n          });\n\n          return;\n        }\n\n        requestFileJob(filePath, finish);\n        return;\n      }\n\n      // NB: Chromium will somehow decide that external source map references\n      // aren't relative to the file that was loaded for node.js modules, but\n      // relative to the HTML file. Since we can't really figure out what the\n      // real path is, we just need to squelch it.\n      if (filePath.match(/\\.map$/i) && !(yield doesMapFileExist(filePath))) {\n        finish({ data: new Buffer(\"\", 'utf8'), mimeType: 'text/plain' });\n        return;\n      }\n\n      for (const bypassChecker of bypassCheckers) {\n        if (bypassChecker(filePath)) {\n          d('bypassing compilers for:', filePath);\n          requestFileJob(filePath, finish);\n          return;\n        }\n      }\n\n      try {\n        let result = yield compilerHost.compile(filePath);\n\n        if (result.mimeType === 'text/html') {\n          result.code = rigHtmlDocumentToInitializeElectronCompile(result.code);\n        }\n\n        if (result.binaryData || result.code instanceof Buffer) {\n          finish({ data: result.binaryData || result.code, mimeType: result.mimeType });\n          return;\n        } else {\n          finish({ data: new Buffer(result.code), mimeType: result.mimeType });\n          return;\n        }\n      } catch (e) {\n        let err = `Failed to compile ${filePath}: ${e.message}\\n${e.stack}`;\n        d(err);\n\n        if (e.errno === 34 /*ENOENT*/) {\n            finish(-6); // net::ERR_FILE_NOT_FOUND\n            return;\n          }\n\n        finish({ mimeType: 'text/plain', data: new Buffer(err) });\n        return;\n      }\n    });\n\n    return function (_x, _x2) {\n      return _ref.apply(this, arguments);\n    };\n  })());\n}\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9wcm90b2NvbC1ob29rLmpzIl0sIm5hbWVzIjpbInJpZ0h0bWxEb2N1bWVudFRvSW5pdGlhbGl6ZUVsZWN0cm9uQ29tcGlsZSIsImFkZEJ5cGFzc0NoZWNrZXIiLCJpbml0aWFsaXplUHJvdG9jb2xIb29rIiwibWFnaWNXb3JkcyIsIm1hZ2ljR2xvYmFsRm9yUm9vdENhY2hlRGlyIiwibWFnaWNHbG9iYWxGb3JBcHBSb290RGlyIiwiZCIsInJlcXVpcmUiLCJwcm90b2NvbCIsIm1hcFN0YXRDYWNoZSIsIkxSVSIsImxlbmd0aCIsImRvZXNNYXBGaWxlRXhpc3QiLCJmaWxlUGF0aCIsInJldCIsImdldCIsInVuZGVmaW5lZCIsIlByb21pc2UiLCJyZXNvbHZlIiwicmVzIiwiZnMiLCJsc3RhdCIsImVyciIsInMiLCJmYWlsZWQiLCJzZXQiLCJkb2MiLCJsaW5lcyIsInNwbGl0IiwicmVwbGFjZW1lbnQiLCJyZXBsYWNlZEhlYWQiLCJpIiwibWF0Y2giLCJyZXBsYWNlIiwiam9pbiIsInJlcXVlc3RGaWxlSm9iIiwiZmluaXNoIiwicmVhZEZpbGUiLCJidWYiLCJlcnJubyIsImRhdGEiLCJtaW1lVHlwZSIsIm1pbWUiLCJsb29rdXAiLCJieXBhc3NDaGVja2VycyIsImJ5cGFzc0NoZWNrZXIiLCJwdXNoIiwiY29tcGlsZXJIb3N0IiwiZ2xvYmFsIiwicm9vdENhY2hlRGlyIiwiYXBwUm9vdCIsImVsZWN0cm9uQ29tcGlsZVNldHVwQ29kZSIsInJlYWRPbmx5TW9kZSIsImludGVyY2VwdEJ1ZmZlclByb3RvY29sIiwicmVxdWVzdCIsInVyaSIsInVybCIsInBhcnNlIiwiaW5kZXhPZiIsIkJ1ZmZlciIsImhvc3QiLCJkZWNvZGVVUklDb21wb25lbnQiLCJwYXRobmFtZSIsInByb2Nlc3MiLCJwbGF0Zm9ybSIsInNsaWNlIiwicmlnZ2VkQ29udGVudHMiLCJjb250ZW50cyIsInJlc3VsdCIsImNvbXBpbGUiLCJjb2RlIiwiYmluYXJ5RGF0YSIsImUi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QTtBQUFBO0FBQUE7QUF1R0QiLCJmaWxlIjoicHJvdG9jb2wtaG9vay5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB1cmwgZnJvbSAndXJsJztcbmltcG9ydCBmcyBmcm9tICdmcyc7XG5pbXBvcnQgbWltZSBmcm9tICdAcGF1bGNiZXR0cy9taW1lLXR5cGVzJztcbmltcG9ydCBMUlUgZnJvbSAnbHJ1LWNhY2hlJztcblxuY29uc3QgbWFnaWNXb3JkcyA9IFwiX19tYWdpY19fZmlsZV9fdG9fX2hlbHBfX2VsZWN0cm9uX19jb21waWxlLmpzXCI7XG5cbi8vIE5COiBUaGVzZSBhcmUgZHVwZWQgaW4gaW5pdGlhbGl6ZS1yZW5kZXJlciBzbyB3ZSBjYW4gc2F2ZSBzdGFydHVwIHRpbWUsIG1ha2Vcbi8vIHN1cmUgdG8gcnVuIGJvdGghXG5jb25zdCBtYWdpY0dsb2JhbEZvclJvb3RDYWNoZURpciA9ICdfX2VsZWN0cm9uX2NvbXBpbGVfcm9vdF9jYWNoZV9kaXInO1xuY29uc3QgbWFnaWNHbG9iYWxGb3JBcHBSb290RGlyID0gJ19fZWxlY3Ryb25fY29tcGlsZV9hcHBfcm9vdF9kaXInO1xuXG5jb25zdCBkID0gcmVxdWlyZSgnZGVidWcnKSgnZWxlY3Ryb24tY29tcGlsZTpwcm90b2NvbC1ob29rJyk7XG5cbmxldCBwcm90b2NvbCA9IG51bGw7XG5cbmNvbnN0IG1hcFN0YXRDYWNoZSA9IG5ldyBMUlUoe2xlbmd0aDogNTEyfSk7XG5mdW5jdGlvbiBkb2VzTWFwRmlsZUV4aXN0KGZpbGVQYXRoKSB7XG4gIGxldCByZXQgPSBtYXBTdGF0Q2FjaGUuZ2V0KGZpbGVQYXRoKTtcbiAgaWYgKHJldCAhPT0gdW5kZWZpbmVkKSByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHJldCk7XG5cbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXMpID0+IHtcbiAgICBmcy5sc3RhdChmaWxlUGF0aCwgKGVyciwgcykgPT4ge1xuICAgICAgbGV0IGZhaWxlZCA9IChlcnIgfHwgIXMpO1xuXG4gICAgICBtYXBTdGF0Q2FjaGUuc2V0KGZpbGVQYXRoLCAhZmFpbGVkKTtcbiAgICAgIHJlcyghZmFpbGVkKTtcbiAgICB9KTtcbiAgfSk7XG59XG5cbi8qKlxuICogQWRkcyBvdXIgc2NyaXB0IGhlYWRlciB0byB0aGUgdG9wIG9mIGFsbCBIVE1MIGZpbGVzXG4gKlxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJpZ0h0bWxEb2N1bWVudFRvSW5pdGlhbGl6ZUVsZWN0cm9uQ29tcGlsZShkb2MpIHtcbiAgbGV0IGxpbmVzID0gZG9jLnNwbGl0KFwiXFxuXCIpO1xuICBsZXQgcmVwbGFjZW1lbnQgPSBgPGhlYWQ+PHNjcmlwdCBzcmM9XCIke21hZ2ljV29yZHN9XCI+PC9zY3JpcHQ+YDtcbiAgbGV0IHJlcGxhY2VkSGVhZCA9IGZhbHNlO1xuXG4gIGZvciAobGV0IGk9MDsgaSA8IGxpbmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKCFsaW5lc1tpXS5tYXRjaCgvPGhlYWQ+L2kpKSBjb250aW51ZTtcblxuICAgIGxpbmVzW2ldID0gKGxpbmVzW2ldKS5yZXBsYWNlKC88aGVhZD4vaSwgcmVwbGFjZW1lbnQpO1xuICAgIHJlcGxhY2VkSGVhZCA9IHRydWU7XG4gICAgYnJlYWs7XG4gIH1cblxuICBpZiAoIXJlcGxhY2VkSGVhZCkge1xuICAgIHJlcGxhY2VtZW50ID0gYDxodG1sJDE+PGhlYWQ+PHNjcmlwdCBzcmM9XCIke21hZ2ljV29yZHN9XCI+PC9zY3JpcHQ+PC9oZWFkPmA7XG4gICAgZm9yIChsZXQgaT0wOyBpIDwgbGluZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmICghbGluZXNbaV0ubWF0Y2goLzxodG1sL2kpKSBjb250aW51ZTtcblxuICAgICAgbGluZXNbaV0gPSAobGluZXNbaV0pLnJlcGxhY2UoLzxodG1sKFtePl0rKT4vaSwgcmVwbGFjZW1lbnQpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGxpbmVzLmpvaW4oXCJcXG5cIik7XG59XG5cbmZ1bmN0aW9uIHJlcXVlc3RGaWxlSm9iKGZpbGVQYXRoLCBmaW5pc2gpIHtcbiAgZnMucmVhZEZpbGUoZmlsZVBhdGgsIChlcnIsIGJ1ZikgPT4ge1xuICAgIGlmIChlcnIpIHtcbiAgICAgIGlmIChlcnIuZXJybm8gPT09IDM0KSB7XG4gICAgICAgIGZpbmlzaCgtNik7IC8vIG5ldDo6RVJSX0ZJTEVfTk9UX0ZPVU5EXG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZpbmlzaCgtMik7IC8vIG5ldDo6RkFJTEVEXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmaW5pc2goe1xuICAgICAgZGF0YTogYnVmLFxuICAgICAgbWltZVR5cGU6IG1pbWUubG9va3VwKGZpbGVQYXRoKSB8fCAndGV4dC9wbGFpbidcbiAgICB9KTtcbiAgfSk7XG59XG5cbmNvbnN0IGJ5cGFzc0NoZWNrZXJzID0gW107XG5cbi8qKlxuICogQWRkcyBhIGZ1bmN0aW9uIHRoYXQgd2lsbCBiZSBjYWxsZWQgb24gZWxlY3Ryb24tY29tcGlsZSdzIHByb3RvY29sIGhvb2tcbiAqIHVzZWQgdG8gaW50ZXJjZXB0IGZpbGUgcmVxdWVzdHMuICBVc2UgdGhpcyB0byBieXBhc3MgZWxlY3Ryb24tY29tcGlsZVxuICogZW50aXJlbHkgZm9yIGNlcnRhaW4gVVJJJ3MuXG4gKiBcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGJ5cGFzc0NoZWNrZXIgRnVuY3Rpb24gdGhhdCB3aWxsIGJlIGNhbGxlZCB3aXRoIHRoZSBmaWxlIHBhdGggdG8gZGV0ZXJtaW5lIHdoZXRoZXIgdG8gYnlwYXNzIG9yIG5vdFxuICovXG5leHBvcnQgZnVuY3Rpb24gYWRkQnlwYXNzQ2hlY2tlcihieXBhc3NDaGVja2VyKSB7XG4gIGJ5cGFzc0NoZWNrZXJzLnB1c2goYnlwYXNzQ2hlY2tlcik7XG59XG5cbi8qKlxuICogSW5pdGlhbGl6ZXMgdGhlIHByb3RvY29sIGhvb2sgb24gZmlsZTogdGhhdCBhbGxvd3MgdXMgdG8gaW50ZXJjZXB0IGZpbGVzXG4gKiBsb2FkZWQgYnkgQ2hyb21pdW0gYW5kIHJld3JpdGUgdGhlbS4gVGhpcyBtZXRob2QgYWxvbmcgd2l0aFxuICoge0BsaW5rIHJlZ2lzdGVyUmVxdWlyZUV4dGVuc2lvbn0gYXJlIHRoZSB0b3AtbGV2ZWwgbWV0aG9kcyB0aGF0IGVsZWN0cm9uLWNvbXBpbGVcbiAqIGFjdHVhbGx5IHVzZXMgdG8gaW50ZXJjZXB0IGNvZGUgdGhhdCBFbGVjdHJvbiBsb2Fkcy5cbiAqXG4gKiBAcGFyYW0gIHtDb21waWxlckhvc3R9IGNvbXBpbGVySG9zdCAgVGhlIGNvbXBpbGVyIGhvc3QgdG8gdXNlIGZvciBjb21waWxhdGlvbi5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGluaXRpYWxpemVQcm90b2NvbEhvb2soY29tcGlsZXJIb3N0KSB7XG4gIHByb3RvY29sID0gcHJvdG9jb2wgfHwgcmVxdWlyZSgnZWxlY3Ryb24nKS5wcm90b2NvbDtcblxuICBnbG9iYWxbbWFnaWNHbG9iYWxGb3JSb290Q2FjaGVEaXJdID0gY29tcGlsZXJIb3N0LnJvb3RDYWNoZURpcjtcbiAgZ2xvYmFsW21hZ2ljR2xvYmFsRm9yQXBwUm9vdERpcl0gPSBjb21waWxlckhvc3QuYXBwUm9vdDtcblxuICBjb25zdCBlbGVjdHJvbkNvbXBpbGVTZXR1cENvZGUgPSBgaWYgKHdpbmRvdy5yZXF1aXJlKSByZXF1aXJlKCdlbGVjdHJvbi1jb21waWxlL2xpYi9pbml0aWFsaXplLXJlbmRlcmVyJykuaW5pdGlhbGl6ZVJlbmRlcmVyUHJvY2Vzcygke2NvbXBpbGVySG9zdC5yZWFkT25seU1vZGV9KTtgO1xuXG4gIHByb3RvY29sLmludGVyY2VwdEJ1ZmZlclByb3RvY29sKCdmaWxlJywgYXN5bmMgZnVuY3Rpb24ocmVxdWVzdCwgZmluaXNoKSB7XG4gICAgbGV0IHVyaSA9IHVybC5wYXJzZShyZXF1ZXN0LnVybCk7XG5cbiAgICBkKGBJbnRlcmNlcHRpbmcgdXJsICR7cmVxdWVzdC51cmx9YCk7XG4gICAgaWYgKHJlcXVlc3QudXJsLmluZGV4T2YobWFnaWNXb3JkcykgPiAtMSkge1xuICAgICAgZmluaXNoKHtcbiAgICAgICAgbWltZVR5cGU6ICdhcHBsaWNhdGlvbi9qYXZhc2NyaXB0JyxcbiAgICAgICAgZGF0YTogbmV3IEJ1ZmZlcihlbGVjdHJvbkNvbXBpbGVTZXR1cENvZGUsICd1dGY4JylcbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gVGhpcyBpcyBhIHByb3RvY29sLXJlbGF0aXZlIFVSTCB0aGF0IGhhcyBnb25lIHBlYXItc2hhcGVkIGluIEVsZWN0cm9uLFxuICAgIC8vIGxldCdzIHJld3JpdGUgaXRcbiAgICBpZiAodXJpLmhvc3QgJiYgdXJpLmhvc3QubGVuZ3RoID4gMSkge1xuICAgICAgLy9sZXQgbmV3VXJpID0gcmVxdWVzdC51cmwucmVwbGFjZSgvXmZpbGU6LywgXCJodHRwczpcIik7XG4gICAgICAvLyBUT0RPOiBKdW1wIG9mZiB0aGlzIGJyaWRnZSBsYXRlclxuICAgICAgZChgVE9ETzogRm91bmQgYm9ndXMgcHJvdG9jb2wtcmVsYXRpdmUgVVJMLCBjYW4ndCBmaXggaXQgdXAhIWApO1xuICAgICAgZmluaXNoKC0yKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBsZXQgZmlsZVBhdGggPSBkZWNvZGVVUklDb21wb25lbnQodXJpLnBhdGhuYW1lKTtcblxuICAgIC8vIE5COiBwYXRobmFtZSBoYXMgYSBsZWFkaW5nICcvJyBvbiBXaW4zMiBmb3Igc29tZSByZWFzb25cbiAgICBpZiAocHJvY2Vzcy5wbGF0Zm9ybSA9PT0gJ3dpbjMyJykge1xuICAgICAgZmlsZVBhdGggPSBmaWxlUGF0aC5zbGljZSgxKTtcbiAgICB9XG5cbiAgICAvLyBOQjogU3BlY2lhbC1jYXNlIGZpbGVzIGNvbWluZyBmcm9tIGF0b20uYXNhciBvciBub2RlX21vZHVsZXNcbiAgICBpZiAoZmlsZVBhdGgubWF0Y2goL1tcXC9cXFxcXShhdG9tfGVsZWN0cm9uKS5hc2FyLykgfHwgZmlsZVBhdGgubWF0Y2goL1tcXC9cXFxcXShub2RlX21vZHVsZXN8Ym93ZXJfY29tcG9uZW50cykvKSkge1xuICAgICAgLy8gTkJzIG9uIE5CczogSWYgd2UncmUgbG9hZGluZyBhbiBIVE1MIGZpbGUgZnJvbSBub2RlX21vZHVsZXMsIHdlIHN0aWxsIGhhdmVcbiAgICAgIC8vIHRvIGRvIHRoZSBIVE1MIGRvY3VtZW50IHJpZ2dpbmdcbiAgICAgIGlmIChmaWxlUGF0aC5tYXRjaCgvXFwuaHRtbD8kL2kpKSB7XG4gICAgICAgIGxldCByaWdnZWRDb250ZW50cyA9IG51bGw7XG4gICAgICAgIGZzLnJlYWRGaWxlKGZpbGVQYXRoLCAndXRmOCcsIChlcnIsIGNvbnRlbnRzKSA9PiB7XG4gICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgaWYgKGVyci5lcnJubyA9PT0gMzQpIHtcbiAgICAgICAgICAgICAgZmluaXNoKC02KTsgLy8gbmV0OjpFUlJfRklMRV9OT1RfRk9VTkRcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgZmluaXNoKC0yKTsgLy8gbmV0OjpGQUlMRURcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHJpZ2dlZENvbnRlbnRzID0gcmlnSHRtbERvY3VtZW50VG9Jbml0aWFsaXplRWxlY3Ryb25Db21waWxlKGNvbnRlbnRzKTtcbiAgICAgICAgICBmaW5pc2goeyBkYXRhOiBuZXcgQnVmZmVyKHJpZ2dlZENvbnRlbnRzKSwgbWltZVR5cGU6ICd0ZXh0L2h0bWwnIH0pO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICByZXF1ZXN0RmlsZUpvYihmaWxlUGF0aCwgZmluaXNoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBOQjogQ2hyb21pdW0gd2lsbCBzb21laG93IGRlY2lkZSB0aGF0IGV4dGVybmFsIHNvdXJjZSBtYXAgcmVmZXJlbmNlc1xuICAgIC8vIGFyZW4ndCByZWxhdGl2ZSB0byB0aGUgZmlsZSB0aGF0IHdhcyBsb2FkZWQgZm9yIG5vZGUuanMgbW9kdWxlcywgYnV0XG4gICAgLy8gcmVsYXRpdmUgdG8gdGhlIEhUTUwgZmlsZS4gU2luY2Ugd2UgY2FuJ3QgcmVhbGx5IGZpZ3VyZSBvdXQgd2hhdCB0aGVcbiAgICAvLyByZWFsIHBhdGggaXMsIHdlIGp1c3QgbmVlZCB0byBzcXVlbGNoIGl0LlxuICAgIGlmIChmaWxlUGF0aC5tYXRjaCgvXFwubWFwJC9pKSAmJiAhKGF3YWl0IGRvZXNNYXBGaWxlRXhpc3QoZmlsZVBhdGgpKSkge1xuICAgICAgZmluaXNoKHsgZGF0YTogbmV3IEJ1ZmZlcihcIlwiLCAndXRmOCcpLCBtaW1lVHlwZTogJ3RleHQvcGxhaW4nIH0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGZvciAoY29uc3QgYnlwYXNzQ2hlY2tlciBvZiBieXBhc3NDaGVja2Vycykge1xuICAgICAgaWYgKGJ5cGFzc0NoZWNrZXIoZmlsZVBhdGgpKSB7XG4gICAgICAgIGQoJ2J5cGFzc2luZyBjb21waWxlcnMgZm9yOicsIGZpbGVQYXRoKTtcbiAgICAgICAgcmVxdWVzdEZpbGVKb2IoZmlsZVBhdGgsIGZpbmlzaCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgbGV0IHJlc3VsdCA9IGF3YWl0IGNvbXBpbGVySG9zdC5jb21waWxlKGZpbGVQYXRoKTtcblxuICAgICAgaWYgKHJlc3VsdC5taW1lVHlwZSA9PT0gJ3RleHQvaHRtbCcpIHtcbiAgICAgICAgcmVzdWx0LmNvZGUgPSByaWdIdG1sRG9jdW1lbnRUb0luaXRpYWxpemVFbGVjdHJvbkNvbXBpbGUocmVzdWx0LmNvZGUpO1xuICAgICAgfVxuXG4gICAgICBpZiAocmVzdWx0LmJpbmFyeURhdGEgfHwgcmVzdWx0LmNvZGUgaW5zdGFuY2VvZiBCdWZmZXIpIHtcbiAgICAgICAgZmluaXNoKHsgZGF0YTogcmVzdWx0LmJpbmFyeURhdGEgfHwgcmVzdWx0LmNvZGUsIG1pbWVUeXBlOiByZXN1bHQubWltZVR5cGUgfSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZpbmlzaCh7IGRhdGE6IG5ldyBCdWZmZXIocmVzdWx0LmNvZGUpLCBtaW1lVHlwZTogcmVzdWx0Lm1pbWVUeXBlIH0pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgbGV0IGVyciA9IGBGYWlsZWQgdG8gY29tcGlsZSAke2ZpbGVQYXRofTogJHtlLm1lc3NhZ2V9XFxuJHtlLnN0YWNrfWA7XG4gICAgICBkKGVycik7XG5cbiAgICAgIGlmIChlLmVycm5vID09PSAzNCAvKkVOT0VOVCovKSB7XG4gICAgICAgIGZpbmlzaCgtNik7IC8vIG5ldDo6RVJSX0ZJTEVfTk9UX0ZPVU5EXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgZmluaXNoKHsgbWltZVR5cGU6ICd0ZXh0L3BsYWluJywgZGF0YTogbmV3IEJ1ZmZlcihlcnIpIH0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfSk7XG59XG4iXX0=\n\n//# sourceURL=webpack:///./node_modules/electron-compile/lib/protocol-hook.js?")},"./node_modules/electron-compile/lib/read-only-compiler.js":
/*!*****************************************************************!*\
  !*** ./node_modules/electron-compile/lib/read-only-compiler.js ***!
  \*****************************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", {\n  value: true\n});\n\nfunction _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }\n\n/**\n * ReadOnlyCompiler is a compiler which allows the host to inject all of the compiler\n * metadata information so that {@link CompileCache} et al are able to recreate the\n * hash without having two separate code paths.\n */\nclass ReadOnlyCompiler {\n  /**\n   * Creates a ReadOnlyCompiler instance\n   *\n   * @private\n   */\n  constructor(name, compilerVersion, compilerOptions, inputMimeTypes) {\n    Object.assign(this, { name, compilerVersion, compilerOptions, inputMimeTypes });\n  }\n\n  shouldCompileFile() {\n    return _asyncToGenerator(function* () {\n      return true;\n    })();\n  }\n  determineDependentFiles() {\n    return _asyncToGenerator(function* () {\n      return [];\n    })();\n  }\n\n  compile() {\n    return _asyncToGenerator(function* () {\n      throw new Error("Read-only compilers can\'t compile");\n    })();\n  }\n\n  shouldCompileFileSync() {\n    return true;\n  }\n  determineDependentFilesSync() {\n    return [];\n  }\n\n  compileSync() {\n    throw new Error("Read-only compilers can\'t compile");\n  }\n\n  getCompilerVersion() {\n    return this.compilerVersion;\n  }\n}\nexports.default = ReadOnlyCompiler;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9yZWFkLW9ubHktY29tcGlsZXIuanMiXSwibmFtZXMiOlsiUmVhZE9ubHlDb21waWxlciIsImNvbnN0cnVjdG9yIiwibmFtZSIsImNvbXBpbGVyVmVyc2lvbiIsImNvbXBpbGVyT3B0aW9ucyIsImlucHV0TWltZVR5cGVzIiwiT2JqZWN0IiwiYXNzaWduIiwic2hvdWxkQ29tcGlsZUZpbGUiLCJkZXRlcm1pbmVEZXBlbmRlbnRGaWxlcyIsImNvbXBpbGUiLCJFcnJvciIsInNob3VsZENvbXBpbGVGaWxlU3luYyIsImRldGVybWluZURlcGVuZGVudEZpbGVzU3luYyIsImNvbXBpbGVTeW5jIiwiZ2V0Q29tcGlsZXJWZXJzaW9uIl0sIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBOzs7OztBQUtlLE1BQU1BLGdCQUFOLENBQXVCO0FBQ3BDOzs7OztBQUtBQyxjQUFZQyxJQUFaLEVBQWtCQyxlQUFsQixFQUFtQ0MsZUFBbkMsRUFBb0RDLGNBQXBELEVBQW9FO0FBQ2xFQyxXQUFPQyxNQUFQLENBQWMsSUFBZCxFQUFvQixFQUFFTCxJQUFGLEVBQVFDLGVBQVIsRUFBeUJDLGVBQXpCLEVBQTBDQyxjQUExQyxFQUFwQjtBQUNEOztBQUVLRyxtQkFBTixHQUEwQjtBQUFBO0FBQUUsYUFBTyxJQUFQO0FBQUY7QUFBZ0I7QUFDcENDLHlCQUFOLEdBQWdDO0FBQUE7QUFBRSxhQUFPLEVBQVA7QUFBRjtBQUFjOztBQUV4Q0MsU0FBTixHQUFnQjtBQUFBO0FBQ2QsWUFBTSxJQUFJQyxLQUFKLENBQVUsbUNBQVYsQ0FBTjtBQURjO0FBRWY7O0FBRURDLDBCQUF3QjtBQUFFLFdBQU8sSUFBUDtBQUFjO0FBQ3hDQyxnQ0FBOEI7QUFBRSxXQUFPLEVBQVA7QUFBWTs7QUFFNUNDLGdCQUFjO0FBQ1osVUFBTSxJQUFJSCxLQUFKLENBQVUsbUNBQVYsQ0FBTjtBQUNEOztBQUVESSx1QkFBcUI7QUFDbkIsV0FBTyxLQUFLWixlQUFaO0FBQ0Q7QUExQm1DO2tCQUFqQkgsZ0IiLCJmaWxlIjoicmVhZC1vbmx5LWNvbXBpbGVyLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBSZWFkT25seUNvbXBpbGVyIGlzIGEgY29tcGlsZXIgd2hpY2ggYWxsb3dzIHRoZSBob3N0IHRvIGluamVjdCBhbGwgb2YgdGhlIGNvbXBpbGVyXG4gKiBtZXRhZGF0YSBpbmZvcm1hdGlvbiBzbyB0aGF0IHtAbGluayBDb21waWxlQ2FjaGV9IGV0IGFsIGFyZSBhYmxlIHRvIHJlY3JlYXRlIHRoZVxuICogaGFzaCB3aXRob3V0IGhhdmluZyB0d28gc2VwYXJhdGUgY29kZSBwYXRocy5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUmVhZE9ubHlDb21waWxlciB7XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgUmVhZE9ubHlDb21waWxlciBpbnN0YW5jZVxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgY29uc3RydWN0b3IobmFtZSwgY29tcGlsZXJWZXJzaW9uLCBjb21waWxlck9wdGlvbnMsIGlucHV0TWltZVR5cGVzKSB7XG4gICAgT2JqZWN0LmFzc2lnbih0aGlzLCB7IG5hbWUsIGNvbXBpbGVyVmVyc2lvbiwgY29tcGlsZXJPcHRpb25zLCBpbnB1dE1pbWVUeXBlcyB9KTtcbiAgfVxuXG4gIGFzeW5jIHNob3VsZENvbXBpbGVGaWxlKCkgeyByZXR1cm4gdHJ1ZTsgfVxuICBhc3luYyBkZXRlcm1pbmVEZXBlbmRlbnRGaWxlcygpIHsgcmV0dXJuIFtdOyB9XG5cbiAgYXN5bmMgY29tcGlsZSgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJSZWFkLW9ubHkgY29tcGlsZXJzIGNhbid0IGNvbXBpbGVcIik7XG4gIH1cblxuICBzaG91bGRDb21waWxlRmlsZVN5bmMoKSB7IHJldHVybiB0cnVlOyB9XG4gIGRldGVybWluZURlcGVuZGVudEZpbGVzU3luYygpIHsgcmV0dXJuIFtdOyB9XG5cbiAgY29tcGlsZVN5bmMoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiUmVhZC1vbmx5IGNvbXBpbGVycyBjYW4ndCBjb21waWxlXCIpO1xuICB9XG5cbiAgZ2V0Q29tcGlsZXJWZXJzaW9uKCkge1xuICAgIHJldHVybiB0aGlzLmNvbXBpbGVyVmVyc2lvbjtcbiAgfVxufVxuIl19\n\n//# sourceURL=webpack:///./node_modules/electron-compile/lib/read-only-compiler.js?')},"./node_modules/electron-compile/lib/require-hook.js":
/*!***********************************************************!*\
  !*** ./node_modules/electron-compile/lib/require-hook.js ***!
  \***********************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", {\n  value: true\n});\nexports.default = registerRequireExtension;\n\nvar _mimeTypes = __webpack_require__(/*! @paulcbetts/mime-types */ "./node_modules/@paulcbetts/mime-types/index.js");\n\nvar _mimeTypes2 = _interopRequireDefault(_mimeTypes);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nlet HMR = false;\n\nconst d = __webpack_require__(/*! debug */ "./node_modules/debug/src/index.js")(\'electron-compile:require-hook\');\nlet electron = null;\n\nif (process.type === \'renderer\') {\n  window.__hot = [];\n  electron = __webpack_require__(/*! electron */ "electron");\n  HMR = electron.remote.getGlobal(\'__electron_compile_hmr_enabled__\');\n\n  if (HMR) {\n    electron.ipcRenderer.on(\'__electron-compile__HMR\', () => {\n      d("Got HMR signal!");\n\n      // Reset the module cache\n      let cache = __webpack_require__(/*! module */ "module")._cache;\n      let toEject = Object.keys(cache).filter(x => x && !x.match(/[\\\\\\/](node_modules|.*\\.asar)[\\\\\\/]/i));\n      toEject.forEach(x => {\n        d(`Removing node module entry for ${x}`);\n        delete cache[x];\n      });\n\n      window.__hot.forEach(fn => fn());\n    });\n  }\n}\n\n/**\n * Initializes the node.js hook that allows us to intercept files loaded by\n * node.js and rewrite them. This method along with {@link initializeProtocolHook}\n * are the top-level methods that electron-compile actually uses to intercept\n * code that Electron loads.\n *\n * @param  {CompilerHost} compilerHost  The compiler host to use for compilation.\n */\nfunction registerRequireExtension(compilerHost, isProduction) {\n  if (HMR) {\n    try {\n      __webpack_require__(/*! module */ "module").prototype.hot = {\n        accept: cb => window.__hot.push(cb)\n      };\n\n      (void 0)(\'react-hot-loader/patch\');\n    } catch (e) {\n      console.error(`Couldn\'t require react-hot-loader/patch, you need to add react-hot-loader@3 as a dependency! ${e.message}`);\n    }\n  }\n\n  let mimeTypeList = isProduction ? Object.keys(compilerHost.mimeTypesToRegister) : Object.keys(compilerHost.compilersByMimeType);\n\n  mimeTypeList.forEach(mimeType => {\n    let ext = _mimeTypes2.default.extension(mimeType);\n\n    (void 0)[`.${ext}`] = (module, filename) => {\n      var _compilerHost$compile = compilerHost.compileSync(filename);\n\n      let code = _compilerHost$compile.code;\n\n\n      if (code === null) {\n        console.error(`null code returned for "${filename}".  Please raise an issue on \'electron-compile\' with the contents of this file.`);\n      }\n\n      module._compile(code, filename);\n    };\n  });\n}\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9yZXF1aXJlLWhvb2suanMiXSwibmFtZXMiOlsicmVnaXN0ZXJSZXF1aXJlRXh0ZW5zaW9uIiwiSE1SIiwiZCIsInJlcXVpcmUiLCJlbGVjdHJvbiIsInByb2Nlc3MiLCJ0eXBlIiwid2luZG93IiwiX19ob3QiLCJyZW1vdGUiLCJnZXRHbG9iYWwiLCJpcGNSZW5kZXJlciIsIm9uIiwiY2FjaGUiLCJfY2FjaGUiLCJ0b0VqZWN0IiwiT2JqZWN0Iiwia2V5cyIsImZpbHRlciIsIngiLCJtYXRjaCIsImZvckVhY2giLCJmbiIsImNvbXBpbGVySG9zdCIsImlzUHJvZHVjdGlvbiIsInByb3RvdHlwZSIsImhvdCIsImFjY2VwdCIsImNiIiwicHVzaCIsIm1haW4iLCJlIiwiY29uc29sZSIsImVycm9yIiwibWVzc2FnZSIsIm1pbWVUeXBlTGlzdCIsIm1pbWVUeXBlc1RvUmVnaXN0ZXIiLCJjb21waWxlcnNCeU1pbWVUeXBlIiwibWltZVR5cGUiLCJleHQiLCJtaW1lVHlwZXMiLCJleHRlbnNpb24iLCJleHRlbnNpb25zIiwibW9kdWxlIiwiZmlsZW5hbWUiLCJjb21waWxlU3luYyIsImNvZGUiLCJfY29tcGlsZSJdLCJtYXBwaW5ncyI6Ijs7Ozs7a0JBcUN3QkEsd0I7O0FBckN4Qjs7Ozs7O0FBRUEsSUFBSUMsTUFBTSxLQUFWOztBQUVBLE1BQU1DLElBQUlDLFFBQVEsT0FBUixFQUFpQiwrQkFBakIsQ0FBVjtBQUNBLElBQUlDLFdBQVcsSUFBZjs7QUFFQSxJQUFJQyxRQUFRQyxJQUFSLEtBQWlCLFVBQXJCLEVBQWlDO0FBQy9CQyxTQUFPQyxLQUFQLEdBQWUsRUFBZjtBQUNBSixhQUFXRCxRQUFRLFVBQVIsQ0FBWDtBQUNBRixRQUFNRyxTQUFTSyxNQUFULENBQWdCQyxTQUFoQixDQUEwQixrQ0FBMUIsQ0FBTjs7QUFFQSxNQUFJVCxHQUFKLEVBQVM7QUFDUEcsYUFBU08sV0FBVCxDQUFxQkMsRUFBckIsQ0FBd0IseUJBQXhCLEVBQW1ELE1BQU07QUFDdkRWLFFBQUUsaUJBQUY7O0FBRUE7QUFDQSxVQUFJVyxRQUFRVixRQUFRLFFBQVIsRUFBa0JXLE1BQTlCO0FBQ0EsVUFBSUMsVUFBVUMsT0FBT0MsSUFBUCxDQUFZSixLQUFaLEVBQW1CSyxNQUFuQixDQUEwQkMsS0FBS0EsS0FBSyxDQUFDQSxFQUFFQyxLQUFGLENBQVEsc0NBQVIsQ0FBckMsQ0FBZDtBQUNBTCxjQUFRTSxPQUFSLENBQWdCRixLQUFLO0FBQ25CakIsVUFBRyxrQ0FBaUNpQixDQUFFLEVBQXRDO0FBQ0EsZUFBT04sTUFBTU0sQ0FBTixDQUFQO0FBQ0QsT0FIRDs7QUFLQVosYUFBT0MsS0FBUCxDQUFhYSxPQUFiLENBQXFCQyxNQUFNQSxJQUEzQjtBQUNELEtBWkQ7QUFhRDtBQUNGOztBQUVEOzs7Ozs7OztBQVFlLFNBQVN0Qix3QkFBVCxDQUFrQ3VCLFlBQWxDLEVBQWdEQyxZQUFoRCxFQUE4RDtBQUMzRSxNQUFJdkIsR0FBSixFQUFTO0FBQ1AsUUFBSTtBQUNGRSxjQUFRLFFBQVIsRUFBa0JzQixTQUFsQixDQUE0QkMsR0FBNUIsR0FBa0M7QUFDaENDLGdCQUFTQyxFQUFELElBQVFyQixPQUFPQyxLQUFQLENBQWFxQixJQUFiLENBQWtCRCxFQUFsQjtBQURnQixPQUFsQzs7QUFJQXpCLGNBQVEyQixJQUFSLENBQWEzQixPQUFiLENBQXFCLHdCQUFyQjtBQUNELEtBTkQsQ0FNRSxPQUFPNEIsQ0FBUCxFQUFVO0FBQ1ZDLGNBQVFDLEtBQVIsQ0FBZSxnR0FBK0ZGLEVBQUVHLE9BQVEsRUFBeEg7QUFDRDtBQUNGOztBQUVELE1BQUlDLGVBQWVYLGVBQ2pCUixPQUFPQyxJQUFQLENBQVlNLGFBQWFhLG1CQUF6QixDQURpQixHQUVqQnBCLE9BQU9DLElBQVAsQ0FBWU0sYUFBYWMsbUJBQXpCLENBRkY7O0FBSUFGLGVBQWFkLE9BQWIsQ0FBc0JpQixRQUFELElBQWM7QUFDakMsUUFBSUMsTUFBTUMsb0JBQVVDLFNBQVYsQ0FBb0JILFFBQXBCLENBQVY7O0FBRUFuQyxZQUFRdUMsVUFBUixDQUFvQixJQUFHSCxHQUFJLEVBQTNCLElBQWdDLENBQUNJLE1BQUQsRUFBU0MsUUFBVCxLQUFzQjtBQUFBLGtDQUN2Q3JCLGFBQWFzQixXQUFiLENBQXlCRCxRQUF6QixDQUR1Qzs7QUFBQSxVQUMvQ0UsSUFEK0MseUJBQy9DQSxJQUQrQzs7O0FBR3BELFVBQUlBLFNBQVMsSUFBYixFQUFtQjtBQUNqQmQsZ0JBQVFDLEtBQVIsQ0FBZSwyQkFBMEJXLFFBQVMsaUZBQWxEO0FBQ0Q7O0FBRURELGFBQU9JLFFBQVAsQ0FBZ0JELElBQWhCLEVBQXNCRixRQUF0QjtBQUNELEtBUkQ7QUFTRCxHQVpEO0FBYUQiLCJmaWxlIjoicmVxdWlyZS1ob29rLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IG1pbWVUeXBlcyBmcm9tICdAcGF1bGNiZXR0cy9taW1lLXR5cGVzJztcblxubGV0IEhNUiA9IGZhbHNlO1xuXG5jb25zdCBkID0gcmVxdWlyZSgnZGVidWcnKSgnZWxlY3Ryb24tY29tcGlsZTpyZXF1aXJlLWhvb2snKTtcbmxldCBlbGVjdHJvbiA9IG51bGw7XG5cbmlmIChwcm9jZXNzLnR5cGUgPT09ICdyZW5kZXJlcicpIHtcbiAgd2luZG93Ll9faG90ID0gW107XG4gIGVsZWN0cm9uID0gcmVxdWlyZSgnZWxlY3Ryb24nKTtcbiAgSE1SID0gZWxlY3Ryb24ucmVtb3RlLmdldEdsb2JhbCgnX19lbGVjdHJvbl9jb21waWxlX2htcl9lbmFibGVkX18nKTtcblxuICBpZiAoSE1SKSB7XG4gICAgZWxlY3Ryb24uaXBjUmVuZGVyZXIub24oJ19fZWxlY3Ryb24tY29tcGlsZV9fSE1SJywgKCkgPT4ge1xuICAgICAgZChcIkdvdCBITVIgc2lnbmFsIVwiKTtcblxuICAgICAgLy8gUmVzZXQgdGhlIG1vZHVsZSBjYWNoZVxuICAgICAgbGV0IGNhY2hlID0gcmVxdWlyZSgnbW9kdWxlJykuX2NhY2hlO1xuICAgICAgbGV0IHRvRWplY3QgPSBPYmplY3Qua2V5cyhjYWNoZSkuZmlsdGVyKHggPT4geCAmJiAheC5tYXRjaCgvW1xcXFxcXC9dKG5vZGVfbW9kdWxlc3wuKlxcLmFzYXIpW1xcXFxcXC9dL2kpKTtcbiAgICAgIHRvRWplY3QuZm9yRWFjaCh4ID0+IHtcbiAgICAgICAgZChgUmVtb3Zpbmcgbm9kZSBtb2R1bGUgZW50cnkgZm9yICR7eH1gKTtcbiAgICAgICAgZGVsZXRlIGNhY2hlW3hdO1xuICAgICAgfSk7XG5cbiAgICAgIHdpbmRvdy5fX2hvdC5mb3JFYWNoKGZuID0+IGZuKCkpO1xuICAgIH0pO1xuICB9XG59XG5cbi8qKlxuICogSW5pdGlhbGl6ZXMgdGhlIG5vZGUuanMgaG9vayB0aGF0IGFsbG93cyB1cyB0byBpbnRlcmNlcHQgZmlsZXMgbG9hZGVkIGJ5XG4gKiBub2RlLmpzIGFuZCByZXdyaXRlIHRoZW0uIFRoaXMgbWV0aG9kIGFsb25nIHdpdGgge0BsaW5rIGluaXRpYWxpemVQcm90b2NvbEhvb2t9XG4gKiBhcmUgdGhlIHRvcC1sZXZlbCBtZXRob2RzIHRoYXQgZWxlY3Ryb24tY29tcGlsZSBhY3R1YWxseSB1c2VzIHRvIGludGVyY2VwdFxuICogY29kZSB0aGF0IEVsZWN0cm9uIGxvYWRzLlxuICpcbiAqIEBwYXJhbSAge0NvbXBpbGVySG9zdH0gY29tcGlsZXJIb3N0ICBUaGUgY29tcGlsZXIgaG9zdCB0byB1c2UgZm9yIGNvbXBpbGF0aW9uLlxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiByZWdpc3RlclJlcXVpcmVFeHRlbnNpb24oY29tcGlsZXJIb3N0LCBpc1Byb2R1Y3Rpb24pIHtcbiAgaWYgKEhNUikge1xuICAgIHRyeSB7XG4gICAgICByZXF1aXJlKCdtb2R1bGUnKS5wcm90b3R5cGUuaG90ID0ge1xuICAgICAgICBhY2NlcHQ6IChjYikgPT4gd2luZG93Ll9faG90LnB1c2goY2IpXG4gICAgICB9O1xuXG4gICAgICByZXF1aXJlLm1haW4ucmVxdWlyZSgncmVhY3QtaG90LWxvYWRlci9wYXRjaCcpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoYENvdWxkbid0IHJlcXVpcmUgcmVhY3QtaG90LWxvYWRlci9wYXRjaCwgeW91IG5lZWQgdG8gYWRkIHJlYWN0LWhvdC1sb2FkZXJAMyBhcyBhIGRlcGVuZGVuY3khICR7ZS5tZXNzYWdlfWApO1xuICAgIH1cbiAgfVxuXG4gIGxldCBtaW1lVHlwZUxpc3QgPSBpc1Byb2R1Y3Rpb24gP1xuICAgIE9iamVjdC5rZXlzKGNvbXBpbGVySG9zdC5taW1lVHlwZXNUb1JlZ2lzdGVyKSA6XG4gICAgT2JqZWN0LmtleXMoY29tcGlsZXJIb3N0LmNvbXBpbGVyc0J5TWltZVR5cGUpO1xuXG4gIG1pbWVUeXBlTGlzdC5mb3JFYWNoKChtaW1lVHlwZSkgPT4ge1xuICAgIGxldCBleHQgPSBtaW1lVHlwZXMuZXh0ZW5zaW9uKG1pbWVUeXBlKTtcblxuICAgIHJlcXVpcmUuZXh0ZW5zaW9uc1tgLiR7ZXh0fWBdID0gKG1vZHVsZSwgZmlsZW5hbWUpID0+IHtcbiAgICAgIGxldCB7Y29kZX0gPSBjb21waWxlckhvc3QuY29tcGlsZVN5bmMoZmlsZW5hbWUpO1xuXG4gICAgICBpZiAoY29kZSA9PT0gbnVsbCkge1xuICAgICAgICBjb25zb2xlLmVycm9yKGBudWxsIGNvZGUgcmV0dXJuZWQgZm9yIFwiJHtmaWxlbmFtZX1cIi4gIFBsZWFzZSByYWlzZSBhbiBpc3N1ZSBvbiAnZWxlY3Ryb24tY29tcGlsZScgd2l0aCB0aGUgY29udGVudHMgb2YgdGhpcyBmaWxlLmApO1xuICAgICAgfVxuXG4gICAgICBtb2R1bGUuX2NvbXBpbGUoY29kZSwgZmlsZW5hbWUpO1xuICAgIH07XG4gIH0pO1xufVxuIl19\n\n//# sourceURL=webpack:///./node_modules/electron-compile/lib/require-hook.js?')},"./node_modules/electron-compile/lib/rig-mime-types.js":
/*!*************************************************************!*\
  !*** ./node_modules/electron-compile/lib/rig-mime-types.js ***!
  \*************************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){"use strict";eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.init = init;\n\nvar _mimeTypes = __webpack_require__(/*! @paulcbetts/mime-types */ \"./node_modules/@paulcbetts/mime-types/index.js\");\n\nvar _mimeTypes2 = _interopRequireDefault(_mimeTypes);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst typesToRig = {\n  'text/typescript': 'ts',\n  'text/tsx': 'tsx',\n  'text/jade': 'jade',\n  'text/cson': 'cson',\n  'text/stylus': 'styl',\n  'text/sass': 'sass',\n  'text/scss': 'scss',\n  'text/vue': 'vue',\n  'text/graphql': 'graphql'\n};\n\n/**\n * Adds MIME types for types not in the mime-types package\n *\n * @private\n */\nfunction init() {\n  Object.keys(typesToRig).forEach(type => {\n    let ext = typesToRig[type];\n\n    _mimeTypes2.default.types[ext] = type;\n    _mimeTypes2.default.extensions[type] = [ext];\n  });\n}\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9yaWctbWltZS10eXBlcy5qcyJdLCJuYW1lcyI6WyJpbml0IiwidHlwZXNUb1JpZyIsIk9iamVjdCIsImtleXMiLCJmb3JFYWNoIiwidHlwZSIsImV4dCIsIm1pbWVUeXBlcyIsInR5cGVzIiwiZXh0ZW5zaW9ucyJdLCJtYXBwaW5ncyI6Ijs7Ozs7UUFtQmdCQSxJLEdBQUFBLEk7O0FBbkJoQjs7Ozs7O0FBRUEsTUFBTUMsYUFBYTtBQUNqQixxQkFBbUIsSUFERjtBQUVqQixjQUFZLEtBRks7QUFHakIsZUFBYSxNQUhJO0FBSWpCLGVBQWEsTUFKSTtBQUtqQixpQkFBZSxNQUxFO0FBTWpCLGVBQWEsTUFOSTtBQU9qQixlQUFhLE1BUEk7QUFRakIsY0FBWSxLQVJLO0FBU2pCLGtCQUFnQjtBQVRDLENBQW5COztBQVlBOzs7OztBQUtPLFNBQVNELElBQVQsR0FBZ0I7QUFDckJFLFNBQU9DLElBQVAsQ0FBWUYsVUFBWixFQUF3QkcsT0FBeEIsQ0FBaUNDLElBQUQsSUFBVTtBQUN4QyxRQUFJQyxNQUFNTCxXQUFXSSxJQUFYLENBQVY7O0FBRUFFLHdCQUFVQyxLQUFWLENBQWdCRixHQUFoQixJQUF1QkQsSUFBdkI7QUFDQUUsd0JBQVVFLFVBQVYsQ0FBcUJKLElBQXJCLElBQTZCLENBQUNDLEdBQUQsQ0FBN0I7QUFDRCxHQUxEO0FBTUQiLCJmaWxlIjoicmlnLW1pbWUtdHlwZXMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgbWltZVR5cGVzIGZyb20gJ0BwYXVsY2JldHRzL21pbWUtdHlwZXMnO1xuXG5jb25zdCB0eXBlc1RvUmlnID0ge1xuICAndGV4dC90eXBlc2NyaXB0JzogJ3RzJyxcbiAgJ3RleHQvdHN4JzogJ3RzeCcsXG4gICd0ZXh0L2phZGUnOiAnamFkZScsXG4gICd0ZXh0L2Nzb24nOiAnY3NvbicsXG4gICd0ZXh0L3N0eWx1cyc6ICdzdHlsJyxcbiAgJ3RleHQvc2Fzcyc6ICdzYXNzJyxcbiAgJ3RleHQvc2Nzcyc6ICdzY3NzJyxcbiAgJ3RleHQvdnVlJzogJ3Z1ZScsXG4gICd0ZXh0L2dyYXBocWwnOiAnZ3JhcGhxbCcsXG59O1xuXG4vKipcbiAqIEFkZHMgTUlNRSB0eXBlcyBmb3IgdHlwZXMgbm90IGluIHRoZSBtaW1lLXR5cGVzIHBhY2thZ2VcbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gaW5pdCgpIHtcbiAgT2JqZWN0LmtleXModHlwZXNUb1JpZykuZm9yRWFjaCgodHlwZSkgPT4ge1xuICAgIGxldCBleHQgPSB0eXBlc1RvUmlnW3R5cGVdO1xuXG4gICAgbWltZVR5cGVzLnR5cGVzW2V4dF0gPSB0eXBlO1xuICAgIG1pbWVUeXBlcy5leHRlbnNpb25zW3R5cGVdID0gW2V4dF07XG4gIH0pO1xufVxuIl19\n\n//# sourceURL=webpack:///./node_modules/electron-compile/lib/rig-mime-types.js?")},"./node_modules/electron-compile/lib/sanitize-paths.js":
/*!*************************************************************!*\
  !*** ./node_modules/electron-compile/lib/sanitize-paths.js ***!
  \*************************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){"use strict";eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = sanitizeFilePath;\n\nvar _fs = __webpack_require__(/*! fs */ \"fs\");\n\nvar _fs2 = _interopRequireDefault(_fs);\n\nvar _lruCache = __webpack_require__(/*! lru-cache */ \"./node_modules/lru-cache/index.js\");\n\nvar _lruCache2 = _interopRequireDefault(_lruCache);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst d = __webpack_require__(/*! debug */ \"./node_modules/debug/src/index.js\")('electron-compile:sanitize-paths');\nconst realpathCache = (0, _lruCache2.default)({ max: 1024 });\n\nfunction cachedRealpath(p) {\n  let ret = realpathCache.get(p);\n  if (ret) return ret;\n\n  ret = _fs2.default.realpathSync(p);\n  d(`Cache miss for cachedRealpath: '${p}' => '${ret}'`);\n\n  realpathCache.set(p, ret);\n  return ret;\n}\n\n/**\n * Electron will sometimes hand us paths that don't match the platform if they\n * were derived from a URL (i.e. 'C:/Users/Paul/...'), whereas the cache will have\n * saved paths with backslashes.\n *\n * @private\n */\nfunction sanitizeFilePath(file) {\n  if (!file) return file;\n\n  // NB: Some people add symlinks into system directories. node.js will internally\n  // call realpath on paths that it finds, which will break our cache resolution.\n  // We need to catch this scenario and fix it up. The tricky part is, some parts\n  // of Electron will give us the pre-resolved paths, and others will give us the\n  // post-resolved one. We need to handle both.\n\n  let realFile = null;\n  let parts = file.split(/[\\\\\\/]app.asar[\\\\\\/]/);\n  if (!parts[1]) {\n    // Not using an ASAR archive\n    realFile = cachedRealpath(file);\n  } else {\n    // We do all this silliness to work around\n    // https://github.com/atom/electron/issues/4610\n    realFile = `${cachedRealpath(parts[0])}/app.asar/${parts[1]}`;\n  }\n\n  return realFile.replace(/[\\\\\\/]/g, '/');\n}\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9zYW5pdGl6ZS1wYXRocy5qcyJdLCJuYW1lcyI6WyJzYW5pdGl6ZUZpbGVQYXRoIiwiZCIsInJlcXVpcmUiLCJyZWFscGF0aENhY2hlIiwibWF4IiwiY2FjaGVkUmVhbHBhdGgiLCJwIiwicmV0IiwiZ2V0IiwiZnMiLCJyZWFscGF0aFN5bmMiLCJzZXQiLCJmaWxlIiwicmVhbEZpbGUiLCJwYXJ0cyIsInNwbGl0IiwicmVwbGFjZSJdLCJtYXBwaW5ncyI6Ijs7Ozs7a0JBd0J3QkEsZ0I7O0FBeEJ4Qjs7OztBQUNBOzs7Ozs7QUFFQSxNQUFNQyxJQUFJQyxRQUFRLE9BQVIsRUFBaUIsaUNBQWpCLENBQVY7QUFDQSxNQUFNQyxnQkFBZ0Isd0JBQVMsRUFBRUMsS0FBSyxJQUFQLEVBQVQsQ0FBdEI7O0FBRUEsU0FBU0MsY0FBVCxDQUF3QkMsQ0FBeEIsRUFBMkI7QUFDekIsTUFBSUMsTUFBTUosY0FBY0ssR0FBZCxDQUFrQkYsQ0FBbEIsQ0FBVjtBQUNBLE1BQUlDLEdBQUosRUFBUyxPQUFPQSxHQUFQOztBQUVUQSxRQUFNRSxhQUFHQyxZQUFILENBQWdCSixDQUFoQixDQUFOO0FBQ0FMLElBQUcsbUNBQWtDSyxDQUFFLFNBQVFDLEdBQUksR0FBbkQ7O0FBRUFKLGdCQUFjUSxHQUFkLENBQWtCTCxDQUFsQixFQUFxQkMsR0FBckI7QUFDQSxTQUFPQSxHQUFQO0FBQ0Q7O0FBRUQ7Ozs7Ozs7QUFPZSxTQUFTUCxnQkFBVCxDQUEwQlksSUFBMUIsRUFBZ0M7QUFDN0MsTUFBSSxDQUFDQSxJQUFMLEVBQVcsT0FBT0EsSUFBUDs7QUFFWDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE1BQUlDLFdBQVcsSUFBZjtBQUNBLE1BQUlDLFFBQVFGLEtBQUtHLEtBQUwsQ0FBVyxzQkFBWCxDQUFaO0FBQ0EsTUFBSSxDQUFDRCxNQUFNLENBQU4sQ0FBTCxFQUFlO0FBQ2I7QUFDQUQsZUFBV1IsZUFBZU8sSUFBZixDQUFYO0FBQ0QsR0FIRCxNQUdPO0FBQ0w7QUFDQTtBQUNBQyxlQUFZLEdBQUVSLGVBQWVTLE1BQU0sQ0FBTixDQUFmLENBQXlCLGFBQVlBLE1BQU0sQ0FBTixDQUFTLEVBQTVEO0FBQ0Q7O0FBRUQsU0FBT0QsU0FBU0csT0FBVCxDQUFpQixTQUFqQixFQUE0QixHQUE1QixDQUFQO0FBQ0QiLCJmaWxlIjoic2FuaXRpemUtcGF0aHMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgZnMgZnJvbSAnZnMnO1xuaW1wb3J0IExSVUNhY2hlIGZyb20gJ2xydS1jYWNoZSc7XG5cbmNvbnN0IGQgPSByZXF1aXJlKCdkZWJ1ZycpKCdlbGVjdHJvbi1jb21waWxlOnNhbml0aXplLXBhdGhzJyk7XG5jb25zdCByZWFscGF0aENhY2hlID0gTFJVQ2FjaGUoeyBtYXg6IDEwMjQgfSk7XG5cbmZ1bmN0aW9uIGNhY2hlZFJlYWxwYXRoKHApIHtcbiAgbGV0IHJldCA9IHJlYWxwYXRoQ2FjaGUuZ2V0KHApO1xuICBpZiAocmV0KSByZXR1cm4gcmV0O1xuXG4gIHJldCA9IGZzLnJlYWxwYXRoU3luYyhwKTtcbiAgZChgQ2FjaGUgbWlzcyBmb3IgY2FjaGVkUmVhbHBhdGg6ICcke3B9JyA9PiAnJHtyZXR9J2ApO1xuXG4gIHJlYWxwYXRoQ2FjaGUuc2V0KHAsIHJldCk7XG4gIHJldHVybiByZXQ7XG59XG5cbi8qKlxuICogRWxlY3Ryb24gd2lsbCBzb21ldGltZXMgaGFuZCB1cyBwYXRocyB0aGF0IGRvbid0IG1hdGNoIHRoZSBwbGF0Zm9ybSBpZiB0aGV5XG4gKiB3ZXJlIGRlcml2ZWQgZnJvbSBhIFVSTCAoaS5lLiAnQzovVXNlcnMvUGF1bC8uLi4nKSwgd2hlcmVhcyB0aGUgY2FjaGUgd2lsbCBoYXZlXG4gKiBzYXZlZCBwYXRocyB3aXRoIGJhY2tzbGFzaGVzLlxuICpcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHNhbml0aXplRmlsZVBhdGgoZmlsZSkge1xuICBpZiAoIWZpbGUpIHJldHVybiBmaWxlO1xuXG4gIC8vIE5COiBTb21lIHBlb3BsZSBhZGQgc3ltbGlua3MgaW50byBzeXN0ZW0gZGlyZWN0b3JpZXMuIG5vZGUuanMgd2lsbCBpbnRlcm5hbGx5XG4gIC8vIGNhbGwgcmVhbHBhdGggb24gcGF0aHMgdGhhdCBpdCBmaW5kcywgd2hpY2ggd2lsbCBicmVhayBvdXIgY2FjaGUgcmVzb2x1dGlvbi5cbiAgLy8gV2UgbmVlZCB0byBjYXRjaCB0aGlzIHNjZW5hcmlvIGFuZCBmaXggaXQgdXAuIFRoZSB0cmlja3kgcGFydCBpcywgc29tZSBwYXJ0c1xuICAvLyBvZiBFbGVjdHJvbiB3aWxsIGdpdmUgdXMgdGhlIHByZS1yZXNvbHZlZCBwYXRocywgYW5kIG90aGVycyB3aWxsIGdpdmUgdXMgdGhlXG4gIC8vIHBvc3QtcmVzb2x2ZWQgb25lLiBXZSBuZWVkIHRvIGhhbmRsZSBib3RoLlxuXG4gIGxldCByZWFsRmlsZSA9IG51bGw7XG4gIGxldCBwYXJ0cyA9IGZpbGUuc3BsaXQoL1tcXFxcXFwvXWFwcC5hc2FyW1xcXFxcXC9dLyk7XG4gIGlmICghcGFydHNbMV0pIHtcbiAgICAvLyBOb3QgdXNpbmcgYW4gQVNBUiBhcmNoaXZlXG4gICAgcmVhbEZpbGUgPSBjYWNoZWRSZWFscGF0aChmaWxlKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBXZSBkbyBhbGwgdGhpcyBzaWxsaW5lc3MgdG8gd29yayBhcm91bmRcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vYXRvbS9lbGVjdHJvbi9pc3N1ZXMvNDYxMFxuICAgIHJlYWxGaWxlID0gYCR7Y2FjaGVkUmVhbHBhdGgocGFydHNbMF0pfS9hcHAuYXNhci8ke3BhcnRzWzFdfWA7XG4gIH1cblxuICByZXR1cm4gcmVhbEZpbGUucmVwbGFjZSgvW1xcXFxcXC9dL2csICcvJyk7XG59XG4iXX0=\n\n//# sourceURL=webpack:///./node_modules/electron-compile/lib/sanitize-paths.js?")},"./node_modules/electron-compile/node_modules/rxjs/InnerSubscriber.js":
/*!****************************************************************************!*\
  !*** ./node_modules/electron-compile/node_modules/rxjs/InnerSubscriber.js ***!
  \****************************************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){"use strict";eval('\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = __webpack_require__(/*! ./Subscriber */ "./node_modules/electron-compile/node_modules/rxjs/Subscriber.js");\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar InnerSubscriber = (function (_super) {\n    __extends(InnerSubscriber, _super);\n    function InnerSubscriber(parent, outerValue, outerIndex) {\n        _super.call(this);\n        this.parent = parent;\n        this.outerValue = outerValue;\n        this.outerIndex = outerIndex;\n        this.index = 0;\n    }\n    InnerSubscriber.prototype._next = function (value) {\n        this.parent.notifyNext(this.outerValue, value, this.outerIndex, this.index++, this);\n    };\n    InnerSubscriber.prototype._error = function (error) {\n        this.parent.notifyError(error, this);\n        this.unsubscribe();\n    };\n    InnerSubscriber.prototype._complete = function () {\n        this.parent.notifyComplete(this);\n        this.unsubscribe();\n    };\n    return InnerSubscriber;\n}(Subscriber_1.Subscriber));\nexports.InnerSubscriber = InnerSubscriber;\n//# sourceMappingURL=InnerSubscriber.js.map\n\n//# sourceURL=webpack:///./node_modules/electron-compile/node_modules/rxjs/InnerSubscriber.js?')},"./node_modules/electron-compile/node_modules/rxjs/Observable.js":
/*!***********************************************************************!*\
  !*** ./node_modules/electron-compile/node_modules/rxjs/Observable.js ***!
  \***********************************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){"use strict";eval('\nvar root_1 = __webpack_require__(/*! ./util/root */ "./node_modules/electron-compile/node_modules/rxjs/util/root.js");\nvar toSubscriber_1 = __webpack_require__(/*! ./util/toSubscriber */ "./node_modules/electron-compile/node_modules/rxjs/util/toSubscriber.js");\nvar observable_1 = __webpack_require__(/*! ./symbol/observable */ "./node_modules/electron-compile/node_modules/rxjs/symbol/observable.js");\nvar pipe_1 = __webpack_require__(/*! ./util/pipe */ "./node_modules/electron-compile/node_modules/rxjs/util/pipe.js");\n/**\n * A representation of any set of values over any amount of time. This is the most basic building block\n * of RxJS.\n *\n * @class Observable<T>\n */\nvar Observable = (function () {\n    /**\n     * @constructor\n     * @param {Function} subscribe the function that is called when the Observable is\n     * initially subscribed to. This function is given a Subscriber, to which new values\n     * can be `next`ed, or an `error` method can be called to raise an error, or\n     * `complete` can be called to notify of a successful completion.\n     */\n    function Observable(subscribe) {\n        this._isScalar = false;\n        if (subscribe) {\n            this._subscribe = subscribe;\n        }\n    }\n    /**\n     * Creates a new Observable, with this Observable as the source, and the passed\n     * operator defined as the new observable\'s operator.\n     * @method lift\n     * @param {Operator} operator the operator defining the operation to take on the observable\n     * @return {Observable} a new observable with the Operator applied\n     */\n    Observable.prototype.lift = function (operator) {\n        var observable = new Observable();\n        observable.source = this;\n        observable.operator = operator;\n        return observable;\n    };\n    /**\n     * Invokes an execution of an Observable and registers Observer handlers for notifications it will emit.\n     *\n     * <span class="informal">Use it when you have all these Observables, but still nothing is happening.</span>\n     *\n     * `subscribe` is not a regular operator, but a method that calls Observable\'s internal `subscribe` function. It\n     * might be for example a function that you passed to a {@link create} static factory, but most of the time it is\n     * a library implementation, which defines what and when will be emitted by an Observable. This means that calling\n     * `subscribe` is actually the moment when Observable starts its work, not when it is created, as it is often\n     * thought.\n     *\n     * Apart from starting the execution of an Observable, this method allows you to listen for values\n     * that an Observable emits, as well as for when it completes or errors. You can achieve this in two\n     * following ways.\n     *\n     * The first way is creating an object that implements {@link Observer} interface. It should have methods\n     * defined by that interface, but note that it should be just a regular JavaScript object, which you can create\n     * yourself in any way you want (ES6 class, classic function constructor, object literal etc.). In particular do\n     * not attempt to use any RxJS implementation details to create Observers - you don\'t need them. Remember also\n     * that your object does not have to implement all methods. If you find yourself creating a method that doesn\'t\n     * do anything, you can simply omit it. Note however, that if `error` method is not provided, all errors will\n     * be left uncaught.\n     *\n     * The second way is to give up on Observer object altogether and simply provide callback functions in place of its methods.\n     * This means you can provide three functions as arguments to `subscribe`, where first function is equivalent\n     * of a `next` method, second of an `error` method and third of a `complete` method. Just as in case of Observer,\n     * if you do not need to listen for something, you can omit a function, preferably by passing `undefined` or `null`,\n     * since `subscribe` recognizes these functions by where they were placed in function call. When it comes\n     * to `error` function, just as before, if not provided, errors emitted by an Observable will be thrown.\n     *\n     * Whatever style of calling `subscribe` you use, in both cases it returns a Subscription object.\n     * This object allows you to call `unsubscribe` on it, which in turn will stop work that an Observable does and will clean\n     * up all resources that an Observable used. Note that cancelling a subscription will not call `complete` callback\n     * provided to `subscribe` function, which is reserved for a regular completion signal that comes from an Observable.\n     *\n     * Remember that callbacks provided to `subscribe` are not guaranteed to be called asynchronously.\n     * It is an Observable itself that decides when these functions will be called. For example {@link of}\n     * by default emits all its values synchronously. Always check documentation for how given Observable\n     * will behave when subscribed and if its default behavior can be modified with a {@link Scheduler}.\n     *\n     * @example <caption>Subscribe with an Observer</caption>\n     * const sumObserver = {\n     *   sum: 0,\n     *   next(value) {\n     *     console.log(\'Adding: \' + value);\n     *     this.sum = this.sum + value;\n     *   },\n     *   error() { // We actually could just remove this method,\n     *   },        // since we do not really care about errors right now.\n     *   complete() {\n     *     console.log(\'Sum equals: \' + this.sum);\n     *   }\n     * };\n     *\n     * Rx.Observable.of(1, 2, 3) // Synchronously emits 1, 2, 3 and then completes.\n     * .subscribe(sumObserver);\n     *\n     * // Logs:\n     * // "Adding: 1"\n     * // "Adding: 2"\n     * // "Adding: 3"\n     * // "Sum equals: 6"\n     *\n     *\n     * @example <caption>Subscribe with functions</caption>\n     * let sum = 0;\n     *\n     * Rx.Observable.of(1, 2, 3)\n     * .subscribe(\n     *   function(value) {\n     *     console.log(\'Adding: \' + value);\n     *     sum = sum + value;\n     *   },\n     *   undefined,\n     *   function() {\n     *     console.log(\'Sum equals: \' + sum);\n     *   }\n     * );\n     *\n     * // Logs:\n     * // "Adding: 1"\n     * // "Adding: 2"\n     * // "Adding: 3"\n     * // "Sum equals: 6"\n     *\n     *\n     * @example <caption>Cancel a subscription</caption>\n     * const subscription = Rx.Observable.interval(1000).subscribe(\n     *   num => console.log(num),\n     *   undefined,\n     *   () => console.log(\'completed!\') // Will not be called, even\n     * );                                // when cancelling subscription\n     *\n     *\n     * setTimeout(() => {\n     *   subscription.unsubscribe();\n     *   console.log(\'unsubscribed!\');\n     * }, 2500);\n     *\n     * // Logs:\n     * // 0 after 1s\n     * // 1 after 2s\n     * // "unsubscribed!" after 2.5s\n     *\n     *\n     * @param {Observer|Function} observerOrNext (optional) Either an observer with methods to be called,\n     *  or the first of three possible handlers, which is the handler for each value emitted from the subscribed\n     *  Observable.\n     * @param {Function} error (optional) A handler for a terminal event resulting from an error. If no error handler is provided,\n     *  the error will be thrown as unhandled.\n     * @param {Function} complete (optional) A handler for a terminal event resulting from successful completion.\n     * @return {ISubscription} a subscription reference to the registered handlers\n     * @method subscribe\n     */\n    Observable.prototype.subscribe = function (observerOrNext, error, complete) {\n        var operator = this.operator;\n        var sink = toSubscriber_1.toSubscriber(observerOrNext, error, complete);\n        if (operator) {\n            operator.call(sink, this.source);\n        }\n        else {\n            sink.add(this.source || !sink.syncErrorThrowable ? this._subscribe(sink) : this._trySubscribe(sink));\n        }\n        if (sink.syncErrorThrowable) {\n            sink.syncErrorThrowable = false;\n            if (sink.syncErrorThrown) {\n                throw sink.syncErrorValue;\n            }\n        }\n        return sink;\n    };\n    Observable.prototype._trySubscribe = function (sink) {\n        try {\n            return this._subscribe(sink);\n        }\n        catch (err) {\n            sink.syncErrorThrown = true;\n            sink.syncErrorValue = err;\n            sink.error(err);\n        }\n    };\n    /**\n     * @method forEach\n     * @param {Function} next a handler for each value emitted by the observable\n     * @param {PromiseConstructor} [PromiseCtor] a constructor function used to instantiate the Promise\n     * @return {Promise} a promise that either resolves on observable completion or\n     *  rejects with the handled error\n     */\n    Observable.prototype.forEach = function (next, PromiseCtor) {\n        var _this = this;\n        if (!PromiseCtor) {\n            if (root_1.root.Rx && root_1.root.Rx.config && root_1.root.Rx.config.Promise) {\n                PromiseCtor = root_1.root.Rx.config.Promise;\n            }\n            else if (root_1.root.Promise) {\n                PromiseCtor = root_1.root.Promise;\n            }\n        }\n        if (!PromiseCtor) {\n            throw new Error(\'no Promise impl found\');\n        }\n        return new PromiseCtor(function (resolve, reject) {\n            // Must be declared in a separate statement to avoid a RefernceError when\n            // accessing subscription below in the closure due to Temporal Dead Zone.\n            var subscription;\n            subscription = _this.subscribe(function (value) {\n                if (subscription) {\n                    // if there is a subscription, then we can surmise\n                    // the next handling is asynchronous. Any errors thrown\n                    // need to be rejected explicitly and unsubscribe must be\n                    // called manually\n                    try {\n                        next(value);\n                    }\n                    catch (err) {\n                        reject(err);\n                        subscription.unsubscribe();\n                    }\n                }\n                else {\n                    // if there is NO subscription, then we\'re getting a nexted\n                    // value synchronously during subscription. We can just call it.\n                    // If it errors, Observable\'s `subscribe` will ensure the\n                    // unsubscription logic is called, then synchronously rethrow the error.\n                    // After that, Promise will trap the error and send it\n                    // down the rejection path.\n                    next(value);\n                }\n            }, reject, resolve);\n        });\n    };\n    /** @deprecated internal use only */ Observable.prototype._subscribe = function (subscriber) {\n        return this.source.subscribe(subscriber);\n    };\n    /**\n     * An interop point defined by the es7-observable spec https://github.com/zenparsing/es-observable\n     * @method Symbol.observable\n     * @return {Observable} this instance of the observable\n     */\n    Observable.prototype[observable_1.observable] = function () {\n        return this;\n    };\n    /* tslint:enable:max-line-length */\n    /**\n     * Used to stitch together functional operators into a chain.\n     * @method pipe\n     * @return {Observable} the Observable result of all of the operators having\n     * been called in the order they were passed in.\n     *\n     * @example\n     *\n     * import { map, filter, scan } from \'rxjs/operators\';\n     *\n     * Rx.Observable.interval(1000)\n     *   .pipe(\n     *     filter(x => x % 2 === 0),\n     *     map(x => x + x),\n     *     scan((acc, x) => acc + x)\n     *   )\n     *   .subscribe(x => console.log(x))\n     */\n    Observable.prototype.pipe = function () {\n        var operations = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            operations[_i - 0] = arguments[_i];\n        }\n        if (operations.length === 0) {\n            return this;\n        }\n        return pipe_1.pipeFromArray(operations)(this);\n    };\n    /* tslint:enable:max-line-length */\n    Observable.prototype.toPromise = function (PromiseCtor) {\n        var _this = this;\n        if (!PromiseCtor) {\n            if (root_1.root.Rx && root_1.root.Rx.config && root_1.root.Rx.config.Promise) {\n                PromiseCtor = root_1.root.Rx.config.Promise;\n            }\n            else if (root_1.root.Promise) {\n                PromiseCtor = root_1.root.Promise;\n            }\n        }\n        if (!PromiseCtor) {\n            throw new Error(\'no Promise impl found\');\n        }\n        return new PromiseCtor(function (resolve, reject) {\n            var value;\n            _this.subscribe(function (x) { return value = x; }, function (err) { return reject(err); }, function () { return resolve(value); });\n        });\n    };\n    // HACK: Since TypeScript inherits static properties too, we have to\n    // fight against TypeScript here so Subject can have a different static create signature\n    /**\n     * Creates a new cold Observable by calling the Observable constructor\n     * @static true\n     * @owner Observable\n     * @method create\n     * @param {Function} subscribe? the subscriber function to be passed to the Observable constructor\n     * @return {Observable} a new cold observable\n     */\n    Observable.create = function (subscribe) {\n        return new Observable(subscribe);\n    };\n    return Observable;\n}());\nexports.Observable = Observable;\n//# sourceMappingURL=Observable.js.map\n\n//# sourceURL=webpack:///./node_modules/electron-compile/node_modules/rxjs/Observable.js?')},"./node_modules/electron-compile/node_modules/rxjs/Observer.js":
/*!*********************************************************************!*\
  !*** ./node_modules/electron-compile/node_modules/rxjs/Observer.js ***!
  \*********************************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){"use strict";eval("\nexports.empty = {\n    closed: true,\n    next: function (value) { },\n    error: function (err) { throw err; },\n    complete: function () { }\n};\n//# sourceMappingURL=Observer.js.map\n\n//# sourceURL=webpack:///./node_modules/electron-compile/node_modules/rxjs/Observer.js?")},"./node_modules/electron-compile/node_modules/rxjs/OuterSubscriber.js":
/*!****************************************************************************!*\
  !*** ./node_modules/electron-compile/node_modules/rxjs/OuterSubscriber.js ***!
  \****************************************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){"use strict";eval('\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = __webpack_require__(/*! ./Subscriber */ "./node_modules/electron-compile/node_modules/rxjs/Subscriber.js");\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar OuterSubscriber = (function (_super) {\n    __extends(OuterSubscriber, _super);\n    function OuterSubscriber() {\n        _super.apply(this, arguments);\n    }\n    OuterSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n        this.destination.next(innerValue);\n    };\n    OuterSubscriber.prototype.notifyError = function (error, innerSub) {\n        this.destination.error(error);\n    };\n    OuterSubscriber.prototype.notifyComplete = function (innerSub) {\n        this.destination.complete();\n    };\n    return OuterSubscriber;\n}(Subscriber_1.Subscriber));\nexports.OuterSubscriber = OuterSubscriber;\n//# sourceMappingURL=OuterSubscriber.js.map\n\n//# sourceURL=webpack:///./node_modules/electron-compile/node_modules/rxjs/OuterSubscriber.js?')},"./node_modules/electron-compile/node_modules/rxjs/Scheduler.js":
/*!**********************************************************************!*\
  !*** ./node_modules/electron-compile/node_modules/rxjs/Scheduler.js ***!
  \**********************************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){"use strict";eval("\n/**\n * An execution context and a data structure to order tasks and schedule their\n * execution. Provides a notion of (potentially virtual) time, through the\n * `now()` getter method.\n *\n * Each unit of work in a Scheduler is called an {@link Action}.\n *\n * ```ts\n * class Scheduler {\n *   now(): number;\n *   schedule(work, delay?, state?): Subscription;\n * }\n * ```\n *\n * @class Scheduler\n */\nvar Scheduler = (function () {\n    function Scheduler(SchedulerAction, now) {\n        if (now === void 0) { now = Scheduler.now; }\n        this.SchedulerAction = SchedulerAction;\n        this.now = now;\n    }\n    /**\n     * Schedules a function, `work`, for execution. May happen at some point in\n     * the future, according to the `delay` parameter, if specified. May be passed\n     * some context object, `state`, which will be passed to the `work` function.\n     *\n     * The given arguments will be processed an stored as an Action object in a\n     * queue of actions.\n     *\n     * @param {function(state: ?T): ?Subscription} work A function representing a\n     * task, or some unit of work to be executed by the Scheduler.\n     * @param {number} [delay] Time to wait before executing the work, where the\n     * time unit is implicit and defined by the Scheduler itself.\n     * @param {T} [state] Some contextual data that the `work` function uses when\n     * called by the Scheduler.\n     * @return {Subscription} A subscription in order to be able to unsubscribe\n     * the scheduled work.\n     */\n    Scheduler.prototype.schedule = function (work, delay, state) {\n        if (delay === void 0) { delay = 0; }\n        return new this.SchedulerAction(this, work).schedule(state, delay);\n    };\n    Scheduler.now = Date.now ? Date.now : function () { return +new Date(); };\n    return Scheduler;\n}());\nexports.Scheduler = Scheduler;\n//# sourceMappingURL=Scheduler.js.map\n\n//# sourceURL=webpack:///./node_modules/electron-compile/node_modules/rxjs/Scheduler.js?")},"./node_modules/electron-compile/node_modules/rxjs/Subject.js":
/*!********************************************************************!*\
  !*** ./node_modules/electron-compile/node_modules/rxjs/Subject.js ***!
  \********************************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){"use strict";eval('\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Observable_1 = __webpack_require__(/*! ./Observable */ "./node_modules/electron-compile/node_modules/rxjs/Observable.js");\nvar Subscriber_1 = __webpack_require__(/*! ./Subscriber */ "./node_modules/electron-compile/node_modules/rxjs/Subscriber.js");\nvar Subscription_1 = __webpack_require__(/*! ./Subscription */ "./node_modules/electron-compile/node_modules/rxjs/Subscription.js");\nvar ObjectUnsubscribedError_1 = __webpack_require__(/*! ./util/ObjectUnsubscribedError */ "./node_modules/electron-compile/node_modules/rxjs/util/ObjectUnsubscribedError.js");\nvar SubjectSubscription_1 = __webpack_require__(/*! ./SubjectSubscription */ "./node_modules/electron-compile/node_modules/rxjs/SubjectSubscription.js");\nvar rxSubscriber_1 = __webpack_require__(/*! ./symbol/rxSubscriber */ "./node_modules/electron-compile/node_modules/rxjs/symbol/rxSubscriber.js");\n/**\n * @class SubjectSubscriber<T>\n */\nvar SubjectSubscriber = (function (_super) {\n    __extends(SubjectSubscriber, _super);\n    function SubjectSubscriber(destination) {\n        _super.call(this, destination);\n        this.destination = destination;\n    }\n    return SubjectSubscriber;\n}(Subscriber_1.Subscriber));\nexports.SubjectSubscriber = SubjectSubscriber;\n/**\n * @class Subject<T>\n */\nvar Subject = (function (_super) {\n    __extends(Subject, _super);\n    function Subject() {\n        _super.call(this);\n        this.observers = [];\n        this.closed = false;\n        this.isStopped = false;\n        this.hasError = false;\n        this.thrownError = null;\n    }\n    Subject.prototype[rxSubscriber_1.rxSubscriber] = function () {\n        return new SubjectSubscriber(this);\n    };\n    Subject.prototype.lift = function (operator) {\n        var subject = new AnonymousSubject(this, this);\n        subject.operator = operator;\n        return subject;\n    };\n    Subject.prototype.next = function (value) {\n        if (this.closed) {\n            throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();\n        }\n        if (!this.isStopped) {\n            var observers = this.observers;\n            var len = observers.length;\n            var copy = observers.slice();\n            for (var i = 0; i < len; i++) {\n                copy[i].next(value);\n            }\n        }\n    };\n    Subject.prototype.error = function (err) {\n        if (this.closed) {\n            throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();\n        }\n        this.hasError = true;\n        this.thrownError = err;\n        this.isStopped = true;\n        var observers = this.observers;\n        var len = observers.length;\n        var copy = observers.slice();\n        for (var i = 0; i < len; i++) {\n            copy[i].error(err);\n        }\n        this.observers.length = 0;\n    };\n    Subject.prototype.complete = function () {\n        if (this.closed) {\n            throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();\n        }\n        this.isStopped = true;\n        var observers = this.observers;\n        var len = observers.length;\n        var copy = observers.slice();\n        for (var i = 0; i < len; i++) {\n            copy[i].complete();\n        }\n        this.observers.length = 0;\n    };\n    Subject.prototype.unsubscribe = function () {\n        this.isStopped = true;\n        this.closed = true;\n        this.observers = null;\n    };\n    Subject.prototype._trySubscribe = function (subscriber) {\n        if (this.closed) {\n            throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();\n        }\n        else {\n            return _super.prototype._trySubscribe.call(this, subscriber);\n        }\n    };\n    /** @deprecated internal use only */ Subject.prototype._subscribe = function (subscriber) {\n        if (this.closed) {\n            throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();\n        }\n        else if (this.hasError) {\n            subscriber.error(this.thrownError);\n            return Subscription_1.Subscription.EMPTY;\n        }\n        else if (this.isStopped) {\n            subscriber.complete();\n            return Subscription_1.Subscription.EMPTY;\n        }\n        else {\n            this.observers.push(subscriber);\n            return new SubjectSubscription_1.SubjectSubscription(this, subscriber);\n        }\n    };\n    Subject.prototype.asObservable = function () {\n        var observable = new Observable_1.Observable();\n        observable.source = this;\n        return observable;\n    };\n    Subject.create = function (destination, source) {\n        return new AnonymousSubject(destination, source);\n    };\n    return Subject;\n}(Observable_1.Observable));\nexports.Subject = Subject;\n/**\n * @class AnonymousSubject<T>\n */\nvar AnonymousSubject = (function (_super) {\n    __extends(AnonymousSubject, _super);\n    function AnonymousSubject(destination, source) {\n        _super.call(this);\n        this.destination = destination;\n        this.source = source;\n    }\n    AnonymousSubject.prototype.next = function (value) {\n        var destination = this.destination;\n        if (destination && destination.next) {\n            destination.next(value);\n        }\n    };\n    AnonymousSubject.prototype.error = function (err) {\n        var destination = this.destination;\n        if (destination && destination.error) {\n            this.destination.error(err);\n        }\n    };\n    AnonymousSubject.prototype.complete = function () {\n        var destination = this.destination;\n        if (destination && destination.complete) {\n            this.destination.complete();\n        }\n    };\n    /** @deprecated internal use only */ AnonymousSubject.prototype._subscribe = function (subscriber) {\n        var source = this.source;\n        if (source) {\n            return this.source.subscribe(subscriber);\n        }\n        else {\n            return Subscription_1.Subscription.EMPTY;\n        }\n    };\n    return AnonymousSubject;\n}(Subject));\nexports.AnonymousSubject = AnonymousSubject;\n//# sourceMappingURL=Subject.js.map\n\n//# sourceURL=webpack:///./node_modules/electron-compile/node_modules/rxjs/Subject.js?')},"./node_modules/electron-compile/node_modules/rxjs/SubjectSubscription.js":
/*!********************************************************************************!*\
  !*** ./node_modules/electron-compile/node_modules/rxjs/SubjectSubscription.js ***!
  \********************************************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){"use strict";eval('\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscription_1 = __webpack_require__(/*! ./Subscription */ "./node_modules/electron-compile/node_modules/rxjs/Subscription.js");\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar SubjectSubscription = (function (_super) {\n    __extends(SubjectSubscription, _super);\n    function SubjectSubscription(subject, subscriber) {\n        _super.call(this);\n        this.subject = subject;\n        this.subscriber = subscriber;\n        this.closed = false;\n    }\n    SubjectSubscription.prototype.unsubscribe = function () {\n        if (this.closed) {\n            return;\n        }\n        this.closed = true;\n        var subject = this.subject;\n        var observers = subject.observers;\n        this.subject = null;\n        if (!observers || observers.length === 0 || subject.isStopped || subject.closed) {\n            return;\n        }\n        var subscriberIndex = observers.indexOf(this.subscriber);\n        if (subscriberIndex !== -1) {\n            observers.splice(subscriberIndex, 1);\n        }\n    };\n    return SubjectSubscription;\n}(Subscription_1.Subscription));\nexports.SubjectSubscription = SubjectSubscription;\n//# sourceMappingURL=SubjectSubscription.js.map\n\n//# sourceURL=webpack:///./node_modules/electron-compile/node_modules/rxjs/SubjectSubscription.js?')},"./node_modules/electron-compile/node_modules/rxjs/Subscriber.js":
/*!***********************************************************************!*\
  !*** ./node_modules/electron-compile/node_modules/rxjs/Subscriber.js ***!
  \***********************************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){"use strict";eval('\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar isFunction_1 = __webpack_require__(/*! ./util/isFunction */ "./node_modules/electron-compile/node_modules/rxjs/util/isFunction.js");\nvar Subscription_1 = __webpack_require__(/*! ./Subscription */ "./node_modules/electron-compile/node_modules/rxjs/Subscription.js");\nvar Observer_1 = __webpack_require__(/*! ./Observer */ "./node_modules/electron-compile/node_modules/rxjs/Observer.js");\nvar rxSubscriber_1 = __webpack_require__(/*! ./symbol/rxSubscriber */ "./node_modules/electron-compile/node_modules/rxjs/symbol/rxSubscriber.js");\n/**\n * Implements the {@link Observer} interface and extends the\n * {@link Subscription} class. While the {@link Observer} is the public API for\n * consuming the values of an {@link Observable}, all Observers get converted to\n * a Subscriber, in order to provide Subscription-like capabilities such as\n * `unsubscribe`. Subscriber is a common type in RxJS, and crucial for\n * implementing operators, but it is rarely used as a public API.\n *\n * @class Subscriber<T>\n */\nvar Subscriber = (function (_super) {\n    __extends(Subscriber, _super);\n    /**\n     * @param {Observer|function(value: T): void} [destinationOrNext] A partially\n     * defined Observer or a `next` callback function.\n     * @param {function(e: ?any): void} [error] The `error` callback of an\n     * Observer.\n     * @param {function(): void} [complete] The `complete` callback of an\n     * Observer.\n     */\n    function Subscriber(destinationOrNext, error, complete) {\n        _super.call(this);\n        this.syncErrorValue = null;\n        this.syncErrorThrown = false;\n        this.syncErrorThrowable = false;\n        this.isStopped = false;\n        switch (arguments.length) {\n            case 0:\n                this.destination = Observer_1.empty;\n                break;\n            case 1:\n                if (!destinationOrNext) {\n                    this.destination = Observer_1.empty;\n                    break;\n                }\n                if (typeof destinationOrNext === \'object\') {\n                    // HACK(benlesh): To resolve an issue where Node users may have multiple\n                    // copies of rxjs in their node_modules directory.\n                    if (isTrustedSubscriber(destinationOrNext)) {\n                        var trustedSubscriber = destinationOrNext[rxSubscriber_1.rxSubscriber]();\n                        this.syncErrorThrowable = trustedSubscriber.syncErrorThrowable;\n                        this.destination = trustedSubscriber;\n                        trustedSubscriber.add(this);\n                    }\n                    else {\n                        this.syncErrorThrowable = true;\n                        this.destination = new SafeSubscriber(this, destinationOrNext);\n                    }\n                    break;\n                }\n            default:\n                this.syncErrorThrowable = true;\n                this.destination = new SafeSubscriber(this, destinationOrNext, error, complete);\n                break;\n        }\n    }\n    Subscriber.prototype[rxSubscriber_1.rxSubscriber] = function () { return this; };\n    /**\n     * A static factory for a Subscriber, given a (potentially partial) definition\n     * of an Observer.\n     * @param {function(x: ?T): void} [next] The `next` callback of an Observer.\n     * @param {function(e: ?any): void} [error] The `error` callback of an\n     * Observer.\n     * @param {function(): void} [complete] The `complete` callback of an\n     * Observer.\n     * @return {Subscriber<T>} A Subscriber wrapping the (partially defined)\n     * Observer represented by the given arguments.\n     */\n    Subscriber.create = function (next, error, complete) {\n        var subscriber = new Subscriber(next, error, complete);\n        subscriber.syncErrorThrowable = false;\n        return subscriber;\n    };\n    /**\n     * The {@link Observer} callback to receive notifications of type `next` from\n     * the Observable, with a value. The Observable may call this method 0 or more\n     * times.\n     * @param {T} [value] The `next` value.\n     * @return {void}\n     */\n    Subscriber.prototype.next = function (value) {\n        if (!this.isStopped) {\n            this._next(value);\n        }\n    };\n    /**\n     * The {@link Observer} callback to receive notifications of type `error` from\n     * the Observable, with an attached {@link Error}. Notifies the Observer that\n     * the Observable has experienced an error condition.\n     * @param {any} [err] The `error` exception.\n     * @return {void}\n     */\n    Subscriber.prototype.error = function (err) {\n        if (!this.isStopped) {\n            this.isStopped = true;\n            this._error(err);\n        }\n    };\n    /**\n     * The {@link Observer} callback to receive a valueless notification of type\n     * `complete` from the Observable. Notifies the Observer that the Observable\n     * has finished sending push-based notifications.\n     * @return {void}\n     */\n    Subscriber.prototype.complete = function () {\n        if (!this.isStopped) {\n            this.isStopped = true;\n            this._complete();\n        }\n    };\n    Subscriber.prototype.unsubscribe = function () {\n        if (this.closed) {\n            return;\n        }\n        this.isStopped = true;\n        _super.prototype.unsubscribe.call(this);\n    };\n    Subscriber.prototype._next = function (value) {\n        this.destination.next(value);\n    };\n    Subscriber.prototype._error = function (err) {\n        this.destination.error(err);\n        this.unsubscribe();\n    };\n    Subscriber.prototype._complete = function () {\n        this.destination.complete();\n        this.unsubscribe();\n    };\n    /** @deprecated internal use only */ Subscriber.prototype._unsubscribeAndRecycle = function () {\n        var _a = this, _parent = _a._parent, _parents = _a._parents;\n        this._parent = null;\n        this._parents = null;\n        this.unsubscribe();\n        this.closed = false;\n        this.isStopped = false;\n        this._parent = _parent;\n        this._parents = _parents;\n        return this;\n    };\n    return Subscriber;\n}(Subscription_1.Subscription));\nexports.Subscriber = Subscriber;\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar SafeSubscriber = (function (_super) {\n    __extends(SafeSubscriber, _super);\n    function SafeSubscriber(_parentSubscriber, observerOrNext, error, complete) {\n        _super.call(this);\n        this._parentSubscriber = _parentSubscriber;\n        var next;\n        var context = this;\n        if (isFunction_1.isFunction(observerOrNext)) {\n            next = observerOrNext;\n        }\n        else if (observerOrNext) {\n            next = observerOrNext.next;\n            error = observerOrNext.error;\n            complete = observerOrNext.complete;\n            if (observerOrNext !== Observer_1.empty) {\n                context = Object.create(observerOrNext);\n                if (isFunction_1.isFunction(context.unsubscribe)) {\n                    this.add(context.unsubscribe.bind(context));\n                }\n                context.unsubscribe = this.unsubscribe.bind(this);\n            }\n        }\n        this._context = context;\n        this._next = next;\n        this._error = error;\n        this._complete = complete;\n    }\n    SafeSubscriber.prototype.next = function (value) {\n        if (!this.isStopped && this._next) {\n            var _parentSubscriber = this._parentSubscriber;\n            if (!_parentSubscriber.syncErrorThrowable) {\n                this.__tryOrUnsub(this._next, value);\n            }\n            else if (this.__tryOrSetError(_parentSubscriber, this._next, value)) {\n                this.unsubscribe();\n            }\n        }\n    };\n    SafeSubscriber.prototype.error = function (err) {\n        if (!this.isStopped) {\n            var _parentSubscriber = this._parentSubscriber;\n            if (this._error) {\n                if (!_parentSubscriber.syncErrorThrowable) {\n                    this.__tryOrUnsub(this._error, err);\n                    this.unsubscribe();\n                }\n                else {\n                    this.__tryOrSetError(_parentSubscriber, this._error, err);\n                    this.unsubscribe();\n                }\n            }\n            else if (!_parentSubscriber.syncErrorThrowable) {\n                this.unsubscribe();\n                throw err;\n            }\n            else {\n                _parentSubscriber.syncErrorValue = err;\n                _parentSubscriber.syncErrorThrown = true;\n                this.unsubscribe();\n            }\n        }\n    };\n    SafeSubscriber.prototype.complete = function () {\n        var _this = this;\n        if (!this.isStopped) {\n            var _parentSubscriber = this._parentSubscriber;\n            if (this._complete) {\n                var wrappedComplete = function () { return _this._complete.call(_this._context); };\n                if (!_parentSubscriber.syncErrorThrowable) {\n                    this.__tryOrUnsub(wrappedComplete);\n                    this.unsubscribe();\n                }\n                else {\n                    this.__tryOrSetError(_parentSubscriber, wrappedComplete);\n                    this.unsubscribe();\n                }\n            }\n            else {\n                this.unsubscribe();\n            }\n        }\n    };\n    SafeSubscriber.prototype.__tryOrUnsub = function (fn, value) {\n        try {\n            fn.call(this._context, value);\n        }\n        catch (err) {\n            this.unsubscribe();\n            throw err;\n        }\n    };\n    SafeSubscriber.prototype.__tryOrSetError = function (parent, fn, value) {\n        try {\n            fn.call(this._context, value);\n        }\n        catch (err) {\n            parent.syncErrorValue = err;\n            parent.syncErrorThrown = true;\n            return true;\n        }\n        return false;\n    };\n    /** @deprecated internal use only */ SafeSubscriber.prototype._unsubscribe = function () {\n        var _parentSubscriber = this._parentSubscriber;\n        this._context = null;\n        this._parentSubscriber = null;\n        _parentSubscriber.unsubscribe();\n    };\n    return SafeSubscriber;\n}(Subscriber));\nfunction isTrustedSubscriber(obj) {\n    return obj instanceof Subscriber || (\'syncErrorThrowable\' in obj && obj[rxSubscriber_1.rxSubscriber]);\n}\n//# sourceMappingURL=Subscriber.js.map\n\n//# sourceURL=webpack:///./node_modules/electron-compile/node_modules/rxjs/Subscriber.js?')},"./node_modules/electron-compile/node_modules/rxjs/Subscription.js":
/*!*************************************************************************!*\
  !*** ./node_modules/electron-compile/node_modules/rxjs/Subscription.js ***!
  \*************************************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){"use strict";eval("\nvar isArray_1 = __webpack_require__(/*! ./util/isArray */ \"./node_modules/electron-compile/node_modules/rxjs/util/isArray.js\");\nvar isObject_1 = __webpack_require__(/*! ./util/isObject */ \"./node_modules/electron-compile/node_modules/rxjs/util/isObject.js\");\nvar isFunction_1 = __webpack_require__(/*! ./util/isFunction */ \"./node_modules/electron-compile/node_modules/rxjs/util/isFunction.js\");\nvar tryCatch_1 = __webpack_require__(/*! ./util/tryCatch */ \"./node_modules/electron-compile/node_modules/rxjs/util/tryCatch.js\");\nvar errorObject_1 = __webpack_require__(/*! ./util/errorObject */ \"./node_modules/electron-compile/node_modules/rxjs/util/errorObject.js\");\nvar UnsubscriptionError_1 = __webpack_require__(/*! ./util/UnsubscriptionError */ \"./node_modules/electron-compile/node_modules/rxjs/util/UnsubscriptionError.js\");\n/**\n * Represents a disposable resource, such as the execution of an Observable. A\n * Subscription has one important method, `unsubscribe`, that takes no argument\n * and just disposes the resource held by the subscription.\n *\n * Additionally, subscriptions may be grouped together through the `add()`\n * method, which will attach a child Subscription to the current Subscription.\n * When a Subscription is unsubscribed, all its children (and its grandchildren)\n * will be unsubscribed as well.\n *\n * @class Subscription\n */\nvar Subscription = (function () {\n    /**\n     * @param {function(): void} [unsubscribe] A function describing how to\n     * perform the disposal of resources when the `unsubscribe` method is called.\n     */\n    function Subscription(unsubscribe) {\n        /**\n         * A flag to indicate whether this Subscription has already been unsubscribed.\n         * @type {boolean}\n         */\n        this.closed = false;\n        this._parent = null;\n        this._parents = null;\n        this._subscriptions = null;\n        if (unsubscribe) {\n            this._unsubscribe = unsubscribe;\n        }\n    }\n    /**\n     * Disposes the resources held by the subscription. May, for instance, cancel\n     * an ongoing Observable execution or cancel any other type of work that\n     * started when the Subscription was created.\n     * @return {void}\n     */\n    Subscription.prototype.unsubscribe = function () {\n        var hasErrors = false;\n        var errors;\n        if (this.closed) {\n            return;\n        }\n        var _a = this, _parent = _a._parent, _parents = _a._parents, _unsubscribe = _a._unsubscribe, _subscriptions = _a._subscriptions;\n        this.closed = true;\n        this._parent = null;\n        this._parents = null;\n        // null out _subscriptions first so any child subscriptions that attempt\n        // to remove themselves from this subscription will noop\n        this._subscriptions = null;\n        var index = -1;\n        var len = _parents ? _parents.length : 0;\n        // if this._parent is null, then so is this._parents, and we\n        // don't have to remove ourselves from any parent subscriptions.\n        while (_parent) {\n            _parent.remove(this);\n            // if this._parents is null or index >= len,\n            // then _parent is set to null, and the loop exits\n            _parent = ++index < len && _parents[index] || null;\n        }\n        if (isFunction_1.isFunction(_unsubscribe)) {\n            var trial = tryCatch_1.tryCatch(_unsubscribe).call(this);\n            if (trial === errorObject_1.errorObject) {\n                hasErrors = true;\n                errors = errors || (errorObject_1.errorObject.e instanceof UnsubscriptionError_1.UnsubscriptionError ?\n                    flattenUnsubscriptionErrors(errorObject_1.errorObject.e.errors) : [errorObject_1.errorObject.e]);\n            }\n        }\n        if (isArray_1.isArray(_subscriptions)) {\n            index = -1;\n            len = _subscriptions.length;\n            while (++index < len) {\n                var sub = _subscriptions[index];\n                if (isObject_1.isObject(sub)) {\n                    var trial = tryCatch_1.tryCatch(sub.unsubscribe).call(sub);\n                    if (trial === errorObject_1.errorObject) {\n                        hasErrors = true;\n                        errors = errors || [];\n                        var err = errorObject_1.errorObject.e;\n                        if (err instanceof UnsubscriptionError_1.UnsubscriptionError) {\n                            errors = errors.concat(flattenUnsubscriptionErrors(err.errors));\n                        }\n                        else {\n                            errors.push(err);\n                        }\n                    }\n                }\n            }\n        }\n        if (hasErrors) {\n            throw new UnsubscriptionError_1.UnsubscriptionError(errors);\n        }\n    };\n    /**\n     * Adds a tear down to be called during the unsubscribe() of this\n     * Subscription.\n     *\n     * If the tear down being added is a subscription that is already\n     * unsubscribed, is the same reference `add` is being called on, or is\n     * `Subscription.EMPTY`, it will not be added.\n     *\n     * If this subscription is already in an `closed` state, the passed\n     * tear down logic will be executed immediately.\n     *\n     * @param {TeardownLogic} teardown The additional logic to execute on\n     * teardown.\n     * @return {Subscription} Returns the Subscription used or created to be\n     * added to the inner subscriptions list. This Subscription can be used with\n     * `remove()` to remove the passed teardown logic from the inner subscriptions\n     * list.\n     */\n    Subscription.prototype.add = function (teardown) {\n        if (!teardown || (teardown === Subscription.EMPTY)) {\n            return Subscription.EMPTY;\n        }\n        if (teardown === this) {\n            return this;\n        }\n        var subscription = teardown;\n        switch (typeof teardown) {\n            case 'function':\n                subscription = new Subscription(teardown);\n            case 'object':\n                if (subscription.closed || typeof subscription.unsubscribe !== 'function') {\n                    return subscription;\n                }\n                else if (this.closed) {\n                    subscription.unsubscribe();\n                    return subscription;\n                }\n                else if (typeof subscription._addParent !== 'function' /* quack quack */) {\n                    var tmp = subscription;\n                    subscription = new Subscription();\n                    subscription._subscriptions = [tmp];\n                }\n                break;\n            default:\n                throw new Error('unrecognized teardown ' + teardown + ' added to Subscription.');\n        }\n        var subscriptions = this._subscriptions || (this._subscriptions = []);\n        subscriptions.push(subscription);\n        subscription._addParent(this);\n        return subscription;\n    };\n    /**\n     * Removes a Subscription from the internal list of subscriptions that will\n     * unsubscribe during the unsubscribe process of this Subscription.\n     * @param {Subscription} subscription The subscription to remove.\n     * @return {void}\n     */\n    Subscription.prototype.remove = function (subscription) {\n        var subscriptions = this._subscriptions;\n        if (subscriptions) {\n            var subscriptionIndex = subscriptions.indexOf(subscription);\n            if (subscriptionIndex !== -1) {\n                subscriptions.splice(subscriptionIndex, 1);\n            }\n        }\n    };\n    Subscription.prototype._addParent = function (parent) {\n        var _a = this, _parent = _a._parent, _parents = _a._parents;\n        if (!_parent || _parent === parent) {\n            // If we don't have a parent, or the new parent is the same as the\n            // current parent, then set this._parent to the new parent.\n            this._parent = parent;\n        }\n        else if (!_parents) {\n            // If there's already one parent, but not multiple, allocate an Array to\n            // store the rest of the parent Subscriptions.\n            this._parents = [parent];\n        }\n        else if (_parents.indexOf(parent) === -1) {\n            // Only add the new parent to the _parents list if it's not already there.\n            _parents.push(parent);\n        }\n    };\n    Subscription.EMPTY = (function (empty) {\n        empty.closed = true;\n        return empty;\n    }(new Subscription()));\n    return Subscription;\n}());\nexports.Subscription = Subscription;\nfunction flattenUnsubscriptionErrors(errors) {\n    return errors.reduce(function (errs, err) { return errs.concat((err instanceof UnsubscriptionError_1.UnsubscriptionError) ? err.errors : err); }, []);\n}\n//# sourceMappingURL=Subscription.js.map\n\n//# sourceURL=webpack:///./node_modules/electron-compile/node_modules/rxjs/Subscription.js?")},"./node_modules/electron-compile/node_modules/rxjs/add/observable/defer.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/electron-compile/node_modules/rxjs/add/observable/defer.js ***!
  \*********************************************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){"use strict";eval('\nvar Observable_1 = __webpack_require__(/*! ../../Observable */ "./node_modules/electron-compile/node_modules/rxjs/Observable.js");\nvar defer_1 = __webpack_require__(/*! ../../observable/defer */ "./node_modules/electron-compile/node_modules/rxjs/observable/defer.js");\nObservable_1.Observable.defer = defer_1.defer;\n//# sourceMappingURL=defer.js.map\n\n//# sourceURL=webpack:///./node_modules/electron-compile/node_modules/rxjs/add/observable/defer.js?')},"./node_modules/electron-compile/node_modules/rxjs/add/observable/empty.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/electron-compile/node_modules/rxjs/add/observable/empty.js ***!
  \*********************************************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){"use strict";eval('\nvar Observable_1 = __webpack_require__(/*! ../../Observable */ "./node_modules/electron-compile/node_modules/rxjs/Observable.js");\nvar empty_1 = __webpack_require__(/*! ../../observable/empty */ "./node_modules/electron-compile/node_modules/rxjs/observable/empty.js");\nObservable_1.Observable.empty = empty_1.empty;\n//# sourceMappingURL=empty.js.map\n\n//# sourceURL=webpack:///./node_modules/electron-compile/node_modules/rxjs/add/observable/empty.js?')},"./node_modules/electron-compile/node_modules/rxjs/add/observable/fromPromise.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/electron-compile/node_modules/rxjs/add/observable/fromPromise.js ***!
  \***************************************************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){"use strict";eval('\nvar Observable_1 = __webpack_require__(/*! ../../Observable */ "./node_modules/electron-compile/node_modules/rxjs/Observable.js");\nvar fromPromise_1 = __webpack_require__(/*! ../../observable/fromPromise */ "./node_modules/electron-compile/node_modules/rxjs/observable/fromPromise.js");\nObservable_1.Observable.fromPromise = fromPromise_1.fromPromise;\n//# sourceMappingURL=fromPromise.js.map\n\n//# sourceURL=webpack:///./node_modules/electron-compile/node_modules/rxjs/add/observable/fromPromise.js?')},"./node_modules/electron-compile/node_modules/rxjs/add/observable/range.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/electron-compile/node_modules/rxjs/add/observable/range.js ***!
  \*********************************************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){"use strict";eval('\nvar Observable_1 = __webpack_require__(/*! ../../Observable */ "./node_modules/electron-compile/node_modules/rxjs/Observable.js");\nvar range_1 = __webpack_require__(/*! ../../observable/range */ "./node_modules/electron-compile/node_modules/rxjs/observable/range.js");\nObservable_1.Observable.range = range_1.range;\n//# sourceMappingURL=range.js.map\n\n//# sourceURL=webpack:///./node_modules/electron-compile/node_modules/rxjs/add/observable/range.js?')},"./node_modules/electron-compile/node_modules/rxjs/add/observable/throw.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/electron-compile/node_modules/rxjs/add/observable/throw.js ***!
  \*********************************************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){"use strict";eval('\nvar Observable_1 = __webpack_require__(/*! ../../Observable */ "./node_modules/electron-compile/node_modules/rxjs/Observable.js");\nvar throw_1 = __webpack_require__(/*! ../../observable/throw */ "./node_modules/electron-compile/node_modules/rxjs/observable/throw.js");\nObservable_1.Observable.throw = throw_1._throw;\n//# sourceMappingURL=throw.js.map\n\n//# sourceURL=webpack:///./node_modules/electron-compile/node_modules/rxjs/add/observable/throw.js?')},"./node_modules/electron-compile/node_modules/rxjs/add/observable/timer.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/electron-compile/node_modules/rxjs/add/observable/timer.js ***!
  \*********************************************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){"use strict";eval('\nvar Observable_1 = __webpack_require__(/*! ../../Observable */ "./node_modules/electron-compile/node_modules/rxjs/Observable.js");\nvar timer_1 = __webpack_require__(/*! ../../observable/timer */ "./node_modules/electron-compile/node_modules/rxjs/observable/timer.js");\nObservable_1.Observable.timer = timer_1.timer;\n//# sourceMappingURL=timer.js.map\n\n//# sourceURL=webpack:///./node_modules/electron-compile/node_modules/rxjs/add/observable/timer.js?')},"./node_modules/electron-compile/node_modules/rxjs/add/operator/catch.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/electron-compile/node_modules/rxjs/add/operator/catch.js ***!
  \*******************************************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){"use strict";eval('\nvar Observable_1 = __webpack_require__(/*! ../../Observable */ "./node_modules/electron-compile/node_modules/rxjs/Observable.js");\nvar catch_1 = __webpack_require__(/*! ../../operator/catch */ "./node_modules/electron-compile/node_modules/rxjs/operator/catch.js");\nObservable_1.Observable.prototype.catch = catch_1._catch;\nObservable_1.Observable.prototype._catch = catch_1._catch;\n//# sourceMappingURL=catch.js.map\n\n//# sourceURL=webpack:///./node_modules/electron-compile/node_modules/rxjs/add/operator/catch.js?')},"./node_modules/electron-compile/node_modules/rxjs/add/operator/filter.js":
/*!********************************************************************************!*\
  !*** ./node_modules/electron-compile/node_modules/rxjs/add/operator/filter.js ***!
  \********************************************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){"use strict";eval('\nvar Observable_1 = __webpack_require__(/*! ../../Observable */ "./node_modules/electron-compile/node_modules/rxjs/Observable.js");\nvar filter_1 = __webpack_require__(/*! ../../operator/filter */ "./node_modules/electron-compile/node_modules/rxjs/operator/filter.js");\nObservable_1.Observable.prototype.filter = filter_1.filter;\n//# sourceMappingURL=filter.js.map\n\n//# sourceURL=webpack:///./node_modules/electron-compile/node_modules/rxjs/add/operator/filter.js?')},"./node_modules/electron-compile/node_modules/rxjs/add/operator/map.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/electron-compile/node_modules/rxjs/add/operator/map.js ***!
  \*****************************************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){"use strict";eval('\nvar Observable_1 = __webpack_require__(/*! ../../Observable */ "./node_modules/electron-compile/node_modules/rxjs/Observable.js");\nvar map_1 = __webpack_require__(/*! ../../operator/map */ "./node_modules/electron-compile/node_modules/rxjs/operator/map.js");\nObservable_1.Observable.prototype.map = map_1.map;\n//# sourceMappingURL=map.js.map\n\n//# sourceURL=webpack:///./node_modules/electron-compile/node_modules/rxjs/add/operator/map.js?')},"./node_modules/electron-compile/node_modules/rxjs/add/operator/mergeMap.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/electron-compile/node_modules/rxjs/add/operator/mergeMap.js ***!
  \**********************************************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){"use strict";eval('\nvar Observable_1 = __webpack_require__(/*! ../../Observable */ "./node_modules/electron-compile/node_modules/rxjs/Observable.js");\nvar mergeMap_1 = __webpack_require__(/*! ../../operator/mergeMap */ "./node_modules/electron-compile/node_modules/rxjs/operator/mergeMap.js");\nObservable_1.Observable.prototype.mergeMap = mergeMap_1.mergeMap;\nObservable_1.Observable.prototype.flatMap = mergeMap_1.mergeMap;\n//# sourceMappingURL=mergeMap.js.map\n\n//# sourceURL=webpack:///./node_modules/electron-compile/node_modules/rxjs/add/operator/mergeMap.js?')},"./node_modules/electron-compile/node_modules/rxjs/add/operator/publish.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/electron-compile/node_modules/rxjs/add/operator/publish.js ***!
  \*********************************************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){"use strict";eval('\nvar Observable_1 = __webpack_require__(/*! ../../Observable */ "./node_modules/electron-compile/node_modules/rxjs/Observable.js");\nvar publish_1 = __webpack_require__(/*! ../../operator/publish */ "./node_modules/electron-compile/node_modules/rxjs/operator/publish.js");\nObservable_1.Observable.prototype.publish = publish_1.publish;\n//# sourceMappingURL=publish.js.map\n\n//# sourceURL=webpack:///./node_modules/electron-compile/node_modules/rxjs/add/operator/publish.js?')},"./node_modules/electron-compile/node_modules/rxjs/add/operator/retryWhen.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/electron-compile/node_modules/rxjs/add/operator/retryWhen.js ***!
  \***********************************************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){"use strict";eval('\nvar Observable_1 = __webpack_require__(/*! ../../Observable */ "./node_modules/electron-compile/node_modules/rxjs/Observable.js");\nvar retryWhen_1 = __webpack_require__(/*! ../../operator/retryWhen */ "./node_modules/electron-compile/node_modules/rxjs/operator/retryWhen.js");\nObservable_1.Observable.prototype.retryWhen = retryWhen_1.retryWhen;\n//# sourceMappingURL=retryWhen.js.map\n\n//# sourceURL=webpack:///./node_modules/electron-compile/node_modules/rxjs/add/operator/retryWhen.js?')},"./node_modules/electron-compile/node_modules/rxjs/add/operator/switch.js":
/*!********************************************************************************!*\
  !*** ./node_modules/electron-compile/node_modules/rxjs/add/operator/switch.js ***!
  \********************************************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){"use strict";eval('\nvar Observable_1 = __webpack_require__(/*! ../../Observable */ "./node_modules/electron-compile/node_modules/rxjs/Observable.js");\nvar switch_1 = __webpack_require__(/*! ../../operator/switch */ "./node_modules/electron-compile/node_modules/rxjs/operator/switch.js");\nObservable_1.Observable.prototype.switch = switch_1._switch;\nObservable_1.Observable.prototype._switch = switch_1._switch;\n//# sourceMappingURL=switch.js.map\n\n//# sourceURL=webpack:///./node_modules/electron-compile/node_modules/rxjs/add/operator/switch.js?')},"./node_modules/electron-compile/node_modules/rxjs/add/operator/switchMap.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/electron-compile/node_modules/rxjs/add/operator/switchMap.js ***!
  \***********************************************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){"use strict";eval('\nvar Observable_1 = __webpack_require__(/*! ../../Observable */ "./node_modules/electron-compile/node_modules/rxjs/Observable.js");\nvar switchMap_1 = __webpack_require__(/*! ../../operator/switchMap */ "./node_modules/electron-compile/node_modules/rxjs/operator/switchMap.js");\nObservable_1.Observable.prototype.switchMap = switchMap_1.switchMap;\n//# sourceMappingURL=switchMap.js.map\n\n//# sourceURL=webpack:///./node_modules/electron-compile/node_modules/rxjs/add/operator/switchMap.js?')},"./node_modules/electron-compile/node_modules/rxjs/add/operator/timeout.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/electron-compile/node_modules/rxjs/add/operator/timeout.js ***!
  \*********************************************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){"use strict";eval('\nvar Observable_1 = __webpack_require__(/*! ../../Observable */ "./node_modules/electron-compile/node_modules/rxjs/Observable.js");\nvar timeout_1 = __webpack_require__(/*! ../../operator/timeout */ "./node_modules/electron-compile/node_modules/rxjs/operator/timeout.js");\nObservable_1.Observable.prototype.timeout = timeout_1.timeout;\n//# sourceMappingURL=timeout.js.map\n\n//# sourceURL=webpack:///./node_modules/electron-compile/node_modules/rxjs/add/operator/timeout.js?')},"./node_modules/electron-compile/node_modules/rxjs/add/operator/zip.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/electron-compile/node_modules/rxjs/add/operator/zip.js ***!
  \*****************************************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){"use strict";eval('\nvar Observable_1 = __webpack_require__(/*! ../../Observable */ "./node_modules/electron-compile/node_modules/rxjs/Observable.js");\nvar zip_1 = __webpack_require__(/*! ../../operator/zip */ "./node_modules/electron-compile/node_modules/rxjs/operator/zip.js");\nObservable_1.Observable.prototype.zip = zip_1.zipProto;\n//# sourceMappingURL=zip.js.map\n\n//# sourceURL=webpack:///./node_modules/electron-compile/node_modules/rxjs/add/operator/zip.js?')},"./node_modules/electron-compile/node_modules/rxjs/observable/ArrayObservable.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/electron-compile/node_modules/rxjs/observable/ArrayObservable.js ***!
  \***************************************************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){"use strict";eval('\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Observable_1 = __webpack_require__(/*! ../Observable */ "./node_modules/electron-compile/node_modules/rxjs/Observable.js");\nvar ScalarObservable_1 = __webpack_require__(/*! ./ScalarObservable */ "./node_modules/electron-compile/node_modules/rxjs/observable/ScalarObservable.js");\nvar EmptyObservable_1 = __webpack_require__(/*! ./EmptyObservable */ "./node_modules/electron-compile/node_modules/rxjs/observable/EmptyObservable.js");\nvar isScheduler_1 = __webpack_require__(/*! ../util/isScheduler */ "./node_modules/electron-compile/node_modules/rxjs/util/isScheduler.js");\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @extends {Ignored}\n * @hide true\n */\nvar ArrayObservable = (function (_super) {\n    __extends(ArrayObservable, _super);\n    function ArrayObservable(array, scheduler) {\n        _super.call(this);\n        this.array = array;\n        this.scheduler = scheduler;\n        if (!scheduler && array.length === 1) {\n            this._isScalar = true;\n            this.value = array[0];\n        }\n    }\n    ArrayObservable.create = function (array, scheduler) {\n        return new ArrayObservable(array, scheduler);\n    };\n    /**\n     * Creates an Observable that emits some values you specify as arguments,\n     * immediately one after the other, and then emits a complete notification.\n     *\n     * <span class="informal">Emits the arguments you provide, then completes.\n     * </span>\n     *\n     * <img src="./img/of.png" width="100%">\n     *\n     * This static operator is useful for creating a simple Observable that only\n     * emits the arguments given, and the complete notification thereafter. It can\n     * be used for composing with other Observables, such as with {@link concat}.\n     * By default, it uses a `null` IScheduler, which means the `next`\n     * notifications are sent synchronously, although with a different IScheduler\n     * it is possible to determine when those notifications will be delivered.\n     *\n     * @example <caption>Emit 10, 20, 30, then \'a\', \'b\', \'c\', then start ticking every second.</caption>\n     * var numbers = Rx.Observable.of(10, 20, 30);\n     * var letters = Rx.Observable.of(\'a\', \'b\', \'c\');\n     * var interval = Rx.Observable.interval(1000);\n     * var result = numbers.concat(letters).concat(interval);\n     * result.subscribe(x => console.log(x));\n     *\n     * @see {@link create}\n     * @see {@link empty}\n     * @see {@link never}\n     * @see {@link throw}\n     *\n     * @param {...T} values Arguments that represent `next` values to be emitted.\n     * @param {Scheduler} [scheduler] A {@link IScheduler} to use for scheduling\n     * the emissions of the `next` notifications.\n     * @return {Observable<T>} An Observable that emits each given input value.\n     * @static true\n     * @name of\n     * @owner Observable\n     */\n    ArrayObservable.of = function () {\n        var array = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            array[_i - 0] = arguments[_i];\n        }\n        var scheduler = array[array.length - 1];\n        if (isScheduler_1.isScheduler(scheduler)) {\n            array.pop();\n        }\n        else {\n            scheduler = null;\n        }\n        var len = array.length;\n        if (len > 1) {\n            return new ArrayObservable(array, scheduler);\n        }\n        else if (len === 1) {\n            return new ScalarObservable_1.ScalarObservable(array[0], scheduler);\n        }\n        else {\n            return new EmptyObservable_1.EmptyObservable(scheduler);\n        }\n    };\n    ArrayObservable.dispatch = function (state) {\n        var array = state.array, index = state.index, count = state.count, subscriber = state.subscriber;\n        if (index >= count) {\n            subscriber.complete();\n            return;\n        }\n        subscriber.next(array[index]);\n        if (subscriber.closed) {\n            return;\n        }\n        state.index = index + 1;\n        this.schedule(state);\n    };\n    /** @deprecated internal use only */ ArrayObservable.prototype._subscribe = function (subscriber) {\n        var index = 0;\n        var array = this.array;\n        var count = array.length;\n        var scheduler = this.scheduler;\n        if (scheduler) {\n            return scheduler.schedule(ArrayObservable.dispatch, 0, {\n                array: array, index: index, count: count, subscriber: subscriber\n            });\n        }\n        else {\n            for (var i = 0; i < count && !subscriber.closed; i++) {\n                subscriber.next(array[i]);\n            }\n            subscriber.complete();\n        }\n    };\n    return ArrayObservable;\n}(Observable_1.Observable));\nexports.ArrayObservable = ArrayObservable;\n//# sourceMappingURL=ArrayObservable.js.map\n\n//# sourceURL=webpack:///./node_modules/electron-compile/node_modules/rxjs/observable/ArrayObservable.js?')},"./node_modules/electron-compile/node_modules/rxjs/observable/ConnectableObservable.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/electron-compile/node_modules/rxjs/observable/ConnectableObservable.js ***!
  \*********************************************************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){"use strict";eval('\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subject_1 = __webpack_require__(/*! ../Subject */ "./node_modules/electron-compile/node_modules/rxjs/Subject.js");\nvar Observable_1 = __webpack_require__(/*! ../Observable */ "./node_modules/electron-compile/node_modules/rxjs/Observable.js");\nvar Subscriber_1 = __webpack_require__(/*! ../Subscriber */ "./node_modules/electron-compile/node_modules/rxjs/Subscriber.js");\nvar Subscription_1 = __webpack_require__(/*! ../Subscription */ "./node_modules/electron-compile/node_modules/rxjs/Subscription.js");\nvar refCount_1 = __webpack_require__(/*! ../operators/refCount */ "./node_modules/electron-compile/node_modules/rxjs/operators/refCount.js");\n/**\n * @class ConnectableObservable<T>\n */\nvar ConnectableObservable = (function (_super) {\n    __extends(ConnectableObservable, _super);\n    function ConnectableObservable(/** @deprecated internal use only */ source, \n        /** @deprecated internal use only */ subjectFactory) {\n        _super.call(this);\n        this.source = source;\n        this.subjectFactory = subjectFactory;\n        /** @deprecated internal use only */ this._refCount = 0;\n        this._isComplete = false;\n    }\n    /** @deprecated internal use only */ ConnectableObservable.prototype._subscribe = function (subscriber) {\n        return this.getSubject().subscribe(subscriber);\n    };\n    /** @deprecated internal use only */ ConnectableObservable.prototype.getSubject = function () {\n        var subject = this._subject;\n        if (!subject || subject.isStopped) {\n            this._subject = this.subjectFactory();\n        }\n        return this._subject;\n    };\n    ConnectableObservable.prototype.connect = function () {\n        var connection = this._connection;\n        if (!connection) {\n            this._isComplete = false;\n            connection = this._connection = new Subscription_1.Subscription();\n            connection.add(this.source\n                .subscribe(new ConnectableSubscriber(this.getSubject(), this)));\n            if (connection.closed) {\n                this._connection = null;\n                connection = Subscription_1.Subscription.EMPTY;\n            }\n            else {\n                this._connection = connection;\n            }\n        }\n        return connection;\n    };\n    ConnectableObservable.prototype.refCount = function () {\n        return refCount_1.refCount()(this);\n    };\n    return ConnectableObservable;\n}(Observable_1.Observable));\nexports.ConnectableObservable = ConnectableObservable;\nvar connectableProto = ConnectableObservable.prototype;\nexports.connectableObservableDescriptor = {\n    operator: { value: null },\n    _refCount: { value: 0, writable: true },\n    _subject: { value: null, writable: true },\n    _connection: { value: null, writable: true },\n    _subscribe: { value: connectableProto._subscribe },\n    _isComplete: { value: connectableProto._isComplete, writable: true },\n    getSubject: { value: connectableProto.getSubject },\n    connect: { value: connectableProto.connect },\n    refCount: { value: connectableProto.refCount }\n};\nvar ConnectableSubscriber = (function (_super) {\n    __extends(ConnectableSubscriber, _super);\n    function ConnectableSubscriber(destination, connectable) {\n        _super.call(this, destination);\n        this.connectable = connectable;\n    }\n    ConnectableSubscriber.prototype._error = function (err) {\n        this._unsubscribe();\n        _super.prototype._error.call(this, err);\n    };\n    ConnectableSubscriber.prototype._complete = function () {\n        this.connectable._isComplete = true;\n        this._unsubscribe();\n        _super.prototype._complete.call(this);\n    };\n    /** @deprecated internal use only */ ConnectableSubscriber.prototype._unsubscribe = function () {\n        var connectable = this.connectable;\n        if (connectable) {\n            this.connectable = null;\n            var connection = connectable._connection;\n            connectable._refCount = 0;\n            connectable._subject = null;\n            connectable._connection = null;\n            if (connection) {\n                connection.unsubscribe();\n            }\n        }\n    };\n    return ConnectableSubscriber;\n}(Subject_1.SubjectSubscriber));\nvar RefCountOperator = (function () {\n    function RefCountOperator(connectable) {\n        this.connectable = connectable;\n    }\n    RefCountOperator.prototype.call = function (subscriber, source) {\n        var connectable = this.connectable;\n        connectable._refCount++;\n        var refCounter = new RefCountSubscriber(subscriber, connectable);\n        var subscription = source.subscribe(refCounter);\n        if (!refCounter.closed) {\n            refCounter.connection = connectable.connect();\n        }\n        return subscription;\n    };\n    return RefCountOperator;\n}());\nvar RefCountSubscriber = (function (_super) {\n    __extends(RefCountSubscriber, _super);\n    function RefCountSubscriber(destination, connectable) {\n        _super.call(this, destination);\n        this.connectable = connectable;\n    }\n    /** @deprecated internal use only */ RefCountSubscriber.prototype._unsubscribe = function () {\n        var connectable = this.connectable;\n        if (!connectable) {\n            this.connection = null;\n            return;\n        }\n        this.connectable = null;\n        var refCount = connectable._refCount;\n        if (refCount <= 0) {\n            this.connection = null;\n            return;\n        }\n        connectable._refCount = refCount - 1;\n        if (refCount > 1) {\n            this.connection = null;\n            return;\n        }\n        ///\n        // Compare the local RefCountSubscriber\'s connection Subscription to the\n        // connection Subscription on the shared ConnectableObservable. In cases\n        // where the ConnectableObservable source synchronously emits values, and\n        // the RefCountSubscriber\'s downstream Observers synchronously unsubscribe,\n        // execution continues to here before the RefCountOperator has a chance to\n        // supply the RefCountSubscriber with the shared connection Subscription.\n        // For example:\n        // ```\n        // Observable.range(0, 10)\n        //   .publish()\n        //   .refCount()\n        //   .take(5)\n        //   .subscribe();\n        // ```\n        // In order to account for this case, RefCountSubscriber should only dispose\n        // the ConnectableObservable\'s shared connection Subscription if the\n        // connection Subscription exists, *and* either:\n        //   a. RefCountSubscriber doesn\'t have a reference to the shared connection\n        //      Subscription yet, or,\n        //   b. RefCountSubscriber\'s connection Subscription reference is identical\n        //      to the shared connection Subscription\n        ///\n        var connection = this.connection;\n        var sharedConnection = connectable._connection;\n        this.connection = null;\n        if (sharedConnection && (!connection || sharedConnection === connection)) {\n            sharedConnection.unsubscribe();\n        }\n    };\n    return RefCountSubscriber;\n}(Subscriber_1.Subscriber));\n//# sourceMappingURL=ConnectableObservable.js.map\n\n//# sourceURL=webpack:///./node_modules/electron-compile/node_modules/rxjs/observable/ConnectableObservable.js?')},"./node_modules/electron-compile/node_modules/rxjs/observable/DeferObservable.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/electron-compile/node_modules/rxjs/observable/DeferObservable.js ***!
  \***************************************************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){"use strict";eval('\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Observable_1 = __webpack_require__(/*! ../Observable */ "./node_modules/electron-compile/node_modules/rxjs/Observable.js");\nvar subscribeToResult_1 = __webpack_require__(/*! ../util/subscribeToResult */ "./node_modules/electron-compile/node_modules/rxjs/util/subscribeToResult.js");\nvar OuterSubscriber_1 = __webpack_require__(/*! ../OuterSubscriber */ "./node_modules/electron-compile/node_modules/rxjs/OuterSubscriber.js");\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @extends {Ignored}\n * @hide true\n */\nvar DeferObservable = (function (_super) {\n    __extends(DeferObservable, _super);\n    function DeferObservable(observableFactory) {\n        _super.call(this);\n        this.observableFactory = observableFactory;\n    }\n    /**\n     * Creates an Observable that, on subscribe, calls an Observable factory to\n     * make an Observable for each new Observer.\n     *\n     * <span class="informal">Creates the Observable lazily, that is, only when it\n     * is subscribed.\n     * </span>\n     *\n     * <img src="./img/defer.png" width="100%">\n     *\n     * `defer` allows you to create the Observable only when the Observer\n     * subscribes, and create a fresh Observable for each Observer. It waits until\n     * an Observer subscribes to it, and then it generates an Observable,\n     * typically with an Observable factory function. It does this afresh for each\n     * subscriber, so although each subscriber may think it is subscribing to the\n     * same Observable, in fact each subscriber gets its own individual\n     * Observable.\n     *\n     * @example <caption>Subscribe to either an Observable of clicks or an Observable of interval, at random</caption>\n     * var clicksOrInterval = Rx.Observable.defer(function () {\n     *   if (Math.random() > 0.5) {\n     *     return Rx.Observable.fromEvent(document, \'click\');\n     *   } else {\n     *     return Rx.Observable.interval(1000);\n     *   }\n     * });\n     * clicksOrInterval.subscribe(x => console.log(x));\n     *\n     * // Results in the following behavior:\n     * // If the result of Math.random() is greater than 0.5 it will listen\n     * // for clicks anywhere on the "document"; when document is clicked it\n     * // will log a MouseEvent object to the console. If the result is less\n     * // than 0.5 it will emit ascending numbers, one every second(1000ms).\n     *\n     * @see {@link create}\n     *\n     * @param {function(): SubscribableOrPromise} observableFactory The Observable\n     * factory function to invoke for each Observer that subscribes to the output\n     * Observable. May also return a Promise, which will be converted on the fly\n     * to an Observable.\n     * @return {Observable} An Observable whose Observers\' subscriptions trigger\n     * an invocation of the given Observable factory function.\n     * @static true\n     * @name defer\n     * @owner Observable\n     */\n    DeferObservable.create = function (observableFactory) {\n        return new DeferObservable(observableFactory);\n    };\n    /** @deprecated internal use only */ DeferObservable.prototype._subscribe = function (subscriber) {\n        return new DeferSubscriber(subscriber, this.observableFactory);\n    };\n    return DeferObservable;\n}(Observable_1.Observable));\nexports.DeferObservable = DeferObservable;\nvar DeferSubscriber = (function (_super) {\n    __extends(DeferSubscriber, _super);\n    function DeferSubscriber(destination, factory) {\n        _super.call(this, destination);\n        this.factory = factory;\n        this.tryDefer();\n    }\n    DeferSubscriber.prototype.tryDefer = function () {\n        try {\n            this._callFactory();\n        }\n        catch (err) {\n            this._error(err);\n        }\n    };\n    DeferSubscriber.prototype._callFactory = function () {\n        var result = this.factory();\n        if (result) {\n            this.add(subscribeToResult_1.subscribeToResult(this, result));\n        }\n    };\n    return DeferSubscriber;\n}(OuterSubscriber_1.OuterSubscriber));\n//# sourceMappingURL=DeferObservable.js.map\n\n//# sourceURL=webpack:///./node_modules/electron-compile/node_modules/rxjs/observable/DeferObservable.js?')},"./node_modules/electron-compile/node_modules/rxjs/observable/EmptyObservable.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/electron-compile/node_modules/rxjs/observable/EmptyObservable.js ***!
  \***************************************************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){"use strict";eval("\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Observable_1 = __webpack_require__(/*! ../Observable */ \"./node_modules/electron-compile/node_modules/rxjs/Observable.js\");\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @extends {Ignored}\n * @hide true\n */\nvar EmptyObservable = (function (_super) {\n    __extends(EmptyObservable, _super);\n    function EmptyObservable(scheduler) {\n        _super.call(this);\n        this.scheduler = scheduler;\n    }\n    /**\n     * Creates an Observable that emits no items to the Observer and immediately\n     * emits a complete notification.\n     *\n     * <span class=\"informal\">Just emits 'complete', and nothing else.\n     * </span>\n     *\n     * <img src=\"./img/empty.png\" width=\"100%\">\n     *\n     * This static operator is useful for creating a simple Observable that only\n     * emits the complete notification. It can be used for composing with other\n     * Observables, such as in a {@link mergeMap}.\n     *\n     * @example <caption>Emit the number 7, then complete.</caption>\n     * var result = Rx.Observable.empty().startWith(7);\n     * result.subscribe(x => console.log(x));\n     *\n     * @example <caption>Map and flatten only odd numbers to the sequence 'a', 'b', 'c'</caption>\n     * var interval = Rx.Observable.interval(1000);\n     * var result = interval.mergeMap(x =>\n     *   x % 2 === 1 ? Rx.Observable.of('a', 'b', 'c') : Rx.Observable.empty()\n     * );\n     * result.subscribe(x => console.log(x));\n     *\n     * // Results in the following to the console:\n     * // x is equal to the count on the interval eg(0,1,2,3,...)\n     * // x will occur every 1000ms\n     * // if x % 2 is equal to 1 print abc\n     * // if x % 2 is not equal to 1 nothing will be output\n     *\n     * @see {@link create}\n     * @see {@link never}\n     * @see {@link of}\n     * @see {@link throw}\n     *\n     * @param {Scheduler} [scheduler] A {@link IScheduler} to use for scheduling\n     * the emission of the complete notification.\n     * @return {Observable} An \"empty\" Observable: emits only the complete\n     * notification.\n     * @static true\n     * @name empty\n     * @owner Observable\n     */\n    EmptyObservable.create = function (scheduler) {\n        return new EmptyObservable(scheduler);\n    };\n    EmptyObservable.dispatch = function (arg) {\n        var subscriber = arg.subscriber;\n        subscriber.complete();\n    };\n    /** @deprecated internal use only */ EmptyObservable.prototype._subscribe = function (subscriber) {\n        var scheduler = this.scheduler;\n        if (scheduler) {\n            return scheduler.schedule(EmptyObservable.dispatch, 0, { subscriber: subscriber });\n        }\n        else {\n            subscriber.complete();\n        }\n    };\n    return EmptyObservable;\n}(Observable_1.Observable));\nexports.EmptyObservable = EmptyObservable;\n//# sourceMappingURL=EmptyObservable.js.map\n\n//# sourceURL=webpack:///./node_modules/electron-compile/node_modules/rxjs/observable/EmptyObservable.js?")},"./node_modules/electron-compile/node_modules/rxjs/observable/ErrorObservable.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/electron-compile/node_modules/rxjs/observable/ErrorObservable.js ***!
  \***************************************************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){"use strict";eval("\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Observable_1 = __webpack_require__(/*! ../Observable */ \"./node_modules/electron-compile/node_modules/rxjs/Observable.js\");\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @extends {Ignored}\n * @hide true\n */\nvar ErrorObservable = (function (_super) {\n    __extends(ErrorObservable, _super);\n    function ErrorObservable(error, scheduler) {\n        _super.call(this);\n        this.error = error;\n        this.scheduler = scheduler;\n    }\n    /**\n     * Creates an Observable that emits no items to the Observer and immediately\n     * emits an error notification.\n     *\n     * <span class=\"informal\">Just emits 'error', and nothing else.\n     * </span>\n     *\n     * <img src=\"./img/throw.png\" width=\"100%\">\n     *\n     * This static operator is useful for creating a simple Observable that only\n     * emits the error notification. It can be used for composing with other\n     * Observables, such as in a {@link mergeMap}.\n     *\n     * @example <caption>Emit the number 7, then emit an error.</caption>\n     * var result = Rx.Observable.throw(new Error('oops!')).startWith(7);\n     * result.subscribe(x => console.log(x), e => console.error(e));\n     *\n     * @example <caption>Map and flatten numbers to the sequence 'a', 'b', 'c', but throw an error for 13</caption>\n     * var interval = Rx.Observable.interval(1000);\n     * var result = interval.mergeMap(x =>\n     *   x === 13 ?\n     *     Rx.Observable.throw('Thirteens are bad') :\n     *     Rx.Observable.of('a', 'b', 'c')\n     * );\n     * result.subscribe(x => console.log(x), e => console.error(e));\n     *\n     * @see {@link create}\n     * @see {@link empty}\n     * @see {@link never}\n     * @see {@link of}\n     *\n     * @param {any} error The particular Error to pass to the error notification.\n     * @param {Scheduler} [scheduler] A {@link IScheduler} to use for scheduling\n     * the emission of the error notification.\n     * @return {Observable} An error Observable: emits only the error notification\n     * using the given error argument.\n     * @static true\n     * @name throw\n     * @owner Observable\n     */\n    ErrorObservable.create = function (error, scheduler) {\n        return new ErrorObservable(error, scheduler);\n    };\n    ErrorObservable.dispatch = function (arg) {\n        var error = arg.error, subscriber = arg.subscriber;\n        subscriber.error(error);\n    };\n    /** @deprecated internal use only */ ErrorObservable.prototype._subscribe = function (subscriber) {\n        var error = this.error;\n        var scheduler = this.scheduler;\n        subscriber.syncErrorThrowable = true;\n        if (scheduler) {\n            return scheduler.schedule(ErrorObservable.dispatch, 0, {\n                error: error, subscriber: subscriber\n            });\n        }\n        else {\n            subscriber.error(error);\n        }\n    };\n    return ErrorObservable;\n}(Observable_1.Observable));\nexports.ErrorObservable = ErrorObservable;\n//# sourceMappingURL=ErrorObservable.js.map\n\n//# sourceURL=webpack:///./node_modules/electron-compile/node_modules/rxjs/observable/ErrorObservable.js?")},"./node_modules/electron-compile/node_modules/rxjs/observable/PromiseObservable.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/electron-compile/node_modules/rxjs/observable/PromiseObservable.js ***!
  \*****************************************************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){"use strict";eval('\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar root_1 = __webpack_require__(/*! ../util/root */ "./node_modules/electron-compile/node_modules/rxjs/util/root.js");\nvar Observable_1 = __webpack_require__(/*! ../Observable */ "./node_modules/electron-compile/node_modules/rxjs/Observable.js");\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @extends {Ignored}\n * @hide true\n */\nvar PromiseObservable = (function (_super) {\n    __extends(PromiseObservable, _super);\n    function PromiseObservable(promise, scheduler) {\n        _super.call(this);\n        this.promise = promise;\n        this.scheduler = scheduler;\n    }\n    /**\n     * Converts a Promise to an Observable.\n     *\n     * <span class="informal">Returns an Observable that just emits the Promise\'s\n     * resolved value, then completes.</span>\n     *\n     * Converts an ES2015 Promise or a Promises/A+ spec compliant Promise to an\n     * Observable. If the Promise resolves with a value, the output Observable\n     * emits that resolved value as a `next`, and then completes. If the Promise\n     * is rejected, then the output Observable emits the corresponding Error.\n     *\n     * @example <caption>Convert the Promise returned by Fetch to an Observable</caption>\n     * var result = Rx.Observable.fromPromise(fetch(\'http://myserver.com/\'));\n     * result.subscribe(x => console.log(x), e => console.error(e));\n     *\n     * @see {@link bindCallback}\n     * @see {@link from}\n     *\n     * @param {PromiseLike<T>} promise The promise to be converted.\n     * @param {Scheduler} [scheduler] An optional IScheduler to use for scheduling\n     * the delivery of the resolved value (or the rejection).\n     * @return {Observable<T>} An Observable which wraps the Promise.\n     * @static true\n     * @name fromPromise\n     * @owner Observable\n     */\n    PromiseObservable.create = function (promise, scheduler) {\n        return new PromiseObservable(promise, scheduler);\n    };\n    /** @deprecated internal use only */ PromiseObservable.prototype._subscribe = function (subscriber) {\n        var _this = this;\n        var promise = this.promise;\n        var scheduler = this.scheduler;\n        if (scheduler == null) {\n            if (this._isScalar) {\n                if (!subscriber.closed) {\n                    subscriber.next(this.value);\n                    subscriber.complete();\n                }\n            }\n            else {\n                promise.then(function (value) {\n                    _this.value = value;\n                    _this._isScalar = true;\n                    if (!subscriber.closed) {\n                        subscriber.next(value);\n                        subscriber.complete();\n                    }\n                }, function (err) {\n                    if (!subscriber.closed) {\n                        subscriber.error(err);\n                    }\n                })\n                    .then(null, function (err) {\n                    // escape the promise trap, throw unhandled errors\n                    root_1.root.setTimeout(function () { throw err; });\n                });\n            }\n        }\n        else {\n            if (this._isScalar) {\n                if (!subscriber.closed) {\n                    return scheduler.schedule(dispatchNext, 0, { value: this.value, subscriber: subscriber });\n                }\n            }\n            else {\n                promise.then(function (value) {\n                    _this.value = value;\n                    _this._isScalar = true;\n                    if (!subscriber.closed) {\n                        subscriber.add(scheduler.schedule(dispatchNext, 0, { value: value, subscriber: subscriber }));\n                    }\n                }, function (err) {\n                    if (!subscriber.closed) {\n                        subscriber.add(scheduler.schedule(dispatchError, 0, { err: err, subscriber: subscriber }));\n                    }\n                })\n                    .then(null, function (err) {\n                    // escape the promise trap, throw unhandled errors\n                    root_1.root.setTimeout(function () { throw err; });\n                });\n            }\n        }\n    };\n    return PromiseObservable;\n}(Observable_1.Observable));\nexports.PromiseObservable = PromiseObservable;\nfunction dispatchNext(arg) {\n    var value = arg.value, subscriber = arg.subscriber;\n    if (!subscriber.closed) {\n        subscriber.next(value);\n        subscriber.complete();\n    }\n}\nfunction dispatchError(arg) {\n    var err = arg.err, subscriber = arg.subscriber;\n    if (!subscriber.closed) {\n        subscriber.error(err);\n    }\n}\n//# sourceMappingURL=PromiseObservable.js.map\n\n//# sourceURL=webpack:///./node_modules/electron-compile/node_modules/rxjs/observable/PromiseObservable.js?')},"./node_modules/electron-compile/node_modules/rxjs/observable/RangeObservable.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/electron-compile/node_modules/rxjs/observable/RangeObservable.js ***!
  \***************************************************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){"use strict";eval('\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Observable_1 = __webpack_require__(/*! ../Observable */ "./node_modules/electron-compile/node_modules/rxjs/Observable.js");\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @extends {Ignored}\n * @hide true\n */\nvar RangeObservable = (function (_super) {\n    __extends(RangeObservable, _super);\n    function RangeObservable(start, count, scheduler) {\n        _super.call(this);\n        this.start = start;\n        this._count = count;\n        this.scheduler = scheduler;\n    }\n    /**\n     * Creates an Observable that emits a sequence of numbers within a specified\n     * range.\n     *\n     * <span class="informal">Emits a sequence of numbers in a range.</span>\n     *\n     * <img src="./img/range.png" width="100%">\n     *\n     * `range` operator emits a range of sequential integers, in order, where you\n     * select the `start` of the range and its `length`. By default, uses no\n     * IScheduler and just delivers the notifications synchronously, but may use\n     * an optional IScheduler to regulate those deliveries.\n     *\n     * @example <caption>Emits the numbers 1 to 10</caption>\n     * var numbers = Rx.Observable.range(1, 10);\n     * numbers.subscribe(x => console.log(x));\n     *\n     * @see {@link timer}\n     * @see {@link interval}\n     *\n     * @param {number} [start=0] The value of the first integer in the sequence.\n     * @param {number} [count=0] The number of sequential integers to generate.\n     * @param {Scheduler} [scheduler] A {@link IScheduler} to use for scheduling\n     * the emissions of the notifications.\n     * @return {Observable} An Observable of numbers that emits a finite range of\n     * sequential integers.\n     * @static true\n     * @name range\n     * @owner Observable\n     */\n    RangeObservable.create = function (start, count, scheduler) {\n        if (start === void 0) { start = 0; }\n        if (count === void 0) { count = 0; }\n        return new RangeObservable(start, count, scheduler);\n    };\n    RangeObservable.dispatch = function (state) {\n        var start = state.start, index = state.index, count = state.count, subscriber = state.subscriber;\n        if (index >= count) {\n            subscriber.complete();\n            return;\n        }\n        subscriber.next(start);\n        if (subscriber.closed) {\n            return;\n        }\n        state.index = index + 1;\n        state.start = start + 1;\n        this.schedule(state);\n    };\n    /** @deprecated internal use only */ RangeObservable.prototype._subscribe = function (subscriber) {\n        var index = 0;\n        var start = this.start;\n        var count = this._count;\n        var scheduler = this.scheduler;\n        if (scheduler) {\n            return scheduler.schedule(RangeObservable.dispatch, 0, {\n                index: index, count: count, start: start, subscriber: subscriber\n            });\n        }\n        else {\n            do {\n                if (index++ >= count) {\n                    subscriber.complete();\n                    break;\n                }\n                subscriber.next(start++);\n                if (subscriber.closed) {\n                    break;\n                }\n            } while (true);\n        }\n    };\n    return RangeObservable;\n}(Observable_1.Observable));\nexports.RangeObservable = RangeObservable;\n//# sourceMappingURL=RangeObservable.js.map\n\n//# sourceURL=webpack:///./node_modules/electron-compile/node_modules/rxjs/observable/RangeObservable.js?')},"./node_modules/electron-compile/node_modules/rxjs/observable/ScalarObservable.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/electron-compile/node_modules/rxjs/observable/ScalarObservable.js ***!
  \****************************************************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){"use strict";eval('\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Observable_1 = __webpack_require__(/*! ../Observable */ "./node_modules/electron-compile/node_modules/rxjs/Observable.js");\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @extends {Ignored}\n * @hide true\n */\nvar ScalarObservable = (function (_super) {\n    __extends(ScalarObservable, _super);\n    function ScalarObservable(value, scheduler) {\n        _super.call(this);\n        this.value = value;\n        this.scheduler = scheduler;\n        this._isScalar = true;\n        if (scheduler) {\n            this._isScalar = false;\n        }\n    }\n    ScalarObservable.create = function (value, scheduler) {\n        return new ScalarObservable(value, scheduler);\n    };\n    ScalarObservable.dispatch = function (state) {\n        var done = state.done, value = state.value, subscriber = state.subscriber;\n        if (done) {\n            subscriber.complete();\n            return;\n        }\n        subscriber.next(value);\n        if (subscriber.closed) {\n            return;\n        }\n        state.done = true;\n        this.schedule(state);\n    };\n    /** @deprecated internal use only */ ScalarObservable.prototype._subscribe = function (subscriber) {\n        var value = this.value;\n        var scheduler = this.scheduler;\n        if (scheduler) {\n            return scheduler.schedule(ScalarObservable.dispatch, 0, {\n                done: false, value: value, subscriber: subscriber\n            });\n        }\n        else {\n            subscriber.next(value);\n            if (!subscriber.closed) {\n                subscriber.complete();\n            }\n        }\n    };\n    return ScalarObservable;\n}(Observable_1.Observable));\nexports.ScalarObservable = ScalarObservable;\n//# sourceMappingURL=ScalarObservable.js.map\n\n//# sourceURL=webpack:///./node_modules/electron-compile/node_modules/rxjs/observable/ScalarObservable.js?')},"./node_modules/electron-compile/node_modules/rxjs/observable/TimerObservable.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/electron-compile/node_modules/rxjs/observable/TimerObservable.js ***!
  \***************************************************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){"use strict";eval('\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar isNumeric_1 = __webpack_require__(/*! ../util/isNumeric */ "./node_modules/electron-compile/node_modules/rxjs/util/isNumeric.js");\nvar Observable_1 = __webpack_require__(/*! ../Observable */ "./node_modules/electron-compile/node_modules/rxjs/Observable.js");\nvar async_1 = __webpack_require__(/*! ../scheduler/async */ "./node_modules/electron-compile/node_modules/rxjs/scheduler/async.js");\nvar isScheduler_1 = __webpack_require__(/*! ../util/isScheduler */ "./node_modules/electron-compile/node_modules/rxjs/util/isScheduler.js");\nvar isDate_1 = __webpack_require__(/*! ../util/isDate */ "./node_modules/electron-compile/node_modules/rxjs/util/isDate.js");\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @extends {Ignored}\n * @hide true\n */\nvar TimerObservable = (function (_super) {\n    __extends(TimerObservable, _super);\n    function TimerObservable(dueTime, period, scheduler) {\n        if (dueTime === void 0) { dueTime = 0; }\n        _super.call(this);\n        this.period = -1;\n        this.dueTime = 0;\n        if (isNumeric_1.isNumeric(period)) {\n            this.period = Number(period) < 1 && 1 || Number(period);\n        }\n        else if (isScheduler_1.isScheduler(period)) {\n            scheduler = period;\n        }\n        if (!isScheduler_1.isScheduler(scheduler)) {\n            scheduler = async_1.async;\n        }\n        this.scheduler = scheduler;\n        this.dueTime = isDate_1.isDate(dueTime) ?\n            (+dueTime - this.scheduler.now()) :\n            dueTime;\n    }\n    /**\n     * Creates an Observable that starts emitting after an `initialDelay` and\n     * emits ever increasing numbers after each `period` of time thereafter.\n     *\n     * <span class="informal">Its like {@link interval}, but you can specify when\n     * should the emissions start.</span>\n     *\n     * <img src="./img/timer.png" width="100%">\n     *\n     * `timer` returns an Observable that emits an infinite sequence of ascending\n     * integers, with a constant interval of time, `period` of your choosing\n     * between those emissions. The first emission happens after the specified\n     * `initialDelay`. The initial delay may be a {@link Date}. By default, this\n     * operator uses the `async` IScheduler to provide a notion of time, but you\n     * may pass any IScheduler to it. If `period` is not specified, the output\n     * Observable emits only one value, `0`. Otherwise, it emits an infinite\n     * sequence.\n     *\n     * @example <caption>Emits ascending numbers, one every second (1000ms), starting after 3 seconds</caption>\n     * var numbers = Rx.Observable.timer(3000, 1000);\n     * numbers.subscribe(x => console.log(x));\n     *\n     * @example <caption>Emits one number after five seconds</caption>\n     * var numbers = Rx.Observable.timer(5000);\n     * numbers.subscribe(x => console.log(x));\n     *\n     * @see {@link interval}\n     * @see {@link delay}\n     *\n     * @param {number|Date} initialDelay The initial delay time to wait before\n     * emitting the first value of `0`.\n     * @param {number} [period] The period of time between emissions of the\n     * subsequent numbers.\n     * @param {Scheduler} [scheduler=async] The IScheduler to use for scheduling\n     * the emission of values, and providing a notion of "time".\n     * @return {Observable} An Observable that emits a `0` after the\n     * `initialDelay` and ever increasing numbers after each `period` of time\n     * thereafter.\n     * @static true\n     * @name timer\n     * @owner Observable\n     */\n    TimerObservable.create = function (initialDelay, period, scheduler) {\n        if (initialDelay === void 0) { initialDelay = 0; }\n        return new TimerObservable(initialDelay, period, scheduler);\n    };\n    TimerObservable.dispatch = function (state) {\n        var index = state.index, period = state.period, subscriber = state.subscriber;\n        var action = this;\n        subscriber.next(index);\n        if (subscriber.closed) {\n            return;\n        }\n        else if (period === -1) {\n            return subscriber.complete();\n        }\n        state.index = index + 1;\n        action.schedule(state, period);\n    };\n    /** @deprecated internal use only */ TimerObservable.prototype._subscribe = function (subscriber) {\n        var index = 0;\n        var _a = this, period = _a.period, dueTime = _a.dueTime, scheduler = _a.scheduler;\n        return scheduler.schedule(TimerObservable.dispatch, dueTime, {\n            index: index, period: period, subscriber: subscriber\n        });\n    };\n    return TimerObservable;\n}(Observable_1.Observable));\nexports.TimerObservable = TimerObservable;\n//# sourceMappingURL=TimerObservable.js.map\n\n//# sourceURL=webpack:///./node_modules/electron-compile/node_modules/rxjs/observable/TimerObservable.js?')},"./node_modules/electron-compile/node_modules/rxjs/observable/defer.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/electron-compile/node_modules/rxjs/observable/defer.js ***!
  \*****************************************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){"use strict";eval('\nvar DeferObservable_1 = __webpack_require__(/*! ./DeferObservable */ "./node_modules/electron-compile/node_modules/rxjs/observable/DeferObservable.js");\nexports.defer = DeferObservable_1.DeferObservable.create;\n//# sourceMappingURL=defer.js.map\n\n//# sourceURL=webpack:///./node_modules/electron-compile/node_modules/rxjs/observable/defer.js?')},"./node_modules/electron-compile/node_modules/rxjs/observable/empty.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/electron-compile/node_modules/rxjs/observable/empty.js ***!
  \*****************************************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){"use strict";eval('\nvar EmptyObservable_1 = __webpack_require__(/*! ./EmptyObservable */ "./node_modules/electron-compile/node_modules/rxjs/observable/EmptyObservable.js");\nexports.empty = EmptyObservable_1.EmptyObservable.create;\n//# sourceMappingURL=empty.js.map\n\n//# sourceURL=webpack:///./node_modules/electron-compile/node_modules/rxjs/observable/empty.js?')},"./node_modules/electron-compile/node_modules/rxjs/observable/fromPromise.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/electron-compile/node_modules/rxjs/observable/fromPromise.js ***!
  \***********************************************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){"use strict";eval('\nvar PromiseObservable_1 = __webpack_require__(/*! ./PromiseObservable */ "./node_modules/electron-compile/node_modules/rxjs/observable/PromiseObservable.js");\nexports.fromPromise = PromiseObservable_1.PromiseObservable.create;\n//# sourceMappingURL=fromPromise.js.map\n\n//# sourceURL=webpack:///./node_modules/electron-compile/node_modules/rxjs/observable/fromPromise.js?')},"./node_modules/electron-compile/node_modules/rxjs/observable/range.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/electron-compile/node_modules/rxjs/observable/range.js ***!
  \*****************************************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){"use strict";eval('\nvar RangeObservable_1 = __webpack_require__(/*! ./RangeObservable */ "./node_modules/electron-compile/node_modules/rxjs/observable/RangeObservable.js");\nexports.range = RangeObservable_1.RangeObservable.create;\n//# sourceMappingURL=range.js.map\n\n//# sourceURL=webpack:///./node_modules/electron-compile/node_modules/rxjs/observable/range.js?')},"./node_modules/electron-compile/node_modules/rxjs/observable/throw.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/electron-compile/node_modules/rxjs/observable/throw.js ***!
  \*****************************************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){"use strict";eval('\nvar ErrorObservable_1 = __webpack_require__(/*! ./ErrorObservable */ "./node_modules/electron-compile/node_modules/rxjs/observable/ErrorObservable.js");\nexports._throw = ErrorObservable_1.ErrorObservable.create;\n//# sourceMappingURL=throw.js.map\n\n//# sourceURL=webpack:///./node_modules/electron-compile/node_modules/rxjs/observable/throw.js?')},"./node_modules/electron-compile/node_modules/rxjs/observable/timer.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/electron-compile/node_modules/rxjs/observable/timer.js ***!
  \*****************************************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){"use strict";eval('\nvar TimerObservable_1 = __webpack_require__(/*! ./TimerObservable */ "./node_modules/electron-compile/node_modules/rxjs/observable/TimerObservable.js");\nexports.timer = TimerObservable_1.TimerObservable.create;\n//# sourceMappingURL=timer.js.map\n\n//# sourceURL=webpack:///./node_modules/electron-compile/node_modules/rxjs/observable/timer.js?')},"./node_modules/electron-compile/node_modules/rxjs/operator/catch.js":
/*!***************************************************************************!*\
  !*** ./node_modules/electron-compile/node_modules/rxjs/operator/catch.js ***!
  \***************************************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){"use strict";eval("\nvar catchError_1 = __webpack_require__(/*! ../operators/catchError */ \"./node_modules/electron-compile/node_modules/rxjs/operators/catchError.js\");\n/**\n * Catches errors on the observable to be handled by returning a new observable or throwing an error.\n *\n * <img src=\"./img/catch.png\" width=\"100%\">\n *\n * @example <caption>Continues with a different Observable when there's an error</caption>\n *\n * Observable.of(1, 2, 3, 4, 5)\n *   .map(n => {\n * \t   if (n == 4) {\n * \t     throw 'four!';\n *     }\n *\t   return n;\n *   })\n *   .catch(err => Observable.of('I', 'II', 'III', 'IV', 'V'))\n *   .subscribe(x => console.log(x));\n *   // 1, 2, 3, I, II, III, IV, V\n *\n * @example <caption>Retries the caught source Observable again in case of error, similar to retry() operator</caption>\n *\n * Observable.of(1, 2, 3, 4, 5)\n *   .map(n => {\n * \t   if (n === 4) {\n * \t     throw 'four!';\n *     }\n * \t   return n;\n *   })\n *   .catch((err, caught) => caught)\n *   .take(30)\n *   .subscribe(x => console.log(x));\n *   // 1, 2, 3, 1, 2, 3, ...\n *\n * @example <caption>Throws a new error when the source Observable throws an error</caption>\n *\n * Observable.of(1, 2, 3, 4, 5)\n *   .map(n => {\n *     if (n == 4) {\n *       throw 'four!';\n *     }\n *     return n;\n *   })\n *   .catch(err => {\n *     throw 'error in source. Details: ' + err;\n *   })\n *   .subscribe(\n *     x => console.log(x),\n *     err => console.log(err)\n *   );\n *   // 1, 2, 3, error in source. Details: four!\n *\n * @param {function} selector a function that takes as arguments `err`, which is the error, and `caught`, which\n *  is the source observable, in case you'd like to \"retry\" that observable by returning it again. Whatever observable\n *  is returned by the `selector` will be used to continue the observable chain.\n * @return {Observable} An observable that originates from either the source or the observable returned by the\n *  catch `selector` function.\n * @method catch\n * @name catch\n * @owner Observable\n */\nfunction _catch(selector) {\n    return catchError_1.catchError(selector)(this);\n}\nexports._catch = _catch;\n//# sourceMappingURL=catch.js.map\n\n//# sourceURL=webpack:///./node_modules/electron-compile/node_modules/rxjs/operator/catch.js?")},"./node_modules/electron-compile/node_modules/rxjs/operator/filter.js":
/*!****************************************************************************!*\
  !*** ./node_modules/electron-compile/node_modules/rxjs/operator/filter.js ***!
  \****************************************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){"use strict";eval('\nvar filter_1 = __webpack_require__(/*! ../operators/filter */ "./node_modules/electron-compile/node_modules/rxjs/operators/filter.js");\n/* tslint:enable:max-line-length */\n/**\n * Filter items emitted by the source Observable by only emitting those that\n * satisfy a specified predicate.\n *\n * <span class="informal">Like\n * [Array.prototype.filter()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter),\n * it only emits a value from the source if it passes a criterion function.</span>\n *\n * <img src="./img/filter.png" width="100%">\n *\n * Similar to the well-known `Array.prototype.filter` method, this operator\n * takes values from the source Observable, passes them through a `predicate`\n * function and only emits those values that yielded `true`.\n *\n * @example <caption>Emit only click events whose target was a DIV element</caption>\n * var clicks = Rx.Observable.fromEvent(document, \'click\');\n * var clicksOnDivs = clicks.filter(ev => ev.target.tagName === \'DIV\');\n * clicksOnDivs.subscribe(x => console.log(x));\n *\n * @see {@link distinct}\n * @see {@link distinctUntilChanged}\n * @see {@link distinctUntilKeyChanged}\n * @see {@link ignoreElements}\n * @see {@link partition}\n * @see {@link skip}\n *\n * @param {function(value: T, index: number): boolean} predicate A function that\n * evaluates each value emitted by the source Observable. If it returns `true`,\n * the value is emitted, if `false` the value is not passed to the output\n * Observable. The `index` parameter is the number `i` for the i-th source\n * emission that has happened since the subscription, starting from the number\n * `0`.\n * @param {any} [thisArg] An optional argument to determine the value of `this`\n * in the `predicate` function.\n * @return {Observable} An Observable of values from the source that were\n * allowed by the `predicate` function.\n * @method filter\n * @owner Observable\n */\nfunction filter(predicate, thisArg) {\n    return filter_1.filter(predicate, thisArg)(this);\n}\nexports.filter = filter;\n//# sourceMappingURL=filter.js.map\n\n//# sourceURL=webpack:///./node_modules/electron-compile/node_modules/rxjs/operator/filter.js?')},"./node_modules/electron-compile/node_modules/rxjs/operator/map.js":
/*!*************************************************************************!*\
  !*** ./node_modules/electron-compile/node_modules/rxjs/operator/map.js ***!
  \*************************************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){"use strict";eval('\nvar map_1 = __webpack_require__(/*! ../operators/map */ "./node_modules/electron-compile/node_modules/rxjs/operators/map.js");\n/**\n * Applies a given `project` function to each value emitted by the source\n * Observable, and emits the resulting values as an Observable.\n *\n * <span class="informal">Like [Array.prototype.map()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map),\n * it passes each source value through a transformation function to get\n * corresponding output values.</span>\n *\n * <img src="./img/map.png" width="100%">\n *\n * Similar to the well known `Array.prototype.map` function, this operator\n * applies a projection to each value and emits that projection in the output\n * Observable.\n *\n * @example <caption>Map every click to the clientX position of that click</caption>\n * var clicks = Rx.Observable.fromEvent(document, \'click\');\n * var positions = clicks.map(ev => ev.clientX);\n * positions.subscribe(x => console.log(x));\n *\n * @see {@link mapTo}\n * @see {@link pluck}\n *\n * @param {function(value: T, index: number): R} project The function to apply\n * to each `value` emitted by the source Observable. The `index` parameter is\n * the number `i` for the i-th emission that has happened since the\n * subscription, starting from the number `0`.\n * @param {any} [thisArg] An optional argument to define what `this` is in the\n * `project` function.\n * @return {Observable<R>} An Observable that emits the values from the source\n * Observable transformed by the given `project` function.\n * @method map\n * @owner Observable\n */\nfunction map(project, thisArg) {\n    return map_1.map(project, thisArg)(this);\n}\nexports.map = map;\n//# sourceMappingURL=map.js.map\n\n//# sourceURL=webpack:///./node_modules/electron-compile/node_modules/rxjs/operator/map.js?')},"./node_modules/electron-compile/node_modules/rxjs/operator/mergeMap.js":
/*!******************************************************************************!*\
  !*** ./node_modules/electron-compile/node_modules/rxjs/operator/mergeMap.js ***!
  \******************************************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){"use strict";eval('\nvar mergeMap_1 = __webpack_require__(/*! ../operators/mergeMap */ "./node_modules/electron-compile/node_modules/rxjs/operators/mergeMap.js");\n/* tslint:enable:max-line-length */\n/**\n * Projects each source value to an Observable which is merged in the output\n * Observable.\n *\n * <span class="informal">Maps each value to an Observable, then flattens all of\n * these inner Observables using {@link mergeAll}.</span>\n *\n * <img src="./img/mergeMap.png" width="100%">\n *\n * Returns an Observable that emits items based on applying a function that you\n * supply to each item emitted by the source Observable, where that function\n * returns an Observable, and then merging those resulting Observables and\n * emitting the results of this merger.\n *\n * @example <caption>Map and flatten each letter to an Observable ticking every 1 second</caption>\n * var letters = Rx.Observable.of(\'a\', \'b\', \'c\');\n * var result = letters.mergeMap(x =>\n *   Rx.Observable.interval(1000).map(i => x+i)\n * );\n * result.subscribe(x => console.log(x));\n *\n * // Results in the following:\n * // a0\n * // b0\n * // c0\n * // a1\n * // b1\n * // c1\n * // continues to list a,b,c with respective ascending integers\n *\n * @see {@link concatMap}\n * @see {@link exhaustMap}\n * @see {@link merge}\n * @see {@link mergeAll}\n * @see {@link mergeMapTo}\n * @see {@link mergeScan}\n * @see {@link switchMap}\n *\n * @param {function(value: T, ?index: number): ObservableInput} project A function\n * that, when applied to an item emitted by the source Observable, returns an\n * Observable.\n * @param {function(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): any} [resultSelector]\n * A function to produce the value on the output Observable based on the values\n * and the indices of the source (outer) emission and the inner Observable\n * emission. The arguments passed to this function are:\n * - `outerValue`: the value that came from the source\n * - `innerValue`: the value that came from the projected Observable\n * - `outerIndex`: the "index" of the value that came from the source\n * - `innerIndex`: the "index" of the value from the projected Observable\n * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of input\n * Observables being subscribed to concurrently.\n * @return {Observable} An Observable that emits the result of applying the\n * projection function (and the optional `resultSelector`) to each item emitted\n * by the source Observable and merging the results of the Observables obtained\n * from this transformation.\n * @method mergeMap\n * @owner Observable\n */\nfunction mergeMap(project, resultSelector, concurrent) {\n    if (concurrent === void 0) { concurrent = Number.POSITIVE_INFINITY; }\n    return mergeMap_1.mergeMap(project, resultSelector, concurrent)(this);\n}\nexports.mergeMap = mergeMap;\n//# sourceMappingURL=mergeMap.js.map\n\n//# sourceURL=webpack:///./node_modules/electron-compile/node_modules/rxjs/operator/mergeMap.js?')},"./node_modules/electron-compile/node_modules/rxjs/operator/publish.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/electron-compile/node_modules/rxjs/operator/publish.js ***!
  \*****************************************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){"use strict";eval('\nvar publish_1 = __webpack_require__(/*! ../operators/publish */ "./node_modules/electron-compile/node_modules/rxjs/operators/publish.js");\n/* tslint:enable:max-line-length */\n/**\n * Returns a ConnectableObservable, which is a variety of Observable that waits until its connect method is called\n * before it begins emitting items to those Observers that have subscribed to it.\n *\n * <img src="./img/publish.png" width="100%">\n *\n * @param {Function} [selector] - Optional selector function which can use the multicasted source sequence as many times\n * as needed, without causing multiple subscriptions to the source sequence.\n * Subscribers to the given source will receive all notifications of the source from the time of the subscription on.\n * @return A ConnectableObservable that upon connection causes the source Observable to emit items to its Observers.\n * @method publish\n * @owner Observable\n */\nfunction publish(selector) {\n    return publish_1.publish(selector)(this);\n}\nexports.publish = publish;\n//# sourceMappingURL=publish.js.map\n\n//# sourceURL=webpack:///./node_modules/electron-compile/node_modules/rxjs/operator/publish.js?')},"./node_modules/electron-compile/node_modules/rxjs/operator/retryWhen.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/electron-compile/node_modules/rxjs/operator/retryWhen.js ***!
  \*******************************************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){"use strict";eval('\nvar retryWhen_1 = __webpack_require__(/*! ../operators/retryWhen */ "./node_modules/electron-compile/node_modules/rxjs/operators/retryWhen.js");\n/**\n * Returns an Observable that mirrors the source Observable with the exception of an `error`. If the source Observable\n * calls `error`, this method will emit the Throwable that caused the error to the Observable returned from `notifier`.\n * If that Observable calls `complete` or `error` then this method will call `complete` or `error` on the child\n * subscription. Otherwise this method will resubscribe to the source Observable.\n *\n * <img src="./img/retryWhen.png" width="100%">\n *\n * @param {function(errors: Observable): Observable} notifier - Receives an Observable of notifications with which a\n * user can `complete` or `error`, aborting the retry.\n * @return {Observable} The source Observable modified with retry logic.\n * @method retryWhen\n * @owner Observable\n */\nfunction retryWhen(notifier) {\n    return retryWhen_1.retryWhen(notifier)(this);\n}\nexports.retryWhen = retryWhen;\n//# sourceMappingURL=retryWhen.js.map\n\n//# sourceURL=webpack:///./node_modules/electron-compile/node_modules/rxjs/operator/retryWhen.js?')},"./node_modules/electron-compile/node_modules/rxjs/operator/switch.js":
/*!****************************************************************************!*\
  !*** ./node_modules/electron-compile/node_modules/rxjs/operator/switch.js ***!
  \****************************************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){"use strict";eval('\nvar switchAll_1 = __webpack_require__(/*! ../operators/switchAll */ "./node_modules/electron-compile/node_modules/rxjs/operators/switchAll.js");\n/**\n * Converts a higher-order Observable into a first-order Observable by\n * subscribing to only the most recently emitted of those inner Observables.\n *\n * <span class="informal">Flattens an Observable-of-Observables by dropping the\n * previous inner Observable once a new one appears.</span>\n *\n * <img src="./img/switch.png" width="100%">\n *\n * `switch` subscribes to an Observable that emits Observables, also known as a\n * higher-order Observable. Each time it observes one of these emitted inner\n * Observables, the output Observable subscribes to the inner Observable and\n * begins emitting the items emitted by that. So far, it behaves\n * like {@link mergeAll}. However, when a new inner Observable is emitted,\n * `switch` unsubscribes from the earlier-emitted inner Observable and\n * subscribes to the new inner Observable and begins emitting items from it. It\n * continues to behave like this for subsequent inner Observables.\n *\n * @example <caption>Rerun an interval Observable on every click event</caption>\n * var clicks = Rx.Observable.fromEvent(document, \'click\');\n * // Each click event is mapped to an Observable that ticks every second\n * var higherOrder = clicks.map((ev) => Rx.Observable.interval(1000));\n * var switched = higherOrder.switch();\n * // The outcome is that `switched` is essentially a timer that restarts\n * // on every click. The interval Observables from older clicks do not merge\n * // with the current interval Observable.\n * switched.subscribe(x => console.log(x));\n *\n * @see {@link combineAll}\n * @see {@link concatAll}\n * @see {@link exhaust}\n * @see {@link mergeAll}\n * @see {@link switchMap}\n * @see {@link switchMapTo}\n * @see {@link zipAll}\n *\n * @return {Observable<T>} An Observable that emits the items emitted by the\n * Observable most recently emitted by the source Observable.\n * @method switch\n * @name switch\n * @owner Observable\n */\nfunction _switch() {\n    return switchAll_1.switchAll()(this);\n}\nexports._switch = _switch;\n//# sourceMappingURL=switch.js.map\n\n//# sourceURL=webpack:///./node_modules/electron-compile/node_modules/rxjs/operator/switch.js?')},"./node_modules/electron-compile/node_modules/rxjs/operator/switchMap.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/electron-compile/node_modules/rxjs/operator/switchMap.js ***!
  \*******************************************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){"use strict";eval('\nvar switchMap_1 = __webpack_require__(/*! ../operators/switchMap */ "./node_modules/electron-compile/node_modules/rxjs/operators/switchMap.js");\n/* tslint:enable:max-line-length */\n/**\n * Projects each source value to an Observable which is merged in the output\n * Observable, emitting values only from the most recently projected Observable.\n *\n * <span class="informal">Maps each value to an Observable, then flattens all of\n * these inner Observables using {@link switch}.</span>\n *\n * <img src="./img/switchMap.png" width="100%">\n *\n * Returns an Observable that emits items based on applying a function that you\n * supply to each item emitted by the source Observable, where that function\n * returns an (so-called "inner") Observable. Each time it observes one of these\n * inner Observables, the output Observable begins emitting the items emitted by\n * that inner Observable. When a new inner Observable is emitted, `switchMap`\n * stops emitting items from the earlier-emitted inner Observable and begins\n * emitting items from the new one. It continues to behave like this for\n * subsequent inner Observables.\n *\n * @example <caption>Rerun an interval Observable on every click event</caption>\n * var clicks = Rx.Observable.fromEvent(document, \'click\');\n * var result = clicks.switchMap((ev) => Rx.Observable.interval(1000));\n * result.subscribe(x => console.log(x));\n *\n * @see {@link concatMap}\n * @see {@link exhaustMap}\n * @see {@link mergeMap}\n * @see {@link switch}\n * @see {@link switchMapTo}\n *\n * @param {function(value: T, ?index: number): ObservableInput} project A function\n * that, when applied to an item emitted by the source Observable, returns an\n * Observable.\n * @param {function(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): any} [resultSelector]\n * A function to produce the value on the output Observable based on the values\n * and the indices of the source (outer) emission and the inner Observable\n * emission. The arguments passed to this function are:\n * - `outerValue`: the value that came from the source\n * - `innerValue`: the value that came from the projected Observable\n * - `outerIndex`: the "index" of the value that came from the source\n * - `innerIndex`: the "index" of the value from the projected Observable\n * @return {Observable} An Observable that emits the result of applying the\n * projection function (and the optional `resultSelector`) to each item emitted\n * by the source Observable and taking only the values from the most recently\n * projected inner Observable.\n * @method switchMap\n * @owner Observable\n */\nfunction switchMap(project, resultSelector) {\n    return switchMap_1.switchMap(project, resultSelector)(this);\n}\nexports.switchMap = switchMap;\n//# sourceMappingURL=switchMap.js.map\n\n//# sourceURL=webpack:///./node_modules/electron-compile/node_modules/rxjs/operator/switchMap.js?')},"./node_modules/electron-compile/node_modules/rxjs/operator/timeout.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/electron-compile/node_modules/rxjs/operator/timeout.js ***!
  \*****************************************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){"use strict";eval('\nvar async_1 = __webpack_require__(/*! ../scheduler/async */ "./node_modules/electron-compile/node_modules/rxjs/scheduler/async.js");\nvar timeout_1 = __webpack_require__(/*! ../operators/timeout */ "./node_modules/electron-compile/node_modules/rxjs/operators/timeout.js");\n/**\n *\n * Errors if Observable does not emit a value in given time span.\n *\n * <span class="informal">Timeouts on Observable that doesn\'t emit values fast enough.</span>\n *\n * <img src="./img/timeout.png" width="100%">\n *\n * `timeout` operator accepts as an argument either a number or a Date.\n *\n * If number was provided, it returns an Observable that behaves like a source\n * Observable, unless there is a period of time where there is no value emitted.\n * So if you provide `100` as argument and first value comes after 50ms from\n * the moment of subscription, this value will be simply re-emitted by the resulting\n * Observable. If however after that 100ms passes without a second value being emitted,\n * stream will end with an error and source Observable will be unsubscribed.\n * These checks are performed throughout whole lifecycle of Observable - from the moment\n * it was subscribed to, until it completes or errors itself. Thus every value must be\n * emitted within specified period since previous value.\n *\n * If provided argument was Date, returned Observable behaves differently. It throws\n * if Observable did not complete before provided Date. This means that periods between\n * emission of particular values do not matter in this case. If Observable did not complete\n * before provided Date, source Observable will be unsubscribed. Other than that, resulting\n * stream behaves just as source Observable.\n *\n * `timeout` accepts also a Scheduler as a second parameter. It is used to schedule moment (or moments)\n * when returned Observable will check if source stream emitted value or completed.\n *\n * @example <caption>Check if ticks are emitted within certain timespan</caption>\n * const seconds = Rx.Observable.interval(1000);\n *\n * seconds.timeout(1100) // Let\'s use bigger timespan to be safe,\n *                       // since `interval` might fire a bit later then scheduled.\n * .subscribe(\n *     value => console.log(value), // Will emit numbers just as regular `interval` would.\n *     err => console.log(err) // Will never be called.\n * );\n *\n * seconds.timeout(900).subscribe(\n *     value => console.log(value), // Will never be called.\n *     err => console.log(err) // Will emit error before even first value is emitted,\n *                             // since it did not arrive within 900ms period.\n * );\n *\n * @example <caption>Use Date to check if Observable completed</caption>\n * const seconds = Rx.Observable.interval(1000);\n *\n * seconds.timeout(new Date("December 17, 2020 03:24:00"))\n * .subscribe(\n *     value => console.log(value), // Will emit values as regular `interval` would\n *                                  // until December 17, 2020 at 03:24:00.\n *     err => console.log(err) // On December 17, 2020 at 03:24:00 it will emit an error,\n *                             // since Observable did not complete by then.\n * );\n *\n * @see {@link timeoutWith}\n *\n * @param {number|Date} due Number specifying period within which Observable must emit values\n *                          or Date specifying before when Observable should complete\n * @param {Scheduler} [scheduler] Scheduler controlling when timeout checks occur.\n * @return {Observable<T>} Observable that mirrors behaviour of source, unless timeout checks fail.\n * @method timeout\n * @owner Observable\n */\nfunction timeout(due, scheduler) {\n    if (scheduler === void 0) { scheduler = async_1.async; }\n    return timeout_1.timeout(due, scheduler)(this);\n}\nexports.timeout = timeout;\n//# sourceMappingURL=timeout.js.map\n\n//# sourceURL=webpack:///./node_modules/electron-compile/node_modules/rxjs/operator/timeout.js?')},"./node_modules/electron-compile/node_modules/rxjs/operator/zip.js":
/*!*************************************************************************!*\
  !*** ./node_modules/electron-compile/node_modules/rxjs/operator/zip.js ***!
  \*************************************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){"use strict";eval('\nvar zip_1 = __webpack_require__(/*! ../operators/zip */ "./node_modules/electron-compile/node_modules/rxjs/operators/zip.js");\n/* tslint:enable:max-line-length */\n/**\n * @param observables\n * @return {Observable<R>}\n * @method zip\n * @owner Observable\n */\nfunction zipProto() {\n    var observables = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        observables[_i - 0] = arguments[_i];\n    }\n    return zip_1.zip.apply(void 0, observables)(this);\n}\nexports.zipProto = zipProto;\n//# sourceMappingURL=zip.js.map\n\n//# sourceURL=webpack:///./node_modules/electron-compile/node_modules/rxjs/operator/zip.js?')},"./node_modules/electron-compile/node_modules/rxjs/operators/catchError.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/electron-compile/node_modules/rxjs/operators/catchError.js ***!
  \*********************************************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){"use strict";eval("\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar OuterSubscriber_1 = __webpack_require__(/*! ../OuterSubscriber */ \"./node_modules/electron-compile/node_modules/rxjs/OuterSubscriber.js\");\nvar subscribeToResult_1 = __webpack_require__(/*! ../util/subscribeToResult */ \"./node_modules/electron-compile/node_modules/rxjs/util/subscribeToResult.js\");\n/**\n * Catches errors on the observable to be handled by returning a new observable or throwing an error.\n *\n * <img src=\"./img/catch.png\" width=\"100%\">\n *\n * @example <caption>Continues with a different Observable when there's an error</caption>\n *\n * Observable.of(1, 2, 3, 4, 5)\n *   .map(n => {\n * \t   if (n == 4) {\n * \t     throw 'four!';\n *     }\n *\t   return n;\n *   })\n *   .catch(err => Observable.of('I', 'II', 'III', 'IV', 'V'))\n *   .subscribe(x => console.log(x));\n *   // 1, 2, 3, I, II, III, IV, V\n *\n * @example <caption>Retries the caught source Observable again in case of error, similar to retry() operator</caption>\n *\n * Observable.of(1, 2, 3, 4, 5)\n *   .map(n => {\n * \t   if (n === 4) {\n * \t     throw 'four!';\n *     }\n * \t   return n;\n *   })\n *   .catch((err, caught) => caught)\n *   .take(30)\n *   .subscribe(x => console.log(x));\n *   // 1, 2, 3, 1, 2, 3, ...\n *\n * @example <caption>Throws a new error when the source Observable throws an error</caption>\n *\n * Observable.of(1, 2, 3, 4, 5)\n *   .map(n => {\n *     if (n == 4) {\n *       throw 'four!';\n *     }\n *     return n;\n *   })\n *   .catch(err => {\n *     throw 'error in source. Details: ' + err;\n *   })\n *   .subscribe(\n *     x => console.log(x),\n *     err => console.log(err)\n *   );\n *   // 1, 2, 3, error in source. Details: four!\n *\n * @param {function} selector a function that takes as arguments `err`, which is the error, and `caught`, which\n *  is the source observable, in case you'd like to \"retry\" that observable by returning it again. Whatever observable\n *  is returned by the `selector` will be used to continue the observable chain.\n * @return {Observable} An observable that originates from either the source or the observable returned by the\n *  catch `selector` function.\n * @name catchError\n */\nfunction catchError(selector) {\n    return function catchErrorOperatorFunction(source) {\n        var operator = new CatchOperator(selector);\n        var caught = source.lift(operator);\n        return (operator.caught = caught);\n    };\n}\nexports.catchError = catchError;\nvar CatchOperator = (function () {\n    function CatchOperator(selector) {\n        this.selector = selector;\n    }\n    CatchOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new CatchSubscriber(subscriber, this.selector, this.caught));\n    };\n    return CatchOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar CatchSubscriber = (function (_super) {\n    __extends(CatchSubscriber, _super);\n    function CatchSubscriber(destination, selector, caught) {\n        _super.call(this, destination);\n        this.selector = selector;\n        this.caught = caught;\n    }\n    // NOTE: overriding `error` instead of `_error` because we don't want\n    // to have this flag this subscriber as `isStopped`. We can mimic the\n    // behavior of the RetrySubscriber (from the `retry` operator), where\n    // we unsubscribe from our source chain, reset our Subscriber flags,\n    // then subscribe to the selector result.\n    CatchSubscriber.prototype.error = function (err) {\n        if (!this.isStopped) {\n            var result = void 0;\n            try {\n                result = this.selector(err, this.caught);\n            }\n            catch (err2) {\n                _super.prototype.error.call(this, err2);\n                return;\n            }\n            this._unsubscribeAndRecycle();\n            this.add(subscribeToResult_1.subscribeToResult(this, result));\n        }\n    };\n    return CatchSubscriber;\n}(OuterSubscriber_1.OuterSubscriber));\n//# sourceMappingURL=catchError.js.map\n\n//# sourceURL=webpack:///./node_modules/electron-compile/node_modules/rxjs/operators/catchError.js?")},"./node_modules/electron-compile/node_modules/rxjs/operators/filter.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/electron-compile/node_modules/rxjs/operators/filter.js ***!
  \*****************************************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){"use strict";eval('\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = __webpack_require__(/*! ../Subscriber */ "./node_modules/electron-compile/node_modules/rxjs/Subscriber.js");\n/* tslint:enable:max-line-length */\n/**\n * Filter items emitted by the source Observable by only emitting those that\n * satisfy a specified predicate.\n *\n * <span class="informal">Like\n * [Array.prototype.filter()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter),\n * it only emits a value from the source if it passes a criterion function.</span>\n *\n * <img src="./img/filter.png" width="100%">\n *\n * Similar to the well-known `Array.prototype.filter` method, this operator\n * takes values from the source Observable, passes them through a `predicate`\n * function and only emits those values that yielded `true`.\n *\n * @example <caption>Emit only click events whose target was a DIV element</caption>\n * var clicks = Rx.Observable.fromEvent(document, \'click\');\n * var clicksOnDivs = clicks.filter(ev => ev.target.tagName === \'DIV\');\n * clicksOnDivs.subscribe(x => console.log(x));\n *\n * @see {@link distinct}\n * @see {@link distinctUntilChanged}\n * @see {@link distinctUntilKeyChanged}\n * @see {@link ignoreElements}\n * @see {@link partition}\n * @see {@link skip}\n *\n * @param {function(value: T, index: number): boolean} predicate A function that\n * evaluates each value emitted by the source Observable. If it returns `true`,\n * the value is emitted, if `false` the value is not passed to the output\n * Observable. The `index` parameter is the number `i` for the i-th source\n * emission that has happened since the subscription, starting from the number\n * `0`.\n * @param {any} [thisArg] An optional argument to determine the value of `this`\n * in the `predicate` function.\n * @return {Observable} An Observable of values from the source that were\n * allowed by the `predicate` function.\n * @method filter\n * @owner Observable\n */\nfunction filter(predicate, thisArg) {\n    return function filterOperatorFunction(source) {\n        return source.lift(new FilterOperator(predicate, thisArg));\n    };\n}\nexports.filter = filter;\nvar FilterOperator = (function () {\n    function FilterOperator(predicate, thisArg) {\n        this.predicate = predicate;\n        this.thisArg = thisArg;\n    }\n    FilterOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new FilterSubscriber(subscriber, this.predicate, this.thisArg));\n    };\n    return FilterOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar FilterSubscriber = (function (_super) {\n    __extends(FilterSubscriber, _super);\n    function FilterSubscriber(destination, predicate, thisArg) {\n        _super.call(this, destination);\n        this.predicate = predicate;\n        this.thisArg = thisArg;\n        this.count = 0;\n    }\n    // the try catch block below is left specifically for\n    // optimization and perf reasons. a tryCatcher is not necessary here.\n    FilterSubscriber.prototype._next = function (value) {\n        var result;\n        try {\n            result = this.predicate.call(this.thisArg, value, this.count++);\n        }\n        catch (err) {\n            this.destination.error(err);\n            return;\n        }\n        if (result) {\n            this.destination.next(value);\n        }\n    };\n    return FilterSubscriber;\n}(Subscriber_1.Subscriber));\n//# sourceMappingURL=filter.js.map\n\n//# sourceURL=webpack:///./node_modules/electron-compile/node_modules/rxjs/operators/filter.js?')},"./node_modules/electron-compile/node_modules/rxjs/operators/map.js":
/*!**************************************************************************!*\
  !*** ./node_modules/electron-compile/node_modules/rxjs/operators/map.js ***!
  \**************************************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){"use strict";eval('\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = __webpack_require__(/*! ../Subscriber */ "./node_modules/electron-compile/node_modules/rxjs/Subscriber.js");\n/**\n * Applies a given `project` function to each value emitted by the source\n * Observable, and emits the resulting values as an Observable.\n *\n * <span class="informal">Like [Array.prototype.map()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map),\n * it passes each source value through a transformation function to get\n * corresponding output values.</span>\n *\n * <img src="./img/map.png" width="100%">\n *\n * Similar to the well known `Array.prototype.map` function, this operator\n * applies a projection to each value and emits that projection in the output\n * Observable.\n *\n * @example <caption>Map every click to the clientX position of that click</caption>\n * var clicks = Rx.Observable.fromEvent(document, \'click\');\n * var positions = clicks.map(ev => ev.clientX);\n * positions.subscribe(x => console.log(x));\n *\n * @see {@link mapTo}\n * @see {@link pluck}\n *\n * @param {function(value: T, index: number): R} project The function to apply\n * to each `value` emitted by the source Observable. The `index` parameter is\n * the number `i` for the i-th emission that has happened since the\n * subscription, starting from the number `0`.\n * @param {any} [thisArg] An optional argument to define what `this` is in the\n * `project` function.\n * @return {Observable<R>} An Observable that emits the values from the source\n * Observable transformed by the given `project` function.\n * @method map\n * @owner Observable\n */\nfunction map(project, thisArg) {\n    return function mapOperation(source) {\n        if (typeof project !== \'function\') {\n            throw new TypeError(\'argument is not a function. Are you looking for `mapTo()`?\');\n        }\n        return source.lift(new MapOperator(project, thisArg));\n    };\n}\nexports.map = map;\nvar MapOperator = (function () {\n    function MapOperator(project, thisArg) {\n        this.project = project;\n        this.thisArg = thisArg;\n    }\n    MapOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new MapSubscriber(subscriber, this.project, this.thisArg));\n    };\n    return MapOperator;\n}());\nexports.MapOperator = MapOperator;\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar MapSubscriber = (function (_super) {\n    __extends(MapSubscriber, _super);\n    function MapSubscriber(destination, project, thisArg) {\n        _super.call(this, destination);\n        this.project = project;\n        this.count = 0;\n        this.thisArg = thisArg || this;\n    }\n    // NOTE: This looks unoptimized, but it\'s actually purposefully NOT\n    // using try/catch optimizations.\n    MapSubscriber.prototype._next = function (value) {\n        var result;\n        try {\n            result = this.project.call(this.thisArg, value, this.count++);\n        }\n        catch (err) {\n            this.destination.error(err);\n            return;\n        }\n        this.destination.next(result);\n    };\n    return MapSubscriber;\n}(Subscriber_1.Subscriber));\n//# sourceMappingURL=map.js.map\n\n//# sourceURL=webpack:///./node_modules/electron-compile/node_modules/rxjs/operators/map.js?')},"./node_modules/electron-compile/node_modules/rxjs/operators/mergeMap.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/electron-compile/node_modules/rxjs/operators/mergeMap.js ***!
  \*******************************************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){"use strict";eval('\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar subscribeToResult_1 = __webpack_require__(/*! ../util/subscribeToResult */ "./node_modules/electron-compile/node_modules/rxjs/util/subscribeToResult.js");\nvar OuterSubscriber_1 = __webpack_require__(/*! ../OuterSubscriber */ "./node_modules/electron-compile/node_modules/rxjs/OuterSubscriber.js");\n/* tslint:enable:max-line-length */\n/**\n * Projects each source value to an Observable which is merged in the output\n * Observable.\n *\n * <span class="informal">Maps each value to an Observable, then flattens all of\n * these inner Observables using {@link mergeAll}.</span>\n *\n * <img src="./img/mergeMap.png" width="100%">\n *\n * Returns an Observable that emits items based on applying a function that you\n * supply to each item emitted by the source Observable, where that function\n * returns an Observable, and then merging those resulting Observables and\n * emitting the results of this merger.\n *\n * @example <caption>Map and flatten each letter to an Observable ticking every 1 second</caption>\n * var letters = Rx.Observable.of(\'a\', \'b\', \'c\');\n * var result = letters.mergeMap(x =>\n *   Rx.Observable.interval(1000).map(i => x+i)\n * );\n * result.subscribe(x => console.log(x));\n *\n * // Results in the following:\n * // a0\n * // b0\n * // c0\n * // a1\n * // b1\n * // c1\n * // continues to list a,b,c with respective ascending integers\n *\n * @see {@link concatMap}\n * @see {@link exhaustMap}\n * @see {@link merge}\n * @see {@link mergeAll}\n * @see {@link mergeMapTo}\n * @see {@link mergeScan}\n * @see {@link switchMap}\n *\n * @param {function(value: T, ?index: number): ObservableInput} project A function\n * that, when applied to an item emitted by the source Observable, returns an\n * Observable.\n * @param {function(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): any} [resultSelector]\n * A function to produce the value on the output Observable based on the values\n * and the indices of the source (outer) emission and the inner Observable\n * emission. The arguments passed to this function are:\n * - `outerValue`: the value that came from the source\n * - `innerValue`: the value that came from the projected Observable\n * - `outerIndex`: the "index" of the value that came from the source\n * - `innerIndex`: the "index" of the value from the projected Observable\n * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of input\n * Observables being subscribed to concurrently.\n * @return {Observable} An Observable that emits the result of applying the\n * projection function (and the optional `resultSelector`) to each item emitted\n * by the source Observable and merging the results of the Observables obtained\n * from this transformation.\n * @method mergeMap\n * @owner Observable\n */\nfunction mergeMap(project, resultSelector, concurrent) {\n    if (concurrent === void 0) { concurrent = Number.POSITIVE_INFINITY; }\n    return function mergeMapOperatorFunction(source) {\n        if (typeof resultSelector === \'number\') {\n            concurrent = resultSelector;\n            resultSelector = null;\n        }\n        return source.lift(new MergeMapOperator(project, resultSelector, concurrent));\n    };\n}\nexports.mergeMap = mergeMap;\nvar MergeMapOperator = (function () {\n    function MergeMapOperator(project, resultSelector, concurrent) {\n        if (concurrent === void 0) { concurrent = Number.POSITIVE_INFINITY; }\n        this.project = project;\n        this.resultSelector = resultSelector;\n        this.concurrent = concurrent;\n    }\n    MergeMapOperator.prototype.call = function (observer, source) {\n        return source.subscribe(new MergeMapSubscriber(observer, this.project, this.resultSelector, this.concurrent));\n    };\n    return MergeMapOperator;\n}());\nexports.MergeMapOperator = MergeMapOperator;\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar MergeMapSubscriber = (function (_super) {\n    __extends(MergeMapSubscriber, _super);\n    function MergeMapSubscriber(destination, project, resultSelector, concurrent) {\n        if (concurrent === void 0) { concurrent = Number.POSITIVE_INFINITY; }\n        _super.call(this, destination);\n        this.project = project;\n        this.resultSelector = resultSelector;\n        this.concurrent = concurrent;\n        this.hasCompleted = false;\n        this.buffer = [];\n        this.active = 0;\n        this.index = 0;\n    }\n    MergeMapSubscriber.prototype._next = function (value) {\n        if (this.active < this.concurrent) {\n            this._tryNext(value);\n        }\n        else {\n            this.buffer.push(value);\n        }\n    };\n    MergeMapSubscriber.prototype._tryNext = function (value) {\n        var result;\n        var index = this.index++;\n        try {\n            result = this.project(value, index);\n        }\n        catch (err) {\n            this.destination.error(err);\n            return;\n        }\n        this.active++;\n        this._innerSub(result, value, index);\n    };\n    MergeMapSubscriber.prototype._innerSub = function (ish, value, index) {\n        this.add(subscribeToResult_1.subscribeToResult(this, ish, value, index));\n    };\n    MergeMapSubscriber.prototype._complete = function () {\n        this.hasCompleted = true;\n        if (this.active === 0 && this.buffer.length === 0) {\n            this.destination.complete();\n        }\n    };\n    MergeMapSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n        if (this.resultSelector) {\n            this._notifyResultSelector(outerValue, innerValue, outerIndex, innerIndex);\n        }\n        else {\n            this.destination.next(innerValue);\n        }\n    };\n    MergeMapSubscriber.prototype._notifyResultSelector = function (outerValue, innerValue, outerIndex, innerIndex) {\n        var result;\n        try {\n            result = this.resultSelector(outerValue, innerValue, outerIndex, innerIndex);\n        }\n        catch (err) {\n            this.destination.error(err);\n            return;\n        }\n        this.destination.next(result);\n    };\n    MergeMapSubscriber.prototype.notifyComplete = function (innerSub) {\n        var buffer = this.buffer;\n        this.remove(innerSub);\n        this.active--;\n        if (buffer.length > 0) {\n            this._next(buffer.shift());\n        }\n        else if (this.active === 0 && this.hasCompleted) {\n            this.destination.complete();\n        }\n    };\n    return MergeMapSubscriber;\n}(OuterSubscriber_1.OuterSubscriber));\nexports.MergeMapSubscriber = MergeMapSubscriber;\n//# sourceMappingURL=mergeMap.js.map\n\n//# sourceURL=webpack:///./node_modules/electron-compile/node_modules/rxjs/operators/mergeMap.js?')},"./node_modules/electron-compile/node_modules/rxjs/operators/multicast.js":
/*!********************************************************************************!*\
  !*** ./node_modules/electron-compile/node_modules/rxjs/operators/multicast.js ***!
  \********************************************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){"use strict";eval('\nvar ConnectableObservable_1 = __webpack_require__(/*! ../observable/ConnectableObservable */ "./node_modules/electron-compile/node_modules/rxjs/observable/ConnectableObservable.js");\n/* tslint:enable:max-line-length */\n/**\n * Returns an Observable that emits the results of invoking a specified selector on items\n * emitted by a ConnectableObservable that shares a single subscription to the underlying stream.\n *\n * <img src="./img/multicast.png" width="100%">\n *\n * @param {Function|Subject} subjectOrSubjectFactory - Factory function to create an intermediate subject through\n * which the source sequence\'s elements will be multicast to the selector function\n * or Subject to push source elements into.\n * @param {Function} [selector] - Optional selector function that can use the multicasted source stream\n * as many times as needed, without causing multiple subscriptions to the source stream.\n * Subscribers to the given source will receive all notifications of the source from the\n * time of the subscription forward.\n * @return {Observable} An Observable that emits the results of invoking the selector\n * on the items emitted by a `ConnectableObservable` that shares a single subscription to\n * the underlying stream.\n * @method multicast\n * @owner Observable\n */\nfunction multicast(subjectOrSubjectFactory, selector) {\n    return function multicastOperatorFunction(source) {\n        var subjectFactory;\n        if (typeof subjectOrSubjectFactory === \'function\') {\n            subjectFactory = subjectOrSubjectFactory;\n        }\n        else {\n            subjectFactory = function subjectFactory() {\n                return subjectOrSubjectFactory;\n            };\n        }\n        if (typeof selector === \'function\') {\n            return source.lift(new MulticastOperator(subjectFactory, selector));\n        }\n        var connectable = Object.create(source, ConnectableObservable_1.connectableObservableDescriptor);\n        connectable.source = source;\n        connectable.subjectFactory = subjectFactory;\n        return connectable;\n    };\n}\nexports.multicast = multicast;\nvar MulticastOperator = (function () {\n    function MulticastOperator(subjectFactory, selector) {\n        this.subjectFactory = subjectFactory;\n        this.selector = selector;\n    }\n    MulticastOperator.prototype.call = function (subscriber, source) {\n        var selector = this.selector;\n        var subject = this.subjectFactory();\n        var subscription = selector(subject).subscribe(subscriber);\n        subscription.add(source.subscribe(subject));\n        return subscription;\n    };\n    return MulticastOperator;\n}());\nexports.MulticastOperator = MulticastOperator;\n//# sourceMappingURL=multicast.js.map\n\n//# sourceURL=webpack:///./node_modules/electron-compile/node_modules/rxjs/operators/multicast.js?')},"./node_modules/electron-compile/node_modules/rxjs/operators/publish.js":
/*!******************************************************************************!*\
  !*** ./node_modules/electron-compile/node_modules/rxjs/operators/publish.js ***!
  \******************************************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){"use strict";eval('\nvar Subject_1 = __webpack_require__(/*! ../Subject */ "./node_modules/electron-compile/node_modules/rxjs/Subject.js");\nvar multicast_1 = __webpack_require__(/*! ./multicast */ "./node_modules/electron-compile/node_modules/rxjs/operators/multicast.js");\n/* tslint:enable:max-line-length */\n/**\n * Returns a ConnectableObservable, which is a variety of Observable that waits until its connect method is called\n * before it begins emitting items to those Observers that have subscribed to it.\n *\n * <img src="./img/publish.png" width="100%">\n *\n * @param {Function} [selector] - Optional selector function which can use the multicasted source sequence as many times\n * as needed, without causing multiple subscriptions to the source sequence.\n * Subscribers to the given source will receive all notifications of the source from the time of the subscription on.\n * @return A ConnectableObservable that upon connection causes the source Observable to emit items to its Observers.\n * @method publish\n * @owner Observable\n */\nfunction publish(selector) {\n    return selector ?\n        multicast_1.multicast(function () { return new Subject_1.Subject(); }, selector) :\n        multicast_1.multicast(new Subject_1.Subject());\n}\nexports.publish = publish;\n//# sourceMappingURL=publish.js.map\n\n//# sourceURL=webpack:///./node_modules/electron-compile/node_modules/rxjs/operators/publish.js?')},"./node_modules/electron-compile/node_modules/rxjs/operators/refCount.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/electron-compile/node_modules/rxjs/operators/refCount.js ***!
  \*******************************************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){"use strict";eval("\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = __webpack_require__(/*! ../Subscriber */ \"./node_modules/electron-compile/node_modules/rxjs/Subscriber.js\");\nfunction refCount() {\n    return function refCountOperatorFunction(source) {\n        return source.lift(new RefCountOperator(source));\n    };\n}\nexports.refCount = refCount;\nvar RefCountOperator = (function () {\n    function RefCountOperator(connectable) {\n        this.connectable = connectable;\n    }\n    RefCountOperator.prototype.call = function (subscriber, source) {\n        var connectable = this.connectable;\n        connectable._refCount++;\n        var refCounter = new RefCountSubscriber(subscriber, connectable);\n        var subscription = source.subscribe(refCounter);\n        if (!refCounter.closed) {\n            refCounter.connection = connectable.connect();\n        }\n        return subscription;\n    };\n    return RefCountOperator;\n}());\nvar RefCountSubscriber = (function (_super) {\n    __extends(RefCountSubscriber, _super);\n    function RefCountSubscriber(destination, connectable) {\n        _super.call(this, destination);\n        this.connectable = connectable;\n    }\n    /** @deprecated internal use only */ RefCountSubscriber.prototype._unsubscribe = function () {\n        var connectable = this.connectable;\n        if (!connectable) {\n            this.connection = null;\n            return;\n        }\n        this.connectable = null;\n        var refCount = connectable._refCount;\n        if (refCount <= 0) {\n            this.connection = null;\n            return;\n        }\n        connectable._refCount = refCount - 1;\n        if (refCount > 1) {\n            this.connection = null;\n            return;\n        }\n        ///\n        // Compare the local RefCountSubscriber's connection Subscription to the\n        // connection Subscription on the shared ConnectableObservable. In cases\n        // where the ConnectableObservable source synchronously emits values, and\n        // the RefCountSubscriber's downstream Observers synchronously unsubscribe,\n        // execution continues to here before the RefCountOperator has a chance to\n        // supply the RefCountSubscriber with the shared connection Subscription.\n        // For example:\n        // ```\n        // Observable.range(0, 10)\n        //   .publish()\n        //   .refCount()\n        //   .take(5)\n        //   .subscribe();\n        // ```\n        // In order to account for this case, RefCountSubscriber should only dispose\n        // the ConnectableObservable's shared connection Subscription if the\n        // connection Subscription exists, *and* either:\n        //   a. RefCountSubscriber doesn't have a reference to the shared connection\n        //      Subscription yet, or,\n        //   b. RefCountSubscriber's connection Subscription reference is identical\n        //      to the shared connection Subscription\n        ///\n        var connection = this.connection;\n        var sharedConnection = connectable._connection;\n        this.connection = null;\n        if (sharedConnection && (!connection || sharedConnection === connection)) {\n            sharedConnection.unsubscribe();\n        }\n    };\n    return RefCountSubscriber;\n}(Subscriber_1.Subscriber));\n//# sourceMappingURL=refCount.js.map\n\n//# sourceURL=webpack:///./node_modules/electron-compile/node_modules/rxjs/operators/refCount.js?")},"./node_modules/electron-compile/node_modules/rxjs/operators/retryWhen.js":
/*!********************************************************************************!*\
  !*** ./node_modules/electron-compile/node_modules/rxjs/operators/retryWhen.js ***!
  \********************************************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){"use strict";eval('\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subject_1 = __webpack_require__(/*! ../Subject */ "./node_modules/electron-compile/node_modules/rxjs/Subject.js");\nvar tryCatch_1 = __webpack_require__(/*! ../util/tryCatch */ "./node_modules/electron-compile/node_modules/rxjs/util/tryCatch.js");\nvar errorObject_1 = __webpack_require__(/*! ../util/errorObject */ "./node_modules/electron-compile/node_modules/rxjs/util/errorObject.js");\nvar OuterSubscriber_1 = __webpack_require__(/*! ../OuterSubscriber */ "./node_modules/electron-compile/node_modules/rxjs/OuterSubscriber.js");\nvar subscribeToResult_1 = __webpack_require__(/*! ../util/subscribeToResult */ "./node_modules/electron-compile/node_modules/rxjs/util/subscribeToResult.js");\n/**\n * Returns an Observable that mirrors the source Observable with the exception of an `error`. If the source Observable\n * calls `error`, this method will emit the Throwable that caused the error to the Observable returned from `notifier`.\n * If that Observable calls `complete` or `error` then this method will call `complete` or `error` on the child\n * subscription. Otherwise this method will resubscribe to the source Observable.\n *\n * <img src="./img/retryWhen.png" width="100%">\n *\n * @param {function(errors: Observable): Observable} notifier - Receives an Observable of notifications with which a\n * user can `complete` or `error`, aborting the retry.\n * @return {Observable} The source Observable modified with retry logic.\n * @method retryWhen\n * @owner Observable\n */\nfunction retryWhen(notifier) {\n    return function (source) { return source.lift(new RetryWhenOperator(notifier, source)); };\n}\nexports.retryWhen = retryWhen;\nvar RetryWhenOperator = (function () {\n    function RetryWhenOperator(notifier, source) {\n        this.notifier = notifier;\n        this.source = source;\n    }\n    RetryWhenOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new RetryWhenSubscriber(subscriber, this.notifier, this.source));\n    };\n    return RetryWhenOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar RetryWhenSubscriber = (function (_super) {\n    __extends(RetryWhenSubscriber, _super);\n    function RetryWhenSubscriber(destination, notifier, source) {\n        _super.call(this, destination);\n        this.notifier = notifier;\n        this.source = source;\n    }\n    RetryWhenSubscriber.prototype.error = function (err) {\n        if (!this.isStopped) {\n            var errors = this.errors;\n            var retries = this.retries;\n            var retriesSubscription = this.retriesSubscription;\n            if (!retries) {\n                errors = new Subject_1.Subject();\n                retries = tryCatch_1.tryCatch(this.notifier)(errors);\n                if (retries === errorObject_1.errorObject) {\n                    return _super.prototype.error.call(this, errorObject_1.errorObject.e);\n                }\n                retriesSubscription = subscribeToResult_1.subscribeToResult(this, retries);\n            }\n            else {\n                this.errors = null;\n                this.retriesSubscription = null;\n            }\n            this._unsubscribeAndRecycle();\n            this.errors = errors;\n            this.retries = retries;\n            this.retriesSubscription = retriesSubscription;\n            errors.next(err);\n        }\n    };\n    /** @deprecated internal use only */ RetryWhenSubscriber.prototype._unsubscribe = function () {\n        var _a = this, errors = _a.errors, retriesSubscription = _a.retriesSubscription;\n        if (errors) {\n            errors.unsubscribe();\n            this.errors = null;\n        }\n        if (retriesSubscription) {\n            retriesSubscription.unsubscribe();\n            this.retriesSubscription = null;\n        }\n        this.retries = null;\n    };\n    RetryWhenSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n        var _a = this, errors = _a.errors, retries = _a.retries, retriesSubscription = _a.retriesSubscription;\n        this.errors = null;\n        this.retries = null;\n        this.retriesSubscription = null;\n        this._unsubscribeAndRecycle();\n        this.errors = errors;\n        this.retries = retries;\n        this.retriesSubscription = retriesSubscription;\n        this.source.subscribe(this);\n    };\n    return RetryWhenSubscriber;\n}(OuterSubscriber_1.OuterSubscriber));\n//# sourceMappingURL=retryWhen.js.map\n\n//# sourceURL=webpack:///./node_modules/electron-compile/node_modules/rxjs/operators/retryWhen.js?')},"./node_modules/electron-compile/node_modules/rxjs/operators/switchAll.js":
/*!********************************************************************************!*\
  !*** ./node_modules/electron-compile/node_modules/rxjs/operators/switchAll.js ***!
  \********************************************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){"use strict";eval('\nvar switchMap_1 = __webpack_require__(/*! ./switchMap */ "./node_modules/electron-compile/node_modules/rxjs/operators/switchMap.js");\nvar identity_1 = __webpack_require__(/*! ../util/identity */ "./node_modules/electron-compile/node_modules/rxjs/util/identity.js");\nfunction switchAll() {\n    return switchMap_1.switchMap(identity_1.identity);\n}\nexports.switchAll = switchAll;\n//# sourceMappingURL=switchAll.js.map\n\n//# sourceURL=webpack:///./node_modules/electron-compile/node_modules/rxjs/operators/switchAll.js?')},"./node_modules/electron-compile/node_modules/rxjs/operators/switchMap.js":
/*!********************************************************************************!*\
  !*** ./node_modules/electron-compile/node_modules/rxjs/operators/switchMap.js ***!
  \********************************************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){"use strict";eval('\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar OuterSubscriber_1 = __webpack_require__(/*! ../OuterSubscriber */ "./node_modules/electron-compile/node_modules/rxjs/OuterSubscriber.js");\nvar subscribeToResult_1 = __webpack_require__(/*! ../util/subscribeToResult */ "./node_modules/electron-compile/node_modules/rxjs/util/subscribeToResult.js");\n/* tslint:enable:max-line-length */\n/**\n * Projects each source value to an Observable which is merged in the output\n * Observable, emitting values only from the most recently projected Observable.\n *\n * <span class="informal">Maps each value to an Observable, then flattens all of\n * these inner Observables using {@link switch}.</span>\n *\n * <img src="./img/switchMap.png" width="100%">\n *\n * Returns an Observable that emits items based on applying a function that you\n * supply to each item emitted by the source Observable, where that function\n * returns an (so-called "inner") Observable. Each time it observes one of these\n * inner Observables, the output Observable begins emitting the items emitted by\n * that inner Observable. When a new inner Observable is emitted, `switchMap`\n * stops emitting items from the earlier-emitted inner Observable and begins\n * emitting items from the new one. It continues to behave like this for\n * subsequent inner Observables.\n *\n * @example <caption>Rerun an interval Observable on every click event</caption>\n * var clicks = Rx.Observable.fromEvent(document, \'click\');\n * var result = clicks.switchMap((ev) => Rx.Observable.interval(1000));\n * result.subscribe(x => console.log(x));\n *\n * @see {@link concatMap}\n * @see {@link exhaustMap}\n * @see {@link mergeMap}\n * @see {@link switch}\n * @see {@link switchMapTo}\n *\n * @param {function(value: T, ?index: number): ObservableInput} project A function\n * that, when applied to an item emitted by the source Observable, returns an\n * Observable.\n * @param {function(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): any} [resultSelector]\n * A function to produce the value on the output Observable based on the values\n * and the indices of the source (outer) emission and the inner Observable\n * emission. The arguments passed to this function are:\n * - `outerValue`: the value that came from the source\n * - `innerValue`: the value that came from the projected Observable\n * - `outerIndex`: the "index" of the value that came from the source\n * - `innerIndex`: the "index" of the value from the projected Observable\n * @return {Observable} An Observable that emits the result of applying the\n * projection function (and the optional `resultSelector`) to each item emitted\n * by the source Observable and taking only the values from the most recently\n * projected inner Observable.\n * @method switchMap\n * @owner Observable\n */\nfunction switchMap(project, resultSelector) {\n    return function switchMapOperatorFunction(source) {\n        return source.lift(new SwitchMapOperator(project, resultSelector));\n    };\n}\nexports.switchMap = switchMap;\nvar SwitchMapOperator = (function () {\n    function SwitchMapOperator(project, resultSelector) {\n        this.project = project;\n        this.resultSelector = resultSelector;\n    }\n    SwitchMapOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new SwitchMapSubscriber(subscriber, this.project, this.resultSelector));\n    };\n    return SwitchMapOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar SwitchMapSubscriber = (function (_super) {\n    __extends(SwitchMapSubscriber, _super);\n    function SwitchMapSubscriber(destination, project, resultSelector) {\n        _super.call(this, destination);\n        this.project = project;\n        this.resultSelector = resultSelector;\n        this.index = 0;\n    }\n    SwitchMapSubscriber.prototype._next = function (value) {\n        var result;\n        var index = this.index++;\n        try {\n            result = this.project(value, index);\n        }\n        catch (error) {\n            this.destination.error(error);\n            return;\n        }\n        this._innerSub(result, value, index);\n    };\n    SwitchMapSubscriber.prototype._innerSub = function (result, value, index) {\n        var innerSubscription = this.innerSubscription;\n        if (innerSubscription) {\n            innerSubscription.unsubscribe();\n        }\n        this.add(this.innerSubscription = subscribeToResult_1.subscribeToResult(this, result, value, index));\n    };\n    SwitchMapSubscriber.prototype._complete = function () {\n        var innerSubscription = this.innerSubscription;\n        if (!innerSubscription || innerSubscription.closed) {\n            _super.prototype._complete.call(this);\n        }\n    };\n    /** @deprecated internal use only */ SwitchMapSubscriber.prototype._unsubscribe = function () {\n        this.innerSubscription = null;\n    };\n    SwitchMapSubscriber.prototype.notifyComplete = function (innerSub) {\n        this.remove(innerSub);\n        this.innerSubscription = null;\n        if (this.isStopped) {\n            _super.prototype._complete.call(this);\n        }\n    };\n    SwitchMapSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n        if (this.resultSelector) {\n            this._tryNotifyNext(outerValue, innerValue, outerIndex, innerIndex);\n        }\n        else {\n            this.destination.next(innerValue);\n        }\n    };\n    SwitchMapSubscriber.prototype._tryNotifyNext = function (outerValue, innerValue, outerIndex, innerIndex) {\n        var result;\n        try {\n            result = this.resultSelector(outerValue, innerValue, outerIndex, innerIndex);\n        }\n        catch (err) {\n            this.destination.error(err);\n            return;\n        }\n        this.destination.next(result);\n    };\n    return SwitchMapSubscriber;\n}(OuterSubscriber_1.OuterSubscriber));\n//# sourceMappingURL=switchMap.js.map\n\n//# sourceURL=webpack:///./node_modules/electron-compile/node_modules/rxjs/operators/switchMap.js?')},"./node_modules/electron-compile/node_modules/rxjs/operators/timeout.js":
/*!******************************************************************************!*\
  !*** ./node_modules/electron-compile/node_modules/rxjs/operators/timeout.js ***!
  \******************************************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){"use strict";eval('\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar async_1 = __webpack_require__(/*! ../scheduler/async */ "./node_modules/electron-compile/node_modules/rxjs/scheduler/async.js");\nvar isDate_1 = __webpack_require__(/*! ../util/isDate */ "./node_modules/electron-compile/node_modules/rxjs/util/isDate.js");\nvar Subscriber_1 = __webpack_require__(/*! ../Subscriber */ "./node_modules/electron-compile/node_modules/rxjs/Subscriber.js");\nvar TimeoutError_1 = __webpack_require__(/*! ../util/TimeoutError */ "./node_modules/electron-compile/node_modules/rxjs/util/TimeoutError.js");\n/**\n *\n * Errors if Observable does not emit a value in given time span.\n *\n * <span class="informal">Timeouts on Observable that doesn\'t emit values fast enough.</span>\n *\n * <img src="./img/timeout.png" width="100%">\n *\n * `timeout` operator accepts as an argument either a number or a Date.\n *\n * If number was provided, it returns an Observable that behaves like a source\n * Observable, unless there is a period of time where there is no value emitted.\n * So if you provide `100` as argument and first value comes after 50ms from\n * the moment of subscription, this value will be simply re-emitted by the resulting\n * Observable. If however after that 100ms passes without a second value being emitted,\n * stream will end with an error and source Observable will be unsubscribed.\n * These checks are performed throughout whole lifecycle of Observable - from the moment\n * it was subscribed to, until it completes or errors itself. Thus every value must be\n * emitted within specified period since previous value.\n *\n * If provided argument was Date, returned Observable behaves differently. It throws\n * if Observable did not complete before provided Date. This means that periods between\n * emission of particular values do not matter in this case. If Observable did not complete\n * before provided Date, source Observable will be unsubscribed. Other than that, resulting\n * stream behaves just as source Observable.\n *\n * `timeout` accepts also a Scheduler as a second parameter. It is used to schedule moment (or moments)\n * when returned Observable will check if source stream emitted value or completed.\n *\n * @example <caption>Check if ticks are emitted within certain timespan</caption>\n * const seconds = Rx.Observable.interval(1000);\n *\n * seconds.timeout(1100) // Let\'s use bigger timespan to be safe,\n *                       // since `interval` might fire a bit later then scheduled.\n * .subscribe(\n *     value => console.log(value), // Will emit numbers just as regular `interval` would.\n *     err => console.log(err) // Will never be called.\n * );\n *\n * seconds.timeout(900).subscribe(\n *     value => console.log(value), // Will never be called.\n *     err => console.log(err) // Will emit error before even first value is emitted,\n *                             // since it did not arrive within 900ms period.\n * );\n *\n * @example <caption>Use Date to check if Observable completed</caption>\n * const seconds = Rx.Observable.interval(1000);\n *\n * seconds.timeout(new Date("December 17, 2020 03:24:00"))\n * .subscribe(\n *     value => console.log(value), // Will emit values as regular `interval` would\n *                                  // until December 17, 2020 at 03:24:00.\n *     err => console.log(err) // On December 17, 2020 at 03:24:00 it will emit an error,\n *                             // since Observable did not complete by then.\n * );\n *\n * @see {@link timeoutWith}\n *\n * @param {number|Date} due Number specifying period within which Observable must emit values\n *                          or Date specifying before when Observable should complete\n * @param {Scheduler} [scheduler] Scheduler controlling when timeout checks occur.\n * @return {Observable<T>} Observable that mirrors behaviour of source, unless timeout checks fail.\n * @method timeout\n * @owner Observable\n */\nfunction timeout(due, scheduler) {\n    if (scheduler === void 0) { scheduler = async_1.async; }\n    var absoluteTimeout = isDate_1.isDate(due);\n    var waitFor = absoluteTimeout ? (+due - scheduler.now()) : Math.abs(due);\n    return function (source) { return source.lift(new TimeoutOperator(waitFor, absoluteTimeout, scheduler, new TimeoutError_1.TimeoutError())); };\n}\nexports.timeout = timeout;\nvar TimeoutOperator = (function () {\n    function TimeoutOperator(waitFor, absoluteTimeout, scheduler, errorInstance) {\n        this.waitFor = waitFor;\n        this.absoluteTimeout = absoluteTimeout;\n        this.scheduler = scheduler;\n        this.errorInstance = errorInstance;\n    }\n    TimeoutOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new TimeoutSubscriber(subscriber, this.absoluteTimeout, this.waitFor, this.scheduler, this.errorInstance));\n    };\n    return TimeoutOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar TimeoutSubscriber = (function (_super) {\n    __extends(TimeoutSubscriber, _super);\n    function TimeoutSubscriber(destination, absoluteTimeout, waitFor, scheduler, errorInstance) {\n        _super.call(this, destination);\n        this.absoluteTimeout = absoluteTimeout;\n        this.waitFor = waitFor;\n        this.scheduler = scheduler;\n        this.errorInstance = errorInstance;\n        this.action = null;\n        this.scheduleTimeout();\n    }\n    TimeoutSubscriber.dispatchTimeout = function (subscriber) {\n        subscriber.error(subscriber.errorInstance);\n    };\n    TimeoutSubscriber.prototype.scheduleTimeout = function () {\n        var action = this.action;\n        if (action) {\n            // Recycle the action if we\'ve already scheduled one. All the production\n            // Scheduler Actions mutate their state/delay time and return themeselves.\n            // VirtualActions are immutable, so they create and return a clone. In this\n            // case, we need to set the action reference to the most recent VirtualAction,\n            // to ensure that\'s the one we clone from next time.\n            this.action = action.schedule(this, this.waitFor);\n        }\n        else {\n            this.add(this.action = this.scheduler.schedule(TimeoutSubscriber.dispatchTimeout, this.waitFor, this));\n        }\n    };\n    TimeoutSubscriber.prototype._next = function (value) {\n        if (!this.absoluteTimeout) {\n            this.scheduleTimeout();\n        }\n        _super.prototype._next.call(this, value);\n    };\n    /** @deprecated internal use only */ TimeoutSubscriber.prototype._unsubscribe = function () {\n        this.action = null;\n        this.scheduler = null;\n        this.errorInstance = null;\n    };\n    return TimeoutSubscriber;\n}(Subscriber_1.Subscriber));\n//# sourceMappingURL=timeout.js.map\n\n//# sourceURL=webpack:///./node_modules/electron-compile/node_modules/rxjs/operators/timeout.js?')},"./node_modules/electron-compile/node_modules/rxjs/operators/zip.js":
/*!**************************************************************************!*\
  !*** ./node_modules/electron-compile/node_modules/rxjs/operators/zip.js ***!
  \**************************************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){"use strict";eval("\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar ArrayObservable_1 = __webpack_require__(/*! ../observable/ArrayObservable */ \"./node_modules/electron-compile/node_modules/rxjs/observable/ArrayObservable.js\");\nvar isArray_1 = __webpack_require__(/*! ../util/isArray */ \"./node_modules/electron-compile/node_modules/rxjs/util/isArray.js\");\nvar Subscriber_1 = __webpack_require__(/*! ../Subscriber */ \"./node_modules/electron-compile/node_modules/rxjs/Subscriber.js\");\nvar OuterSubscriber_1 = __webpack_require__(/*! ../OuterSubscriber */ \"./node_modules/electron-compile/node_modules/rxjs/OuterSubscriber.js\");\nvar subscribeToResult_1 = __webpack_require__(/*! ../util/subscribeToResult */ \"./node_modules/electron-compile/node_modules/rxjs/util/subscribeToResult.js\");\nvar iterator_1 = __webpack_require__(/*! ../symbol/iterator */ \"./node_modules/electron-compile/node_modules/rxjs/symbol/iterator.js\");\n/* tslint:enable:max-line-length */\n/**\n * @param observables\n * @return {Observable<R>}\n * @method zip\n * @owner Observable\n */\nfunction zip() {\n    var observables = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        observables[_i - 0] = arguments[_i];\n    }\n    return function zipOperatorFunction(source) {\n        return source.lift.call(zipStatic.apply(void 0, [source].concat(observables)));\n    };\n}\nexports.zip = zip;\n/* tslint:enable:max-line-length */\n/**\n * Combines multiple Observables to create an Observable whose values are calculated from the values, in order, of each\n * of its input Observables.\n *\n * If the latest parameter is a function, this function is used to compute the created value from the input values.\n * Otherwise, an array of the input values is returned.\n *\n * @example <caption>Combine age and name from different sources</caption>\n *\n * let age$ = Observable.of<number>(27, 25, 29);\n * let name$ = Observable.of<string>('Foo', 'Bar', 'Beer');\n * let isDev$ = Observable.of<boolean>(true, true, false);\n *\n * Observable\n *     .zip(age$,\n *          name$,\n *          isDev$,\n *          (age: number, name: string, isDev: boolean) => ({ age, name, isDev }))\n *     .subscribe(x => console.log(x));\n *\n * // outputs\n * // { age: 27, name: 'Foo', isDev: true }\n * // { age: 25, name: 'Bar', isDev: true }\n * // { age: 29, name: 'Beer', isDev: false }\n *\n * @param observables\n * @return {Observable<R>}\n * @static true\n * @name zip\n * @owner Observable\n */\nfunction zipStatic() {\n    var observables = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        observables[_i - 0] = arguments[_i];\n    }\n    var project = observables[observables.length - 1];\n    if (typeof project === 'function') {\n        observables.pop();\n    }\n    return new ArrayObservable_1.ArrayObservable(observables).lift(new ZipOperator(project));\n}\nexports.zipStatic = zipStatic;\nvar ZipOperator = (function () {\n    function ZipOperator(project) {\n        this.project = project;\n    }\n    ZipOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new ZipSubscriber(subscriber, this.project));\n    };\n    return ZipOperator;\n}());\nexports.ZipOperator = ZipOperator;\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar ZipSubscriber = (function (_super) {\n    __extends(ZipSubscriber, _super);\n    function ZipSubscriber(destination, project, values) {\n        if (values === void 0) { values = Object.create(null); }\n        _super.call(this, destination);\n        this.iterators = [];\n        this.active = 0;\n        this.project = (typeof project === 'function') ? project : null;\n        this.values = values;\n    }\n    ZipSubscriber.prototype._next = function (value) {\n        var iterators = this.iterators;\n        if (isArray_1.isArray(value)) {\n            iterators.push(new StaticArrayIterator(value));\n        }\n        else if (typeof value[iterator_1.iterator] === 'function') {\n            iterators.push(new StaticIterator(value[iterator_1.iterator]()));\n        }\n        else {\n            iterators.push(new ZipBufferIterator(this.destination, this, value));\n        }\n    };\n    ZipSubscriber.prototype._complete = function () {\n        var iterators = this.iterators;\n        var len = iterators.length;\n        if (len === 0) {\n            this.destination.complete();\n            return;\n        }\n        this.active = len;\n        for (var i = 0; i < len; i++) {\n            var iterator = iterators[i];\n            if (iterator.stillUnsubscribed) {\n                this.add(iterator.subscribe(iterator, i));\n            }\n            else {\n                this.active--; // not an observable\n            }\n        }\n    };\n    ZipSubscriber.prototype.notifyInactive = function () {\n        this.active--;\n        if (this.active === 0) {\n            this.destination.complete();\n        }\n    };\n    ZipSubscriber.prototype.checkIterators = function () {\n        var iterators = this.iterators;\n        var len = iterators.length;\n        var destination = this.destination;\n        // abort if not all of them have values\n        for (var i = 0; i < len; i++) {\n            var iterator = iterators[i];\n            if (typeof iterator.hasValue === 'function' && !iterator.hasValue()) {\n                return;\n            }\n        }\n        var shouldComplete = false;\n        var args = [];\n        for (var i = 0; i < len; i++) {\n            var iterator = iterators[i];\n            var result = iterator.next();\n            // check to see if it's completed now that you've gotten\n            // the next value.\n            if (iterator.hasCompleted()) {\n                shouldComplete = true;\n            }\n            if (result.done) {\n                destination.complete();\n                return;\n            }\n            args.push(result.value);\n        }\n        if (this.project) {\n            this._tryProject(args);\n        }\n        else {\n            destination.next(args);\n        }\n        if (shouldComplete) {\n            destination.complete();\n        }\n    };\n    ZipSubscriber.prototype._tryProject = function (args) {\n        var result;\n        try {\n            result = this.project.apply(this, args);\n        }\n        catch (err) {\n            this.destination.error(err);\n            return;\n        }\n        this.destination.next(result);\n    };\n    return ZipSubscriber;\n}(Subscriber_1.Subscriber));\nexports.ZipSubscriber = ZipSubscriber;\nvar StaticIterator = (function () {\n    function StaticIterator(iterator) {\n        this.iterator = iterator;\n        this.nextResult = iterator.next();\n    }\n    StaticIterator.prototype.hasValue = function () {\n        return true;\n    };\n    StaticIterator.prototype.next = function () {\n        var result = this.nextResult;\n        this.nextResult = this.iterator.next();\n        return result;\n    };\n    StaticIterator.prototype.hasCompleted = function () {\n        var nextResult = this.nextResult;\n        return nextResult && nextResult.done;\n    };\n    return StaticIterator;\n}());\nvar StaticArrayIterator = (function () {\n    function StaticArrayIterator(array) {\n        this.array = array;\n        this.index = 0;\n        this.length = 0;\n        this.length = array.length;\n    }\n    StaticArrayIterator.prototype[iterator_1.iterator] = function () {\n        return this;\n    };\n    StaticArrayIterator.prototype.next = function (value) {\n        var i = this.index++;\n        var array = this.array;\n        return i < this.length ? { value: array[i], done: false } : { value: null, done: true };\n    };\n    StaticArrayIterator.prototype.hasValue = function () {\n        return this.array.length > this.index;\n    };\n    StaticArrayIterator.prototype.hasCompleted = function () {\n        return this.array.length === this.index;\n    };\n    return StaticArrayIterator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar ZipBufferIterator = (function (_super) {\n    __extends(ZipBufferIterator, _super);\n    function ZipBufferIterator(destination, parent, observable) {\n        _super.call(this, destination);\n        this.parent = parent;\n        this.observable = observable;\n        this.stillUnsubscribed = true;\n        this.buffer = [];\n        this.isComplete = false;\n    }\n    ZipBufferIterator.prototype[iterator_1.iterator] = function () {\n        return this;\n    };\n    // NOTE: there is actually a name collision here with Subscriber.next and Iterator.next\n    //    this is legit because `next()` will never be called by a subscription in this case.\n    ZipBufferIterator.prototype.next = function () {\n        var buffer = this.buffer;\n        if (buffer.length === 0 && this.isComplete) {\n            return { value: null, done: true };\n        }\n        else {\n            return { value: buffer.shift(), done: false };\n        }\n    };\n    ZipBufferIterator.prototype.hasValue = function () {\n        return this.buffer.length > 0;\n    };\n    ZipBufferIterator.prototype.hasCompleted = function () {\n        return this.buffer.length === 0 && this.isComplete;\n    };\n    ZipBufferIterator.prototype.notifyComplete = function () {\n        if (this.buffer.length > 0) {\n            this.isComplete = true;\n            this.parent.notifyInactive();\n        }\n        else {\n            this.destination.complete();\n        }\n    };\n    ZipBufferIterator.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n        this.buffer.push(innerValue);\n        this.parent.checkIterators();\n    };\n    ZipBufferIterator.prototype.subscribe = function (value, index) {\n        return subscribeToResult_1.subscribeToResult(this, this.observable, this, index);\n    };\n    return ZipBufferIterator;\n}(OuterSubscriber_1.OuterSubscriber));\n//# sourceMappingURL=zip.js.map\n\n//# sourceURL=webpack:///./node_modules/electron-compile/node_modules/rxjs/operators/zip.js?")},"./node_modules/electron-compile/node_modules/rxjs/scheduler/Action.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/electron-compile/node_modules/rxjs/scheduler/Action.js ***!
  \*****************************************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){"use strict";eval('\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscription_1 = __webpack_require__(/*! ../Subscription */ "./node_modules/electron-compile/node_modules/rxjs/Subscription.js");\n/**\n * A unit of work to be executed in a {@link Scheduler}. An action is typically\n * created from within a Scheduler and an RxJS user does not need to concern\n * themselves about creating and manipulating an Action.\n *\n * ```ts\n * class Action<T> extends Subscription {\n *   new (scheduler: Scheduler, work: (state?: T) => void);\n *   schedule(state?: T, delay: number = 0): Subscription;\n * }\n * ```\n *\n * @class Action<T>\n */\nvar Action = (function (_super) {\n    __extends(Action, _super);\n    function Action(scheduler, work) {\n        _super.call(this);\n    }\n    /**\n     * Schedules this action on its parent Scheduler for execution. May be passed\n     * some context object, `state`. May happen at some point in the future,\n     * according to the `delay` parameter, if specified.\n     * @param {T} [state] Some contextual data that the `work` function uses when\n     * called by the Scheduler.\n     * @param {number} [delay] Time to wait before executing the work, where the\n     * time unit is implicit and defined by the Scheduler.\n     * @return {void}\n     */\n    Action.prototype.schedule = function (state, delay) {\n        if (delay === void 0) { delay = 0; }\n        return this;\n    };\n    return Action;\n}(Subscription_1.Subscription));\nexports.Action = Action;\n//# sourceMappingURL=Action.js.map\n\n//# sourceURL=webpack:///./node_modules/electron-compile/node_modules/rxjs/scheduler/Action.js?')},"./node_modules/electron-compile/node_modules/rxjs/scheduler/AsyncAction.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/electron-compile/node_modules/rxjs/scheduler/AsyncAction.js ***!
  \**********************************************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){"use strict";eval("\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar root_1 = __webpack_require__(/*! ../util/root */ \"./node_modules/electron-compile/node_modules/rxjs/util/root.js\");\nvar Action_1 = __webpack_require__(/*! ./Action */ \"./node_modules/electron-compile/node_modules/rxjs/scheduler/Action.js\");\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar AsyncAction = (function (_super) {\n    __extends(AsyncAction, _super);\n    function AsyncAction(scheduler, work) {\n        _super.call(this, scheduler, work);\n        this.scheduler = scheduler;\n        this.pending = false;\n        this.work = work;\n    }\n    AsyncAction.prototype.schedule = function (state, delay) {\n        if (delay === void 0) { delay = 0; }\n        if (this.closed) {\n            return this;\n        }\n        // Always replace the current state with the new state.\n        this.state = state;\n        // Set the pending flag indicating that this action has been scheduled, or\n        // has recursively rescheduled itself.\n        this.pending = true;\n        var id = this.id;\n        var scheduler = this.scheduler;\n        //\n        // Important implementation note:\n        //\n        // Actions only execute once by default, unless rescheduled from within the\n        // scheduled callback. This allows us to implement single and repeat\n        // actions via the same code path, without adding API surface area, as well\n        // as mimic traditional recursion but across asynchronous boundaries.\n        //\n        // However, JS runtimes and timers distinguish between intervals achieved by\n        // serial `setTimeout` calls vs. a single `setInterval` call. An interval of\n        // serial `setTimeout` calls can be individually delayed, which delays\n        // scheduling the next `setTimeout`, and so on. `setInterval` attempts to\n        // guarantee the interval callback will be invoked more precisely to the\n        // interval period, regardless of load.\n        //\n        // Therefore, we use `setInterval` to schedule single and repeat actions.\n        // If the action reschedules itself with the same delay, the interval is not\n        // canceled. If the action doesn't reschedule, or reschedules with a\n        // different delay, the interval will be canceled after scheduled callback\n        // execution.\n        //\n        if (id != null) {\n            this.id = this.recycleAsyncId(scheduler, id, delay);\n        }\n        this.delay = delay;\n        // If this action has already an async Id, don't request a new one.\n        this.id = this.id || this.requestAsyncId(scheduler, this.id, delay);\n        return this;\n    };\n    AsyncAction.prototype.requestAsyncId = function (scheduler, id, delay) {\n        if (delay === void 0) { delay = 0; }\n        return root_1.root.setInterval(scheduler.flush.bind(scheduler, this), delay);\n    };\n    AsyncAction.prototype.recycleAsyncId = function (scheduler, id, delay) {\n        if (delay === void 0) { delay = 0; }\n        // If this action is rescheduled with the same delay time, don't clear the interval id.\n        if (delay !== null && this.delay === delay && this.pending === false) {\n            return id;\n        }\n        // Otherwise, if the action's delay time is different from the current delay,\n        // or the action has been rescheduled before it's executed, clear the interval id\n        return root_1.root.clearInterval(id) && undefined || undefined;\n    };\n    /**\n     * Immediately executes this action and the `work` it contains.\n     * @return {any}\n     */\n    AsyncAction.prototype.execute = function (state, delay) {\n        if (this.closed) {\n            return new Error('executing a cancelled action');\n        }\n        this.pending = false;\n        var error = this._execute(state, delay);\n        if (error) {\n            return error;\n        }\n        else if (this.pending === false && this.id != null) {\n            // Dequeue if the action didn't reschedule itself. Don't call\n            // unsubscribe(), because the action could reschedule later.\n            // For example:\n            // ```\n            // scheduler.schedule(function doWork(counter) {\n            //   /* ... I'm a busy worker bee ... */\n            //   var originalAction = this;\n            //   /* wait 100ms before rescheduling the action */\n            //   setTimeout(function () {\n            //     originalAction.schedule(counter + 1);\n            //   }, 100);\n            // }, 1000);\n            // ```\n            this.id = this.recycleAsyncId(this.scheduler, this.id, null);\n        }\n    };\n    AsyncAction.prototype._execute = function (state, delay) {\n        var errored = false;\n        var errorValue = undefined;\n        try {\n            this.work(state);\n        }\n        catch (e) {\n            errored = true;\n            errorValue = !!e && e || new Error(e);\n        }\n        if (errored) {\n            this.unsubscribe();\n            return errorValue;\n        }\n    };\n    /** @deprecated internal use only */ AsyncAction.prototype._unsubscribe = function () {\n        var id = this.id;\n        var scheduler = this.scheduler;\n        var actions = scheduler.actions;\n        var index = actions.indexOf(this);\n        this.work = null;\n        this.state = null;\n        this.pending = false;\n        this.scheduler = null;\n        if (index !== -1) {\n            actions.splice(index, 1);\n        }\n        if (id != null) {\n            this.id = this.recycleAsyncId(scheduler, id, null);\n        }\n        this.delay = null;\n    };\n    return AsyncAction;\n}(Action_1.Action));\nexports.AsyncAction = AsyncAction;\n//# sourceMappingURL=AsyncAction.js.map\n\n//# sourceURL=webpack:///./node_modules/electron-compile/node_modules/rxjs/scheduler/AsyncAction.js?")},"./node_modules/electron-compile/node_modules/rxjs/scheduler/AsyncScheduler.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/electron-compile/node_modules/rxjs/scheduler/AsyncScheduler.js ***!
  \*************************************************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){"use strict";eval('\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Scheduler_1 = __webpack_require__(/*! ../Scheduler */ "./node_modules/electron-compile/node_modules/rxjs/Scheduler.js");\nvar AsyncScheduler = (function (_super) {\n    __extends(AsyncScheduler, _super);\n    function AsyncScheduler() {\n        _super.apply(this, arguments);\n        this.actions = [];\n        /**\n         * A flag to indicate whether the Scheduler is currently executing a batch of\n         * queued actions.\n         * @type {boolean}\n         */\n        this.active = false;\n        /**\n         * An internal ID used to track the latest asynchronous task such as those\n         * coming from `setTimeout`, `setInterval`, `requestAnimationFrame`, and\n         * others.\n         * @type {any}\n         */\n        this.scheduled = undefined;\n    }\n    AsyncScheduler.prototype.flush = function (action) {\n        var actions = this.actions;\n        if (this.active) {\n            actions.push(action);\n            return;\n        }\n        var error;\n        this.active = true;\n        do {\n            if (error = action.execute(action.state, action.delay)) {\n                break;\n            }\n        } while (action = actions.shift()); // exhaust the scheduler queue\n        this.active = false;\n        if (error) {\n            while (action = actions.shift()) {\n                action.unsubscribe();\n            }\n            throw error;\n        }\n    };\n    return AsyncScheduler;\n}(Scheduler_1.Scheduler));\nexports.AsyncScheduler = AsyncScheduler;\n//# sourceMappingURL=AsyncScheduler.js.map\n\n//# sourceURL=webpack:///./node_modules/electron-compile/node_modules/rxjs/scheduler/AsyncScheduler.js?')},"./node_modules/electron-compile/node_modules/rxjs/scheduler/async.js":
/*!****************************************************************************!*\
  !*** ./node_modules/electron-compile/node_modules/rxjs/scheduler/async.js ***!
  \****************************************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){"use strict";eval('\nvar AsyncAction_1 = __webpack_require__(/*! ./AsyncAction */ "./node_modules/electron-compile/node_modules/rxjs/scheduler/AsyncAction.js");\nvar AsyncScheduler_1 = __webpack_require__(/*! ./AsyncScheduler */ "./node_modules/electron-compile/node_modules/rxjs/scheduler/AsyncScheduler.js");\n/**\n *\n * Async Scheduler\n *\n * <span class="informal">Schedule task as if you used setTimeout(task, duration)</span>\n *\n * `async` scheduler schedules tasks asynchronously, by putting them on the JavaScript\n * event loop queue. It is best used to delay tasks in time or to schedule tasks repeating\n * in intervals.\n *\n * If you just want to "defer" task, that is to perform it right after currently\n * executing synchronous code ends (commonly achieved by `setTimeout(deferredTask, 0)`),\n * better choice will be the {@link asap} scheduler.\n *\n * @example <caption>Use async scheduler to delay task</caption>\n * const task = () => console.log(\'it works!\');\n *\n * Rx.Scheduler.async.schedule(task, 2000);\n *\n * // After 2 seconds logs:\n * // "it works!"\n *\n *\n * @example <caption>Use async scheduler to repeat task in intervals</caption>\n * function task(state) {\n *   console.log(state);\n *   this.schedule(state + 1, 1000); // `this` references currently executing Action,\n *                                   // which we reschedule with new state and delay\n * }\n *\n * Rx.Scheduler.async.schedule(task, 3000, 0);\n *\n * // Logs:\n * // 0 after 3s\n * // 1 after 4s\n * // 2 after 5s\n * // 3 after 6s\n *\n * @static true\n * @name async\n * @owner Scheduler\n */\nexports.async = new AsyncScheduler_1.AsyncScheduler(AsyncAction_1.AsyncAction);\n//# sourceMappingURL=async.js.map\n\n//# sourceURL=webpack:///./node_modules/electron-compile/node_modules/rxjs/scheduler/async.js?')},"./node_modules/electron-compile/node_modules/rxjs/symbol/iterator.js":
/*!****************************************************************************!*\
  !*** ./node_modules/electron-compile/node_modules/rxjs/symbol/iterator.js ***!
  \****************************************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){"use strict";eval("\nvar root_1 = __webpack_require__(/*! ../util/root */ \"./node_modules/electron-compile/node_modules/rxjs/util/root.js\");\nfunction symbolIteratorPonyfill(root) {\n    var Symbol = root.Symbol;\n    if (typeof Symbol === 'function') {\n        if (!Symbol.iterator) {\n            Symbol.iterator = Symbol('iterator polyfill');\n        }\n        return Symbol.iterator;\n    }\n    else {\n        // [for Mozilla Gecko 27-35:](https://mzl.la/2ewE1zC)\n        var Set_1 = root.Set;\n        if (Set_1 && typeof new Set_1()['@@iterator'] === 'function') {\n            return '@@iterator';\n        }\n        var Map_1 = root.Map;\n        // required for compatability with es6-shim\n        if (Map_1) {\n            var keys = Object.getOwnPropertyNames(Map_1.prototype);\n            for (var i = 0; i < keys.length; ++i) {\n                var key = keys[i];\n                // according to spec, Map.prototype[@@iterator] and Map.orototype.entries must be equal.\n                if (key !== 'entries' && key !== 'size' && Map_1.prototype[key] === Map_1.prototype['entries']) {\n                    return key;\n                }\n            }\n        }\n        return '@@iterator';\n    }\n}\nexports.symbolIteratorPonyfill = symbolIteratorPonyfill;\nexports.iterator = symbolIteratorPonyfill(root_1.root);\n/**\n * @deprecated use iterator instead\n */\nexports.$$iterator = exports.iterator;\n//# sourceMappingURL=iterator.js.map\n\n//# sourceURL=webpack:///./node_modules/electron-compile/node_modules/rxjs/symbol/iterator.js?")},"./node_modules/electron-compile/node_modules/rxjs/symbol/observable.js":
/*!******************************************************************************!*\
  !*** ./node_modules/electron-compile/node_modules/rxjs/symbol/observable.js ***!
  \******************************************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){"use strict";eval("\nvar root_1 = __webpack_require__(/*! ../util/root */ \"./node_modules/electron-compile/node_modules/rxjs/util/root.js\");\nfunction getSymbolObservable(context) {\n    var $$observable;\n    var Symbol = context.Symbol;\n    if (typeof Symbol === 'function') {\n        if (Symbol.observable) {\n            $$observable = Symbol.observable;\n        }\n        else {\n            $$observable = Symbol('observable');\n            Symbol.observable = $$observable;\n        }\n    }\n    else {\n        $$observable = '@@observable';\n    }\n    return $$observable;\n}\nexports.getSymbolObservable = getSymbolObservable;\nexports.observable = getSymbolObservable(root_1.root);\n/**\n * @deprecated use observable instead\n */\nexports.$$observable = exports.observable;\n//# sourceMappingURL=observable.js.map\n\n//# sourceURL=webpack:///./node_modules/electron-compile/node_modules/rxjs/symbol/observable.js?")},"./node_modules/electron-compile/node_modules/rxjs/symbol/rxSubscriber.js":
/*!********************************************************************************!*\
  !*** ./node_modules/electron-compile/node_modules/rxjs/symbol/rxSubscriber.js ***!
  \********************************************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){"use strict";eval("\nvar root_1 = __webpack_require__(/*! ../util/root */ \"./node_modules/electron-compile/node_modules/rxjs/util/root.js\");\nvar Symbol = root_1.root.Symbol;\nexports.rxSubscriber = (typeof Symbol === 'function' && typeof Symbol.for === 'function') ?\n    Symbol.for('rxSubscriber') : '@@rxSubscriber';\n/**\n * @deprecated use rxSubscriber instead\n */\nexports.$$rxSubscriber = exports.rxSubscriber;\n//# sourceMappingURL=rxSubscriber.js.map\n\n//# sourceURL=webpack:///./node_modules/electron-compile/node_modules/rxjs/symbol/rxSubscriber.js?")},"./node_modules/electron-compile/node_modules/rxjs/util/ObjectUnsubscribedError.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/electron-compile/node_modules/rxjs/util/ObjectUnsubscribedError.js ***!
  \*****************************************************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){"use strict";eval("\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\n/**\n * An error thrown when an action is invalid because the object has been\n * unsubscribed.\n *\n * @see {@link Subject}\n * @see {@link BehaviorSubject}\n *\n * @class ObjectUnsubscribedError\n */\nvar ObjectUnsubscribedError = (function (_super) {\n    __extends(ObjectUnsubscribedError, _super);\n    function ObjectUnsubscribedError() {\n        var err = _super.call(this, 'object unsubscribed');\n        this.name = err.name = 'ObjectUnsubscribedError';\n        this.stack = err.stack;\n        this.message = err.message;\n    }\n    return ObjectUnsubscribedError;\n}(Error));\nexports.ObjectUnsubscribedError = ObjectUnsubscribedError;\n//# sourceMappingURL=ObjectUnsubscribedError.js.map\n\n//# sourceURL=webpack:///./node_modules/electron-compile/node_modules/rxjs/util/ObjectUnsubscribedError.js?")},"./node_modules/electron-compile/node_modules/rxjs/util/TimeoutError.js":
/*!******************************************************************************!*\
  !*** ./node_modules/electron-compile/node_modules/rxjs/util/TimeoutError.js ***!
  \******************************************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){"use strict";eval("\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\n/**\n * An error thrown when duetime elapses.\n *\n * @see {@link timeout}\n *\n * @class TimeoutError\n */\nvar TimeoutError = (function (_super) {\n    __extends(TimeoutError, _super);\n    function TimeoutError() {\n        var err = _super.call(this, 'Timeout has occurred');\n        this.name = err.name = 'TimeoutError';\n        this.stack = err.stack;\n        this.message = err.message;\n    }\n    return TimeoutError;\n}(Error));\nexports.TimeoutError = TimeoutError;\n//# sourceMappingURL=TimeoutError.js.map\n\n//# sourceURL=webpack:///./node_modules/electron-compile/node_modules/rxjs/util/TimeoutError.js?")},"./node_modules/electron-compile/node_modules/rxjs/util/UnsubscriptionError.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/electron-compile/node_modules/rxjs/util/UnsubscriptionError.js ***!
  \*************************************************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){"use strict";eval("\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\n/**\n * An error thrown when one or more errors have occurred during the\n * `unsubscribe` of a {@link Subscription}.\n */\nvar UnsubscriptionError = (function (_super) {\n    __extends(UnsubscriptionError, _super);\n    function UnsubscriptionError(errors) {\n        _super.call(this);\n        this.errors = errors;\n        var err = Error.call(this, errors ?\n            errors.length + \" errors occurred during unsubscription:\\n  \" + errors.map(function (err, i) { return ((i + 1) + \") \" + err.toString()); }).join('\\n  ') : '');\n        this.name = err.name = 'UnsubscriptionError';\n        this.stack = err.stack;\n        this.message = err.message;\n    }\n    return UnsubscriptionError;\n}(Error));\nexports.UnsubscriptionError = UnsubscriptionError;\n//# sourceMappingURL=UnsubscriptionError.js.map\n\n//# sourceURL=webpack:///./node_modules/electron-compile/node_modules/rxjs/util/UnsubscriptionError.js?")},"./node_modules/electron-compile/node_modules/rxjs/util/errorObject.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/electron-compile/node_modules/rxjs/util/errorObject.js ***!
  \*****************************************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){"use strict";eval("\n// typeof any so that it we don't have to cast when comparing a result to the error object\nexports.errorObject = { e: {} };\n//# sourceMappingURL=errorObject.js.map\n\n//# sourceURL=webpack:///./node_modules/electron-compile/node_modules/rxjs/util/errorObject.js?")},"./node_modules/electron-compile/node_modules/rxjs/util/identity.js":
/*!**************************************************************************!*\
  !*** ./node_modules/electron-compile/node_modules/rxjs/util/identity.js ***!
  \**************************************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){"use strict";eval("\nfunction identity(x) {\n    return x;\n}\nexports.identity = identity;\n//# sourceMappingURL=identity.js.map\n\n//# sourceURL=webpack:///./node_modules/electron-compile/node_modules/rxjs/util/identity.js?")},"./node_modules/electron-compile/node_modules/rxjs/util/isArray.js":
/*!*************************************************************************!*\
  !*** ./node_modules/electron-compile/node_modules/rxjs/util/isArray.js ***!
  \*************************************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){"use strict";eval("\nexports.isArray = Array.isArray || (function (x) { return x && typeof x.length === 'number'; });\n//# sourceMappingURL=isArray.js.map\n\n//# sourceURL=webpack:///./node_modules/electron-compile/node_modules/rxjs/util/isArray.js?")},"./node_modules/electron-compile/node_modules/rxjs/util/isArrayLike.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/electron-compile/node_modules/rxjs/util/isArrayLike.js ***!
  \*****************************************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){"use strict";eval("\nexports.isArrayLike = (function (x) { return x && typeof x.length === 'number'; });\n//# sourceMappingURL=isArrayLike.js.map\n\n//# sourceURL=webpack:///./node_modules/electron-compile/node_modules/rxjs/util/isArrayLike.js?")},"./node_modules/electron-compile/node_modules/rxjs/util/isDate.js":
/*!************************************************************************!*\
  !*** ./node_modules/electron-compile/node_modules/rxjs/util/isDate.js ***!
  \************************************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){"use strict";eval("\nfunction isDate(value) {\n    return value instanceof Date && !isNaN(+value);\n}\nexports.isDate = isDate;\n//# sourceMappingURL=isDate.js.map\n\n//# sourceURL=webpack:///./node_modules/electron-compile/node_modules/rxjs/util/isDate.js?")},"./node_modules/electron-compile/node_modules/rxjs/util/isFunction.js":
/*!****************************************************************************!*\
  !*** ./node_modules/electron-compile/node_modules/rxjs/util/isFunction.js ***!
  \****************************************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){"use strict";eval("\nfunction isFunction(x) {\n    return typeof x === 'function';\n}\nexports.isFunction = isFunction;\n//# sourceMappingURL=isFunction.js.map\n\n//# sourceURL=webpack:///./node_modules/electron-compile/node_modules/rxjs/util/isFunction.js?")},"./node_modules/electron-compile/node_modules/rxjs/util/isNumeric.js":
/*!***************************************************************************!*\
  !*** ./node_modules/electron-compile/node_modules/rxjs/util/isNumeric.js ***!
  \***************************************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){"use strict";eval('\nvar isArray_1 = __webpack_require__(/*! ../util/isArray */ "./node_modules/electron-compile/node_modules/rxjs/util/isArray.js");\nfunction isNumeric(val) {\n    // parseFloat NaNs numeric-cast false positives (null|true|false|"")\n    // ...but misinterprets leading-number strings, particularly hex literals ("0x...")\n    // subtraction forces infinities to NaN\n    // adding 1 corrects loss of precision from parseFloat (#15100)\n    return !isArray_1.isArray(val) && (val - parseFloat(val) + 1) >= 0;\n}\nexports.isNumeric = isNumeric;\n;\n//# sourceMappingURL=isNumeric.js.map\n\n//# sourceURL=webpack:///./node_modules/electron-compile/node_modules/rxjs/util/isNumeric.js?')},"./node_modules/electron-compile/node_modules/rxjs/util/isObject.js":
/*!**************************************************************************!*\
  !*** ./node_modules/electron-compile/node_modules/rxjs/util/isObject.js ***!
  \**************************************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){"use strict";eval("\nfunction isObject(x) {\n    return x != null && typeof x === 'object';\n}\nexports.isObject = isObject;\n//# sourceMappingURL=isObject.js.map\n\n//# sourceURL=webpack:///./node_modules/electron-compile/node_modules/rxjs/util/isObject.js?")},"./node_modules/electron-compile/node_modules/rxjs/util/isPromise.js":
/*!***************************************************************************!*\
  !*** ./node_modules/electron-compile/node_modules/rxjs/util/isPromise.js ***!
  \***************************************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){"use strict";eval("\nfunction isPromise(value) {\n    return value && typeof value.subscribe !== 'function' && typeof value.then === 'function';\n}\nexports.isPromise = isPromise;\n//# sourceMappingURL=isPromise.js.map\n\n//# sourceURL=webpack:///./node_modules/electron-compile/node_modules/rxjs/util/isPromise.js?")},"./node_modules/electron-compile/node_modules/rxjs/util/isScheduler.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/electron-compile/node_modules/rxjs/util/isScheduler.js ***!
  \*****************************************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){"use strict";eval("\nfunction isScheduler(value) {\n    return value && typeof value.schedule === 'function';\n}\nexports.isScheduler = isScheduler;\n//# sourceMappingURL=isScheduler.js.map\n\n//# sourceURL=webpack:///./node_modules/electron-compile/node_modules/rxjs/util/isScheduler.js?")},"./node_modules/electron-compile/node_modules/rxjs/util/noop.js":
/*!**********************************************************************!*\
  !*** ./node_modules/electron-compile/node_modules/rxjs/util/noop.js ***!
  \**********************************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){"use strict";eval("\n/* tslint:disable:no-empty */\nfunction noop() { }\nexports.noop = noop;\n//# sourceMappingURL=noop.js.map\n\n//# sourceURL=webpack:///./node_modules/electron-compile/node_modules/rxjs/util/noop.js?")},"./node_modules/electron-compile/node_modules/rxjs/util/pipe.js":
/*!**********************************************************************!*\
  !*** ./node_modules/electron-compile/node_modules/rxjs/util/pipe.js ***!
  \**********************************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){"use strict";eval('\nvar noop_1 = __webpack_require__(/*! ./noop */ "./node_modules/electron-compile/node_modules/rxjs/util/noop.js");\n/* tslint:enable:max-line-length */\nfunction pipe() {\n    var fns = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        fns[_i - 0] = arguments[_i];\n    }\n    return pipeFromArray(fns);\n}\nexports.pipe = pipe;\n/* @internal */\nfunction pipeFromArray(fns) {\n    if (!fns) {\n        return noop_1.noop;\n    }\n    if (fns.length === 1) {\n        return fns[0];\n    }\n    return function piped(input) {\n        return fns.reduce(function (prev, fn) { return fn(prev); }, input);\n    };\n}\nexports.pipeFromArray = pipeFromArray;\n//# sourceMappingURL=pipe.js.map\n\n//# sourceURL=webpack:///./node_modules/electron-compile/node_modules/rxjs/util/pipe.js?')},"./node_modules/electron-compile/node_modules/rxjs/util/root.js":
/*!**********************************************************************!*\
  !*** ./node_modules/electron-compile/node_modules/rxjs/util/root.js ***!
  \**********************************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){"use strict";eval("\n// CommonJS / Node have global context exposed as \"global\" variable.\n// We don't want to include the whole node.d.ts this this compilation unit so we'll just fake\n// the global \"global\" var for now.\nvar __window = typeof window !== 'undefined' && window;\nvar __self = typeof self !== 'undefined' && typeof WorkerGlobalScope !== 'undefined' &&\n    self instanceof WorkerGlobalScope && self;\nvar __global = typeof global !== 'undefined' && global;\nvar _root = __window || __global || __self;\nexports.root = _root;\n// Workaround Closure Compiler restriction: The body of a goog.module cannot use throw.\n// This is needed when used with angular/tsickle which inserts a goog.module statement.\n// Wrap in IIFE\n(function () {\n    if (!_root) {\n        throw new Error('RxJS could not find any global context (window, self, global)');\n    }\n})();\n//# sourceMappingURL=root.js.map\n\n//# sourceURL=webpack:///./node_modules/electron-compile/node_modules/rxjs/util/root.js?")},"./node_modules/electron-compile/node_modules/rxjs/util/subscribeToResult.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/electron-compile/node_modules/rxjs/util/subscribeToResult.js ***!
  \***********************************************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){"use strict";eval('\nvar root_1 = __webpack_require__(/*! ./root */ "./node_modules/electron-compile/node_modules/rxjs/util/root.js");\nvar isArrayLike_1 = __webpack_require__(/*! ./isArrayLike */ "./node_modules/electron-compile/node_modules/rxjs/util/isArrayLike.js");\nvar isPromise_1 = __webpack_require__(/*! ./isPromise */ "./node_modules/electron-compile/node_modules/rxjs/util/isPromise.js");\nvar isObject_1 = __webpack_require__(/*! ./isObject */ "./node_modules/electron-compile/node_modules/rxjs/util/isObject.js");\nvar Observable_1 = __webpack_require__(/*! ../Observable */ "./node_modules/electron-compile/node_modules/rxjs/Observable.js");\nvar iterator_1 = __webpack_require__(/*! ../symbol/iterator */ "./node_modules/electron-compile/node_modules/rxjs/symbol/iterator.js");\nvar InnerSubscriber_1 = __webpack_require__(/*! ../InnerSubscriber */ "./node_modules/electron-compile/node_modules/rxjs/InnerSubscriber.js");\nvar observable_1 = __webpack_require__(/*! ../symbol/observable */ "./node_modules/electron-compile/node_modules/rxjs/symbol/observable.js");\nfunction subscribeToResult(outerSubscriber, result, outerValue, outerIndex) {\n    var destination = new InnerSubscriber_1.InnerSubscriber(outerSubscriber, outerValue, outerIndex);\n    if (destination.closed) {\n        return null;\n    }\n    if (result instanceof Observable_1.Observable) {\n        if (result._isScalar) {\n            destination.next(result.value);\n            destination.complete();\n            return null;\n        }\n        else {\n            destination.syncErrorThrowable = true;\n            return result.subscribe(destination);\n        }\n    }\n    else if (isArrayLike_1.isArrayLike(result)) {\n        for (var i = 0, len = result.length; i < len && !destination.closed; i++) {\n            destination.next(result[i]);\n        }\n        if (!destination.closed) {\n            destination.complete();\n        }\n    }\n    else if (isPromise_1.isPromise(result)) {\n        result.then(function (value) {\n            if (!destination.closed) {\n                destination.next(value);\n                destination.complete();\n            }\n        }, function (err) { return destination.error(err); })\n            .then(null, function (err) {\n            // Escaping the Promise trap: globally throw unhandled errors\n            root_1.root.setTimeout(function () { throw err; });\n        });\n        return destination;\n    }\n    else if (result && typeof result[iterator_1.iterator] === \'function\') {\n        var iterator = result[iterator_1.iterator]();\n        do {\n            var item = iterator.next();\n            if (item.done) {\n                destination.complete();\n                break;\n            }\n            destination.next(item.value);\n            if (destination.closed) {\n                break;\n            }\n        } while (true);\n    }\n    else if (result && typeof result[observable_1.observable] === \'function\') {\n        var obs = result[observable_1.observable]();\n        if (typeof obs.subscribe !== \'function\') {\n            destination.error(new TypeError(\'Provided object does not correctly implement Symbol.observable\'));\n        }\n        else {\n            return obs.subscribe(new InnerSubscriber_1.InnerSubscriber(outerSubscriber, outerValue, outerIndex));\n        }\n    }\n    else {\n        var value = isObject_1.isObject(result) ? \'an invalid object\' : "\'" + result + "\'";\n        var msg = ("You provided " + value + " where a stream was expected.")\n            + \' You can provide an Observable, Promise, Array, or Iterable.\';\n        destination.error(new TypeError(msg));\n    }\n    return null;\n}\nexports.subscribeToResult = subscribeToResult;\n//# sourceMappingURL=subscribeToResult.js.map\n\n//# sourceURL=webpack:///./node_modules/electron-compile/node_modules/rxjs/util/subscribeToResult.js?')},"./node_modules/electron-compile/node_modules/rxjs/util/toSubscriber.js":
/*!******************************************************************************!*\
  !*** ./node_modules/electron-compile/node_modules/rxjs/util/toSubscriber.js ***!
  \******************************************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){"use strict";eval('\nvar Subscriber_1 = __webpack_require__(/*! ../Subscriber */ "./node_modules/electron-compile/node_modules/rxjs/Subscriber.js");\nvar rxSubscriber_1 = __webpack_require__(/*! ../symbol/rxSubscriber */ "./node_modules/electron-compile/node_modules/rxjs/symbol/rxSubscriber.js");\nvar Observer_1 = __webpack_require__(/*! ../Observer */ "./node_modules/electron-compile/node_modules/rxjs/Observer.js");\nfunction toSubscriber(nextOrObserver, error, complete) {\n    if (nextOrObserver) {\n        if (nextOrObserver instanceof Subscriber_1.Subscriber) {\n            return nextOrObserver;\n        }\n        if (nextOrObserver[rxSubscriber_1.rxSubscriber]) {\n            return nextOrObserver[rxSubscriber_1.rxSubscriber]();\n        }\n    }\n    if (!nextOrObserver && !error && !complete) {\n        return new Subscriber_1.Subscriber(Observer_1.empty);\n    }\n    return new Subscriber_1.Subscriber(nextOrObserver, error, complete);\n}\nexports.toSubscriber = toSubscriber;\n//# sourceMappingURL=toSubscriber.js.map\n\n//# sourceURL=webpack:///./node_modules/electron-compile/node_modules/rxjs/util/toSubscriber.js?')},"./node_modules/electron-compile/node_modules/rxjs/util/tryCatch.js":
/*!**************************************************************************!*\
  !*** ./node_modules/electron-compile/node_modules/rxjs/util/tryCatch.js ***!
  \**************************************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){"use strict";eval('\nvar errorObject_1 = __webpack_require__(/*! ./errorObject */ "./node_modules/electron-compile/node_modules/rxjs/util/errorObject.js");\nvar tryCatchTarget;\nfunction tryCatcher() {\n    try {\n        return tryCatchTarget.apply(this, arguments);\n    }\n    catch (e) {\n        errorObject_1.errorObject.e = e;\n        return errorObject_1.errorObject;\n    }\n}\nfunction tryCatch(fn) {\n    tryCatchTarget = fn;\n    return tryCatcher;\n}\nexports.tryCatch = tryCatch;\n;\n//# sourceMappingURL=tryCatch.js.map\n\n//# sourceURL=webpack:///./node_modules/electron-compile/node_modules/rxjs/util/tryCatch.js?')},"./node_modules/lru-cache/index.js":
/*!*****************************************!*\
  !*** ./node_modules/lru-cache/index.js ***!
  \*****************************************/
/*! no static exports found */function(module,exports,__webpack_require__){"use strict";eval("\n\nmodule.exports = LRUCache\n\n// This will be a proper iterable 'Map' in engines that support it,\n// or a fakey-fake PseudoMap in older versions.\nvar Map = __webpack_require__(/*! pseudomap */ \"./node_modules/pseudomap/map.js\")\nvar util = __webpack_require__(/*! util */ \"util\")\n\n// A linked list to keep track of recently-used-ness\nvar Yallist = __webpack_require__(/*! yallist */ \"./node_modules/lru-cache/node_modules/yallist/yallist.js\")\n\n// use symbols if possible, otherwise just _props\nvar hasSymbol = typeof Symbol === 'function' && process.env._nodeLRUCacheForceNoSymbol !== '1'\nvar makeSymbol\nif (hasSymbol) {\n  makeSymbol = function (key) {\n    return Symbol(key)\n  }\n} else {\n  makeSymbol = function (key) {\n    return '_' + key\n  }\n}\n\nvar MAX = makeSymbol('max')\nvar LENGTH = makeSymbol('length')\nvar LENGTH_CALCULATOR = makeSymbol('lengthCalculator')\nvar ALLOW_STALE = makeSymbol('allowStale')\nvar MAX_AGE = makeSymbol('maxAge')\nvar DISPOSE = makeSymbol('dispose')\nvar NO_DISPOSE_ON_SET = makeSymbol('noDisposeOnSet')\nvar LRU_LIST = makeSymbol('lruList')\nvar CACHE = makeSymbol('cache')\n\nfunction naiveLength () { return 1 }\n\n// lruList is a yallist where the head is the youngest\n// item, and the tail is the oldest.  the list contains the Hit\n// objects as the entries.\n// Each Hit object has a reference to its Yallist.Node.  This\n// never changes.\n//\n// cache is a Map (or PseudoMap) that matches the keys to\n// the Yallist.Node object.\nfunction LRUCache (options) {\n  if (!(this instanceof LRUCache)) {\n    return new LRUCache(options)\n  }\n\n  if (typeof options === 'number') {\n    options = { max: options }\n  }\n\n  if (!options) {\n    options = {}\n  }\n\n  var max = this[MAX] = options.max\n  // Kind of weird to have a default max of Infinity, but oh well.\n  if (!max ||\n      !(typeof max === 'number') ||\n      max <= 0) {\n    this[MAX] = Infinity\n  }\n\n  var lc = options.length || naiveLength\n  if (typeof lc !== 'function') {\n    lc = naiveLength\n  }\n  this[LENGTH_CALCULATOR] = lc\n\n  this[ALLOW_STALE] = options.stale || false\n  this[MAX_AGE] = options.maxAge || 0\n  this[DISPOSE] = options.dispose\n  this[NO_DISPOSE_ON_SET] = options.noDisposeOnSet || false\n  this.reset()\n}\n\n// resize the cache when the max changes.\nObject.defineProperty(LRUCache.prototype, 'max', {\n  set: function (mL) {\n    if (!mL || !(typeof mL === 'number') || mL <= 0) {\n      mL = Infinity\n    }\n    this[MAX] = mL\n    trim(this)\n  },\n  get: function () {\n    return this[MAX]\n  },\n  enumerable: true\n})\n\nObject.defineProperty(LRUCache.prototype, 'allowStale', {\n  set: function (allowStale) {\n    this[ALLOW_STALE] = !!allowStale\n  },\n  get: function () {\n    return this[ALLOW_STALE]\n  },\n  enumerable: true\n})\n\nObject.defineProperty(LRUCache.prototype, 'maxAge', {\n  set: function (mA) {\n    if (!mA || !(typeof mA === 'number') || mA < 0) {\n      mA = 0\n    }\n    this[MAX_AGE] = mA\n    trim(this)\n  },\n  get: function () {\n    return this[MAX_AGE]\n  },\n  enumerable: true\n})\n\n// resize the cache when the lengthCalculator changes.\nObject.defineProperty(LRUCache.prototype, 'lengthCalculator', {\n  set: function (lC) {\n    if (typeof lC !== 'function') {\n      lC = naiveLength\n    }\n    if (lC !== this[LENGTH_CALCULATOR]) {\n      this[LENGTH_CALCULATOR] = lC\n      this[LENGTH] = 0\n      this[LRU_LIST].forEach(function (hit) {\n        hit.length = this[LENGTH_CALCULATOR](hit.value, hit.key)\n        this[LENGTH] += hit.length\n      }, this)\n    }\n    trim(this)\n  },\n  get: function () { return this[LENGTH_CALCULATOR] },\n  enumerable: true\n})\n\nObject.defineProperty(LRUCache.prototype, 'length', {\n  get: function () { return this[LENGTH] },\n  enumerable: true\n})\n\nObject.defineProperty(LRUCache.prototype, 'itemCount', {\n  get: function () { return this[LRU_LIST].length },\n  enumerable: true\n})\n\nLRUCache.prototype.rforEach = function (fn, thisp) {\n  thisp = thisp || this\n  for (var walker = this[LRU_LIST].tail; walker !== null;) {\n    var prev = walker.prev\n    forEachStep(this, fn, walker, thisp)\n    walker = prev\n  }\n}\n\nfunction forEachStep (self, fn, node, thisp) {\n  var hit = node.value\n  if (isStale(self, hit)) {\n    del(self, node)\n    if (!self[ALLOW_STALE]) {\n      hit = undefined\n    }\n  }\n  if (hit) {\n    fn.call(thisp, hit.value, hit.key, self)\n  }\n}\n\nLRUCache.prototype.forEach = function (fn, thisp) {\n  thisp = thisp || this\n  for (var walker = this[LRU_LIST].head; walker !== null;) {\n    var next = walker.next\n    forEachStep(this, fn, walker, thisp)\n    walker = next\n  }\n}\n\nLRUCache.prototype.keys = function () {\n  return this[LRU_LIST].toArray().map(function (k) {\n    return k.key\n  }, this)\n}\n\nLRUCache.prototype.values = function () {\n  return this[LRU_LIST].toArray().map(function (k) {\n    return k.value\n  }, this)\n}\n\nLRUCache.prototype.reset = function () {\n  if (this[DISPOSE] &&\n      this[LRU_LIST] &&\n      this[LRU_LIST].length) {\n    this[LRU_LIST].forEach(function (hit) {\n      this[DISPOSE](hit.key, hit.value)\n    }, this)\n  }\n\n  this[CACHE] = new Map() // hash of items by key\n  this[LRU_LIST] = new Yallist() // list of items in order of use recency\n  this[LENGTH] = 0 // length of items in the list\n}\n\nLRUCache.prototype.dump = function () {\n  return this[LRU_LIST].map(function (hit) {\n    if (!isStale(this, hit)) {\n      return {\n        k: hit.key,\n        v: hit.value,\n        e: hit.now + (hit.maxAge || 0)\n      }\n    }\n  }, this).toArray().filter(function (h) {\n    return h\n  })\n}\n\nLRUCache.prototype.dumpLru = function () {\n  return this[LRU_LIST]\n}\n\n/* istanbul ignore next */\nLRUCache.prototype.inspect = function (n, opts) {\n  var str = 'LRUCache {'\n  var extras = false\n\n  var as = this[ALLOW_STALE]\n  if (as) {\n    str += '\\n  allowStale: true'\n    extras = true\n  }\n\n  var max = this[MAX]\n  if (max && max !== Infinity) {\n    if (extras) {\n      str += ','\n    }\n    str += '\\n  max: ' + util.inspect(max, opts)\n    extras = true\n  }\n\n  var maxAge = this[MAX_AGE]\n  if (maxAge) {\n    if (extras) {\n      str += ','\n    }\n    str += '\\n  maxAge: ' + util.inspect(maxAge, opts)\n    extras = true\n  }\n\n  var lc = this[LENGTH_CALCULATOR]\n  if (lc && lc !== naiveLength) {\n    if (extras) {\n      str += ','\n    }\n    str += '\\n  length: ' + util.inspect(this[LENGTH], opts)\n    extras = true\n  }\n\n  var didFirst = false\n  this[LRU_LIST].forEach(function (item) {\n    if (didFirst) {\n      str += ',\\n  '\n    } else {\n      if (extras) {\n        str += ',\\n'\n      }\n      didFirst = true\n      str += '\\n  '\n    }\n    var key = util.inspect(item.key).split('\\n').join('\\n  ')\n    var val = { value: item.value }\n    if (item.maxAge !== maxAge) {\n      val.maxAge = item.maxAge\n    }\n    if (lc !== naiveLength) {\n      val.length = item.length\n    }\n    if (isStale(this, item)) {\n      val.stale = true\n    }\n\n    val = util.inspect(val, opts).split('\\n').join('\\n  ')\n    str += key + ' => ' + val\n  })\n\n  if (didFirst || extras) {\n    str += '\\n'\n  }\n  str += '}'\n\n  return str\n}\n\nLRUCache.prototype.set = function (key, value, maxAge) {\n  maxAge = maxAge || this[MAX_AGE]\n\n  var now = maxAge ? Date.now() : 0\n  var len = this[LENGTH_CALCULATOR](value, key)\n\n  if (this[CACHE].has(key)) {\n    if (len > this[MAX]) {\n      del(this, this[CACHE].get(key))\n      return false\n    }\n\n    var node = this[CACHE].get(key)\n    var item = node.value\n\n    // dispose of the old one before overwriting\n    // split out into 2 ifs for better coverage tracking\n    if (this[DISPOSE]) {\n      if (!this[NO_DISPOSE_ON_SET]) {\n        this[DISPOSE](key, item.value)\n      }\n    }\n\n    item.now = now\n    item.maxAge = maxAge\n    item.value = value\n    this[LENGTH] += len - item.length\n    item.length = len\n    this.get(key)\n    trim(this)\n    return true\n  }\n\n  var hit = new Entry(key, value, len, now, maxAge)\n\n  // oversized objects fall out of cache automatically.\n  if (hit.length > this[MAX]) {\n    if (this[DISPOSE]) {\n      this[DISPOSE](key, value)\n    }\n    return false\n  }\n\n  this[LENGTH] += hit.length\n  this[LRU_LIST].unshift(hit)\n  this[CACHE].set(key, this[LRU_LIST].head)\n  trim(this)\n  return true\n}\n\nLRUCache.prototype.has = function (key) {\n  if (!this[CACHE].has(key)) return false\n  var hit = this[CACHE].get(key).value\n  if (isStale(this, hit)) {\n    return false\n  }\n  return true\n}\n\nLRUCache.prototype.get = function (key) {\n  return get(this, key, true)\n}\n\nLRUCache.prototype.peek = function (key) {\n  return get(this, key, false)\n}\n\nLRUCache.prototype.pop = function () {\n  var node = this[LRU_LIST].tail\n  if (!node) return null\n  del(this, node)\n  return node.value\n}\n\nLRUCache.prototype.del = function (key) {\n  del(this, this[CACHE].get(key))\n}\n\nLRUCache.prototype.load = function (arr) {\n  // reset the cache\n  this.reset()\n\n  var now = Date.now()\n  // A previous serialized cache has the most recent items first\n  for (var l = arr.length - 1; l >= 0; l--) {\n    var hit = arr[l]\n    var expiresAt = hit.e || 0\n    if (expiresAt === 0) {\n      // the item was created without expiration in a non aged cache\n      this.set(hit.k, hit.v)\n    } else {\n      var maxAge = expiresAt - now\n      // dont add already expired items\n      if (maxAge > 0) {\n        this.set(hit.k, hit.v, maxAge)\n      }\n    }\n  }\n}\n\nLRUCache.prototype.prune = function () {\n  var self = this\n  this[CACHE].forEach(function (value, key) {\n    get(self, key, false)\n  })\n}\n\nfunction get (self, key, doUse) {\n  var node = self[CACHE].get(key)\n  if (node) {\n    var hit = node.value\n    if (isStale(self, hit)) {\n      del(self, node)\n      if (!self[ALLOW_STALE]) hit = undefined\n    } else {\n      if (doUse) {\n        self[LRU_LIST].unshiftNode(node)\n      }\n    }\n    if (hit) hit = hit.value\n  }\n  return hit\n}\n\nfunction isStale (self, hit) {\n  if (!hit || (!hit.maxAge && !self[MAX_AGE])) {\n    return false\n  }\n  var stale = false\n  var diff = Date.now() - hit.now\n  if (hit.maxAge) {\n    stale = diff > hit.maxAge\n  } else {\n    stale = self[MAX_AGE] && (diff > self[MAX_AGE])\n  }\n  return stale\n}\n\nfunction trim (self) {\n  if (self[LENGTH] > self[MAX]) {\n    for (var walker = self[LRU_LIST].tail;\n      self[LENGTH] > self[MAX] && walker !== null;) {\n      // We know that we're about to delete this one, and also\n      // what the next least recently used key will be, so just\n      // go ahead and set it now.\n      var prev = walker.prev\n      del(self, walker)\n      walker = prev\n    }\n  }\n}\n\nfunction del (self, node) {\n  if (node) {\n    var hit = node.value\n    if (self[DISPOSE]) {\n      self[DISPOSE](hit.key, hit.value)\n    }\n    self[LENGTH] -= hit.length\n    self[CACHE].delete(hit.key)\n    self[LRU_LIST].removeNode(node)\n  }\n}\n\n// classy, since V8 prefers predictable objects.\nfunction Entry (key, value, length, now, maxAge) {\n  this.key = key\n  this.value = value\n  this.length = length\n  this.now = now\n  this.maxAge = maxAge || 0\n}\n\n\n//# sourceURL=webpack:///./node_modules/lru-cache/index.js?")},"./node_modules/lru-cache/node_modules/yallist/yallist.js":
/*!****************************************************************!*\
  !*** ./node_modules/lru-cache/node_modules/yallist/yallist.js ***!
  \****************************************************************/
/*! no static exports found */function(module,exports){eval("module.exports = Yallist\n\nYallist.Node = Node\nYallist.create = Yallist\n\nfunction Yallist (list) {\n  var self = this\n  if (!(self instanceof Yallist)) {\n    self = new Yallist()\n  }\n\n  self.tail = null\n  self.head = null\n  self.length = 0\n\n  if (list && typeof list.forEach === 'function') {\n    list.forEach(function (item) {\n      self.push(item)\n    })\n  } else if (arguments.length > 0) {\n    for (var i = 0, l = arguments.length; i < l; i++) {\n      self.push(arguments[i])\n    }\n  }\n\n  return self\n}\n\nYallist.prototype.removeNode = function (node) {\n  if (node.list !== this) {\n    throw new Error('removing node which does not belong to this list')\n  }\n\n  var next = node.next\n  var prev = node.prev\n\n  if (next) {\n    next.prev = prev\n  }\n\n  if (prev) {\n    prev.next = next\n  }\n\n  if (node === this.head) {\n    this.head = next\n  }\n  if (node === this.tail) {\n    this.tail = prev\n  }\n\n  node.list.length--\n  node.next = null\n  node.prev = null\n  node.list = null\n}\n\nYallist.prototype.unshiftNode = function (node) {\n  if (node === this.head) {\n    return\n  }\n\n  if (node.list) {\n    node.list.removeNode(node)\n  }\n\n  var head = this.head\n  node.list = this\n  node.next = head\n  if (head) {\n    head.prev = node\n  }\n\n  this.head = node\n  if (!this.tail) {\n    this.tail = node\n  }\n  this.length++\n}\n\nYallist.prototype.pushNode = function (node) {\n  if (node === this.tail) {\n    return\n  }\n\n  if (node.list) {\n    node.list.removeNode(node)\n  }\n\n  var tail = this.tail\n  node.list = this\n  node.prev = tail\n  if (tail) {\n    tail.next = node\n  }\n\n  this.tail = node\n  if (!this.head) {\n    this.head = node\n  }\n  this.length++\n}\n\nYallist.prototype.push = function () {\n  for (var i = 0, l = arguments.length; i < l; i++) {\n    push(this, arguments[i])\n  }\n  return this.length\n}\n\nYallist.prototype.unshift = function () {\n  for (var i = 0, l = arguments.length; i < l; i++) {\n    unshift(this, arguments[i])\n  }\n  return this.length\n}\n\nYallist.prototype.pop = function () {\n  if (!this.tail) {\n    return undefined\n  }\n\n  var res = this.tail.value\n  this.tail = this.tail.prev\n  if (this.tail) {\n    this.tail.next = null\n  } else {\n    this.head = null\n  }\n  this.length--\n  return res\n}\n\nYallist.prototype.shift = function () {\n  if (!this.head) {\n    return undefined\n  }\n\n  var res = this.head.value\n  this.head = this.head.next\n  if (this.head) {\n    this.head.prev = null\n  } else {\n    this.tail = null\n  }\n  this.length--\n  return res\n}\n\nYallist.prototype.forEach = function (fn, thisp) {\n  thisp = thisp || this\n  for (var walker = this.head, i = 0; walker !== null; i++) {\n    fn.call(thisp, walker.value, i, this)\n    walker = walker.next\n  }\n}\n\nYallist.prototype.forEachReverse = function (fn, thisp) {\n  thisp = thisp || this\n  for (var walker = this.tail, i = this.length - 1; walker !== null; i--) {\n    fn.call(thisp, walker.value, i, this)\n    walker = walker.prev\n  }\n}\n\nYallist.prototype.get = function (n) {\n  for (var i = 0, walker = this.head; walker !== null && i < n; i++) {\n    // abort out of the list early if we hit a cycle\n    walker = walker.next\n  }\n  if (i === n && walker !== null) {\n    return walker.value\n  }\n}\n\nYallist.prototype.getReverse = function (n) {\n  for (var i = 0, walker = this.tail; walker !== null && i < n; i++) {\n    // abort out of the list early if we hit a cycle\n    walker = walker.prev\n  }\n  if (i === n && walker !== null) {\n    return walker.value\n  }\n}\n\nYallist.prototype.map = function (fn, thisp) {\n  thisp = thisp || this\n  var res = new Yallist()\n  for (var walker = this.head; walker !== null;) {\n    res.push(fn.call(thisp, walker.value, this))\n    walker = walker.next\n  }\n  return res\n}\n\nYallist.prototype.mapReverse = function (fn, thisp) {\n  thisp = thisp || this\n  var res = new Yallist()\n  for (var walker = this.tail; walker !== null;) {\n    res.push(fn.call(thisp, walker.value, this))\n    walker = walker.prev\n  }\n  return res\n}\n\nYallist.prototype.reduce = function (fn, initial) {\n  var acc\n  var walker = this.head\n  if (arguments.length > 1) {\n    acc = initial\n  } else if (this.head) {\n    walker = this.head.next\n    acc = this.head.value\n  } else {\n    throw new TypeError('Reduce of empty list with no initial value')\n  }\n\n  for (var i = 0; walker !== null; i++) {\n    acc = fn(acc, walker.value, i)\n    walker = walker.next\n  }\n\n  return acc\n}\n\nYallist.prototype.reduceReverse = function (fn, initial) {\n  var acc\n  var walker = this.tail\n  if (arguments.length > 1) {\n    acc = initial\n  } else if (this.tail) {\n    walker = this.tail.prev\n    acc = this.tail.value\n  } else {\n    throw new TypeError('Reduce of empty list with no initial value')\n  }\n\n  for (var i = this.length - 1; walker !== null; i--) {\n    acc = fn(acc, walker.value, i)\n    walker = walker.prev\n  }\n\n  return acc\n}\n\nYallist.prototype.toArray = function () {\n  var arr = new Array(this.length)\n  for (var i = 0, walker = this.head; walker !== null; i++) {\n    arr[i] = walker.value\n    walker = walker.next\n  }\n  return arr\n}\n\nYallist.prototype.toArrayReverse = function () {\n  var arr = new Array(this.length)\n  for (var i = 0, walker = this.tail; walker !== null; i++) {\n    arr[i] = walker.value\n    walker = walker.prev\n  }\n  return arr\n}\n\nYallist.prototype.slice = function (from, to) {\n  to = to || this.length\n  if (to < 0) {\n    to += this.length\n  }\n  from = from || 0\n  if (from < 0) {\n    from += this.length\n  }\n  var ret = new Yallist()\n  if (to < from || to < 0) {\n    return ret\n  }\n  if (from < 0) {\n    from = 0\n  }\n  if (to > this.length) {\n    to = this.length\n  }\n  for (var i = 0, walker = this.head; walker !== null && i < from; i++) {\n    walker = walker.next\n  }\n  for (; walker !== null && i < to; i++, walker = walker.next) {\n    ret.push(walker.value)\n  }\n  return ret\n}\n\nYallist.prototype.sliceReverse = function (from, to) {\n  to = to || this.length\n  if (to < 0) {\n    to += this.length\n  }\n  from = from || 0\n  if (from < 0) {\n    from += this.length\n  }\n  var ret = new Yallist()\n  if (to < from || to < 0) {\n    return ret\n  }\n  if (from < 0) {\n    from = 0\n  }\n  if (to > this.length) {\n    to = this.length\n  }\n  for (var i = this.length, walker = this.tail; walker !== null && i > to; i--) {\n    walker = walker.prev\n  }\n  for (; walker !== null && i > from; i--, walker = walker.prev) {\n    ret.push(walker.value)\n  }\n  return ret\n}\n\nYallist.prototype.reverse = function () {\n  var head = this.head\n  var tail = this.tail\n  for (var walker = head; walker !== null; walker = walker.prev) {\n    var p = walker.prev\n    walker.prev = walker.next\n    walker.next = p\n  }\n  this.head = tail\n  this.tail = head\n  return this\n}\n\nfunction push (self, item) {\n  self.tail = new Node(item, self.tail, null, self)\n  if (!self.head) {\n    self.head = self.tail\n  }\n  self.length++\n}\n\nfunction unshift (self, item) {\n  self.head = new Node(item, null, self.head, self)\n  if (!self.tail) {\n    self.tail = self.head\n  }\n  self.length++\n}\n\nfunction Node (value, prev, next, list) {\n  if (!(this instanceof Node)) {\n    return new Node(value, prev, next, list)\n  }\n\n  this.list = list\n  this.value = value\n\n  if (prev) {\n    prev.next = this\n    this.prev = prev\n  } else {\n    this.prev = null\n  }\n\n  if (next) {\n    next.prev = this\n    this.next = next\n  } else {\n    this.next = null\n  }\n}\n\n\n//# sourceURL=webpack:///./node_modules/lru-cache/node_modules/yallist/yallist.js?")},"./node_modules/mkdirp/index.js":
/*!**************************************!*\
  !*** ./node_modules/mkdirp/index.js ***!
  \**************************************/
/*! no static exports found */function(module,exports,__webpack_require__){eval("var path = __webpack_require__(/*! path */ \"path\");\nvar fs = __webpack_require__(/*! fs */ \"fs\");\nvar _0777 = parseInt('0777', 8);\n\nmodule.exports = mkdirP.mkdirp = mkdirP.mkdirP = mkdirP;\n\nfunction mkdirP (p, opts, f, made) {\n    if (typeof opts === 'function') {\n        f = opts;\n        opts = {};\n    }\n    else if (!opts || typeof opts !== 'object') {\n        opts = { mode: opts };\n    }\n    \n    var mode = opts.mode;\n    var xfs = opts.fs || fs;\n    \n    if (mode === undefined) {\n        mode = _0777 & (~process.umask());\n    }\n    if (!made) made = null;\n    \n    var cb = f || function () {};\n    p = path.resolve(p);\n    \n    xfs.mkdir(p, mode, function (er) {\n        if (!er) {\n            made = made || p;\n            return cb(null, made);\n        }\n        switch (er.code) {\n            case 'ENOENT':\n                mkdirP(path.dirname(p), opts, function (er, made) {\n                    if (er) cb(er, made);\n                    else mkdirP(p, opts, cb, made);\n                });\n                break;\n\n            // In the case of any other error, just see if there's a dir\n            // there already.  If so, then hooray!  If not, then something\n            // is borked.\n            default:\n                xfs.stat(p, function (er2, stat) {\n                    // if the stat fails, then that's super weird.\n                    // let the original error be the failure reason.\n                    if (er2 || !stat.isDirectory()) cb(er, made)\n                    else cb(null, made);\n                });\n                break;\n        }\n    });\n}\n\nmkdirP.sync = function sync (p, opts, made) {\n    if (!opts || typeof opts !== 'object') {\n        opts = { mode: opts };\n    }\n    \n    var mode = opts.mode;\n    var xfs = opts.fs || fs;\n    \n    if (mode === undefined) {\n        mode = _0777 & (~process.umask());\n    }\n    if (!made) made = null;\n\n    p = path.resolve(p);\n\n    try {\n        xfs.mkdirSync(p, mode);\n        made = made || p;\n    }\n    catch (err0) {\n        switch (err0.code) {\n            case 'ENOENT' :\n                made = sync(path.dirname(p), opts, made);\n                sync(p, opts, made);\n                break;\n\n            // In the case of any other error, just see if there's a dir\n            // there already.  If so, then hooray!  If not, then something\n            // is borked.\n            default:\n                var stat;\n                try {\n                    stat = xfs.statSync(p);\n                }\n                catch (err1) {\n                    throw err0;\n                }\n                if (!stat.isDirectory()) throw err0;\n                break;\n        }\n    }\n\n    return made;\n};\n\n\n//# sourceURL=webpack:///./node_modules/mkdirp/index.js?")},"./node_modules/ms/index.js":
/*!**********************************!*\
  !*** ./node_modules/ms/index.js ***!
  \**********************************/
/*! no static exports found */function(module,exports){eval("/**\n * Helpers.\n */\n\nvar s = 1000;\nvar m = s * 60;\nvar h = m * 60;\nvar d = h * 24;\nvar y = d * 365.25;\n\n/**\n * Parse or format the given `val`.\n *\n * Options:\n *\n *  - `long` verbose formatting [false]\n *\n * @param {String|Number} val\n * @param {Object} [options]\n * @throws {Error} throw an error if val is not a non-empty string or a number\n * @return {String|Number}\n * @api public\n */\n\nmodule.exports = function(val, options) {\n  options = options || {};\n  var type = typeof val;\n  if (type === 'string' && val.length > 0) {\n    return parse(val);\n  } else if (type === 'number' && isNaN(val) === false) {\n    return options.long ? fmtLong(val) : fmtShort(val);\n  }\n  throw new Error(\n    'val is not a non-empty string or a valid number. val=' +\n      JSON.stringify(val)\n  );\n};\n\n/**\n * Parse the given `str` and return milliseconds.\n *\n * @param {String} str\n * @return {Number}\n * @api private\n */\n\nfunction parse(str) {\n  str = String(str);\n  if (str.length > 100) {\n    return;\n  }\n  var match = /^((?:\\d+)?\\.?\\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(\n    str\n  );\n  if (!match) {\n    return;\n  }\n  var n = parseFloat(match[1]);\n  var type = (match[2] || 'ms').toLowerCase();\n  switch (type) {\n    case 'years':\n    case 'year':\n    case 'yrs':\n    case 'yr':\n    case 'y':\n      return n * y;\n    case 'days':\n    case 'day':\n    case 'd':\n      return n * d;\n    case 'hours':\n    case 'hour':\n    case 'hrs':\n    case 'hr':\n    case 'h':\n      return n * h;\n    case 'minutes':\n    case 'minute':\n    case 'mins':\n    case 'min':\n    case 'm':\n      return n * m;\n    case 'seconds':\n    case 'second':\n    case 'secs':\n    case 'sec':\n    case 's':\n      return n * s;\n    case 'milliseconds':\n    case 'millisecond':\n    case 'msecs':\n    case 'msec':\n    case 'ms':\n      return n;\n    default:\n      return undefined;\n  }\n}\n\n/**\n * Short format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtShort(ms) {\n  if (ms >= d) {\n    return Math.round(ms / d) + 'd';\n  }\n  if (ms >= h) {\n    return Math.round(ms / h) + 'h';\n  }\n  if (ms >= m) {\n    return Math.round(ms / m) + 'm';\n  }\n  if (ms >= s) {\n    return Math.round(ms / s) + 's';\n  }\n  return ms + 'ms';\n}\n\n/**\n * Long format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtLong(ms) {\n  return plural(ms, d, 'day') ||\n    plural(ms, h, 'hour') ||\n    plural(ms, m, 'minute') ||\n    plural(ms, s, 'second') ||\n    ms + ' ms';\n}\n\n/**\n * Pluralization helper.\n */\n\nfunction plural(ms, n, name) {\n  if (ms < n) {\n    return;\n  }\n  if (ms < n * 1.5) {\n    return Math.floor(ms / n) + ' ' + name;\n  }\n  return Math.ceil(ms / n) + ' ' + name + 's';\n}\n\n\n//# sourceURL=webpack:///./node_modules/ms/index.js?")},"./node_modules/pify/index.js":
/*!************************************!*\
  !*** ./node_modules/pify/index.js ***!
  \************************************/
/*! no static exports found */function(module,exports,__webpack_require__){"use strict";eval("\n\nvar processFn = function (fn, P, opts) {\n\treturn function () {\n\t\tvar that = this;\n\t\tvar args = new Array(arguments.length);\n\n\t\tfor (var i = 0; i < arguments.length; i++) {\n\t\t\targs[i] = arguments[i];\n\t\t}\n\n\t\treturn new P(function (resolve, reject) {\n\t\t\targs.push(function (err, result) {\n\t\t\t\tif (err) {\n\t\t\t\t\treject(err);\n\t\t\t\t} else if (opts.multiArgs) {\n\t\t\t\t\tvar results = new Array(arguments.length - 1);\n\n\t\t\t\t\tfor (var i = 1; i < arguments.length; i++) {\n\t\t\t\t\t\tresults[i - 1] = arguments[i];\n\t\t\t\t\t}\n\n\t\t\t\t\tresolve(results);\n\t\t\t\t} else {\n\t\t\t\t\tresolve(result);\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tfn.apply(that, args);\n\t\t});\n\t};\n};\n\nvar pify = module.exports = function (obj, P, opts) {\n\tif (typeof P !== 'function') {\n\t\topts = P;\n\t\tP = Promise;\n\t}\n\n\topts = opts || {};\n\topts.exclude = opts.exclude || [/.+Sync$/];\n\n\tvar filter = function (key) {\n\t\tvar match = function (pattern) {\n\t\t\treturn typeof pattern === 'string' ? key === pattern : pattern.test(key);\n\t\t};\n\n\t\treturn opts.include ? opts.include.some(match) : !opts.exclude.some(match);\n\t};\n\n\tvar ret = typeof obj === 'function' ? function () {\n\t\tif (opts.excludeMain) {\n\t\t\treturn obj.apply(this, arguments);\n\t\t}\n\n\t\treturn processFn(obj, P, opts).apply(this, arguments);\n\t} : {};\n\n\treturn Object.keys(obj).reduce(function (ret, key) {\n\t\tvar x = obj[key];\n\n\t\tret[key] = typeof x === 'function' && filter(key) ? processFn(x, P, opts) : x;\n\n\t\treturn ret;\n\t}, ret);\n};\n\npify.all = pify;\n\n\n//# sourceURL=webpack:///./node_modules/pify/index.js?")},"./node_modules/pseudomap/map.js":
/*!***************************************!*\
  !*** ./node_modules/pseudomap/map.js ***!
  \***************************************/
/*! no static exports found */function(module,exports,__webpack_require__){eval("if (process.env.npm_package_name === 'pseudomap' &&\n    process.env.npm_lifecycle_script === 'test')\n  process.env.TEST_PSEUDOMAP = 'true'\n\nif (typeof Map === 'function' && !process.env.TEST_PSEUDOMAP) {\n  module.exports = Map\n} else {\n  module.exports = __webpack_require__(/*! ./pseudomap */ \"./node_modules/pseudomap/pseudomap.js\")\n}\n\n\n//# sourceURL=webpack:///./node_modules/pseudomap/map.js?")},"./node_modules/pseudomap/pseudomap.js":
/*!*********************************************!*\
  !*** ./node_modules/pseudomap/pseudomap.js ***!
  \*********************************************/
/*! no static exports found */function(module,exports){eval("var hasOwnProperty = Object.prototype.hasOwnProperty\n\nmodule.exports = PseudoMap\n\nfunction PseudoMap (set) {\n  if (!(this instanceof PseudoMap)) // whyyyyyyy\n    throw new TypeError(\"Constructor PseudoMap requires 'new'\")\n\n  this.clear()\n\n  if (set) {\n    if ((set instanceof PseudoMap) ||\n        (typeof Map === 'function' && set instanceof Map))\n      set.forEach(function (value, key) {\n        this.set(key, value)\n      }, this)\n    else if (Array.isArray(set))\n      set.forEach(function (kv) {\n        this.set(kv[0], kv[1])\n      }, this)\n    else\n      throw new TypeError('invalid argument')\n  }\n}\n\nPseudoMap.prototype.forEach = function (fn, thisp) {\n  thisp = thisp || this\n  Object.keys(this._data).forEach(function (k) {\n    if (k !== 'size')\n      fn.call(thisp, this._data[k].value, this._data[k].key)\n  }, this)\n}\n\nPseudoMap.prototype.has = function (k) {\n  return !!find(this._data, k)\n}\n\nPseudoMap.prototype.get = function (k) {\n  var res = find(this._data, k)\n  return res && res.value\n}\n\nPseudoMap.prototype.set = function (k, v) {\n  set(this._data, k, v)\n}\n\nPseudoMap.prototype.delete = function (k) {\n  var res = find(this._data, k)\n  if (res) {\n    delete this._data[res._index]\n    this._data.size--\n  }\n}\n\nPseudoMap.prototype.clear = function () {\n  var data = Object.create(null)\n  data.size = 0\n\n  Object.defineProperty(this, '_data', {\n    value: data,\n    enumerable: false,\n    configurable: true,\n    writable: false\n  })\n}\n\nObject.defineProperty(PseudoMap.prototype, 'size', {\n  get: function () {\n    return this._data.size\n  },\n  set: function (n) {},\n  enumerable: true,\n  configurable: true\n})\n\nPseudoMap.prototype.values =\nPseudoMap.prototype.keys =\nPseudoMap.prototype.entries = function () {\n  throw new Error('iterators are not implemented in this version')\n}\n\n// Either identical, or both NaN\nfunction same (a, b) {\n  return a === b || a !== a && b !== b\n}\n\nfunction Entry (k, v, i) {\n  this.key = k\n  this.value = v\n  this._index = i\n}\n\nfunction find (data, k) {\n  for (var i = 0, s = '_' + k, key = s;\n       hasOwnProperty.call(data, key);\n       key = s + i++) {\n    if (same(data[key].key, k))\n      return data[key]\n  }\n}\n\nfunction set (data, k, v) {\n  for (var i = 0, s = '_' + k, key = s;\n       hasOwnProperty.call(data, key);\n       key = s + i++) {\n    if (same(data[key].key, k)) {\n      data[key].value = v\n      return\n    }\n  }\n  data.size++\n  data[key] = new Entry(k, v, key)\n}\n\n\n//# sourceURL=webpack:///./node_modules/pseudomap/pseudomap.js?")},"./src/electron.js":
/*!*************************!*\
  !*** ./src/electron.js ***!
  \*************************/
/*! no exports provided */function(module,__webpack_exports__,__webpack_require__){"use strict";eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var electron__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! electron */ \"electron\");\n/* harmony import */ var electron__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(electron__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var electron_compile__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! electron-compile */ \"./node_modules/electron-compile/lib/index.js\");\n/* harmony import */ var electron_compile__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(electron_compile__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! path */ \"path\");\n/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(path__WEBPACK_IMPORTED_MODULE_2__);\n\n\n\n\n// Keep a global reference of the window object, if you don't, the window will\n// be closed automatically when the JavaScript object is garbage collected.\nlet mainWindow;\nlet appIcon = null;\nlet authWindow;\nconst isDevMode = process.execPath.match(/[\\\\/]electron/);\n\nif (isDevMode) Object(electron_compile__WEBPACK_IMPORTED_MODULE_1__[\"enableLiveReload\"])({ strategy: 'react-hmr' });\n\nconst createWindow = async () => {\n  mainWindow = new electron__WEBPACK_IMPORTED_MODULE_0__[\"BrowserWindow\"]({\n    width: 1000,\n    height: 770,\n    minHeight: 600,\n    minWidth: 600,\n    show: false,\n    frame: true,\n    backgroundColor: '#f4f4f5',\n    title: 'Remotify',\n  });\n\n  authWindow = new electron__WEBPACK_IMPORTED_MODULE_0__[\"BrowserWindow\"]({\n    width: 550,\n    height: 500,\n    show: true,\n    minHeight: 310,\n    minWidth: 310,\n    frame: false,\n    backgroundColor: '#f4f4f5',\n    title: 'Remotify',\n  });\n\n  mainWindow.loadURL(`file://${__dirname}/index.html`);\n  // Open the DevTools.\n  if (isDevMode) {\n    mainWindow.webContents.openDevTools();\n  }\n\n  authWindow.loadURL(`file://${__dirname}/login.html`);\n  // Open the DevTools.\n  // if (isDevMode) {\n  //   mainWindow.webContents.openDevTools();\n  // }\n\n  // Emitted when the window is closed.\n  mainWindow.on('closed', () => {\n    // Dereference the window object, usually you would store windows\n    // in an array if your app supports multi windows, this is the time\n    // when you should delete the corresponding element.\n    mainWindow = null;\n  });\n};\n\n// This method will be called when Electron has finished\n// initialization and is ready to create browser windows.\n// Some APIs can only be used after this event occurs.\nelectron__WEBPACK_IMPORTED_MODULE_0__[\"app\"].on('ready', createWindow);\n\n// Quit when all windows are closed.\nelectron__WEBPACK_IMPORTED_MODULE_0__[\"app\"].on('window-all-closed', () => {\n  // On OS X it is common for applications and their menu bar\n  // to stay active until the user quits explicitly with Cmd + Q\n  if (process.platform !== 'darwin') {\n    electron__WEBPACK_IMPORTED_MODULE_0__[\"app\"].quit();\n  }\n});\n\n// console.log('hello');\n\nelectron__WEBPACK_IMPORTED_MODULE_0__[\"app\"].on('activate', () => {\n  // On OS X it's common to re-create a window in the app when the\n  // dock icon is clicked and there are no other windows open.\n  if (mainWindow === null) {\n    createWindow();\n  }\n});\n\n// In this file you can include the rest of your app's specific main process\n// code. You can also put them in separate files and import them here.\n\nelectron__WEBPACK_IMPORTED_MODULE_0__[\"ipcMain\"].on('authenticate-user', (event, arg) => {\n  authWindow.show();\n  mainWindow.hide();\n});\n\nelectron__WEBPACK_IMPORTED_MODULE_0__[\"ipcMain\"].on('authenticated', (event, arg) => {\n  authWindow.hide();\n  mainWindow.show();\n});\n\nelectron__WEBPACK_IMPORTED_MODULE_0__[\"ipcMain\"].on('create-tray', (event) => {\n  const icon = process.platform === 'win32' ? 'win.png' : 'win.png';\n  const iconPath = path__WEBPACK_IMPORTED_MODULE_2___default.a.join(__dirname, icon);\n  appIcon = new electron__WEBPACK_IMPORTED_MODULE_0__[\"Tray\"](iconPath);\n\n  const contextMenu = electron__WEBPACK_IMPORTED_MODULE_0__[\"Menu\"].buildFromTemplate([\n    {\n      label: 'Remove',\n      click: () => {\n        event.sender.send('remove-tray');\n      },\n    },\n  ]);\n\n  appIcon.setToolTip('Remotify');\n  appIcon.setContextMenu(contextMenu);\n});\n\nelectron__WEBPACK_IMPORTED_MODULE_0__[\"ipcMain\"].on('delete-tray', (event, arg) => {\n  appIcon.destroy();\n});\n\n\n//# sourceURL=webpack:///./src/electron.js?")},crypto:
/*!*************************!*\
  !*** external "crypto" ***!
  \*************************/
/*! no static exports found */function(module,exports){eval('module.exports = require("crypto");\n\n//# sourceURL=webpack:///external_%22crypto%22?')},electron:
/*!***************************!*\
  !*** external "electron" ***!
  \***************************/
/*! no static exports found */function(module,exports){eval('module.exports = require("electron");\n\n//# sourceURL=webpack:///external_%22electron%22?')},fs:
/*!*********************!*\
  !*** external "fs" ***!
  \*********************/
/*! no static exports found */function(module,exports){eval('module.exports = require("fs");\n\n//# sourceURL=webpack:///external_%22fs%22?')},module:
/*!*************************!*\
  !*** external "module" ***!
  \*************************/
/*! no static exports found */function(module,exports){eval('module.exports = require("module");\n\n//# sourceURL=webpack:///external_%22module%22?')},net:
/*!**********************!*\
  !*** external "net" ***!
  \**********************/
/*! no static exports found */function(module,exports){eval('module.exports = require("net");\n\n//# sourceURL=webpack:///external_%22net%22?')},path:
/*!***********************!*\
  !*** external "path" ***!
  \***********************/
/*! no static exports found */function(module,exports){eval('module.exports = require("path");\n\n//# sourceURL=webpack:///external_%22path%22?')},tty:
/*!**********************!*\
  !*** external "tty" ***!
  \**********************/
/*! no static exports found */function(module,exports){eval('module.exports = require("tty");\n\n//# sourceURL=webpack:///external_%22tty%22?')},url:
/*!**********************!*\
  !*** external "url" ***!
  \**********************/
/*! no static exports found */function(module,exports){eval('module.exports = require("url");\n\n//# sourceURL=webpack:///external_%22url%22?')},util:
/*!***********************!*\
  !*** external "util" ***!
  \***********************/
/*! no static exports found */function(module,exports){eval('module.exports = require("util");\n\n//# sourceURL=webpack:///external_%22util%22?')},zlib:
/*!***********************!*\
  !*** external "zlib" ***!
  \***********************/
/*! no static exports found */function(module,exports){eval('module.exports = require("zlib");\n\n//# sourceURL=webpack:///external_%22zlib%22?')}});